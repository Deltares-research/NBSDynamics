{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NBSDynamics documentation \u00b6 On this pages diverse information can be found related to this project. Project layout \u00b6 The project is currently being structured as follows: docs/ # Contains the documentation related to this project. guides/ # Contains the documentation related to installation, usage and contribution to this project. reference/ # Contains references to the modules. Docstrings will be used to generate automatically documentation. src/ biota_models/ # Module containing all biota species models that inherit or use the modules from core/ coral/ # Module containing the coral model definition. bioprocess/ # Contains all the different bio processes required by the coral model. model/ # Defines the coral model and related (such as constants). output/ # Contains the definition(s) of output parameters to save. simulation/ # The simulation classes for running different coral configurations. vegetation/ # Module containing the different vegetation model definitions. bioprocess/ # Contains all the different bio processes required by the vegetation model. model/ # Defines the vegetation model and related (such as constants). output/ # Contains the definition(s) of output parameters to save. simulation/ # The simulation classes for running different vegetation configurations. core/ # Module containing all the classes and methods of NBSDynamics. biota/ # The base class biota from which sub models can inherit. hydrodynamics/ # The different hydrodynamic models ('Transect', 'Delft3D', 'Reef0D', 'Reef1D') output/ # The base output models. simulation/ # The base simulation classes. tools/ # Module containing tools used by the coral_model module. test/ # Module based on pytest to mirror and test all the classes from src/ Version control \u00b6 Currently versioning is done with the help of commitizen using a tag system of v.Major.Minor.Patch . A the changelog.md is generated automatically. Project architecture \u00b6 At the moment of this edition (version v.0.5.1), the project has undergone several refactorings and is divided in different modules and components as explained in the 'Project layout' section. A summary of the architecture can be seen in the following 'reduced' class diagram: SimulationProtocol \u00b6 HydrodynamicProtocol \u00b6 CoralProtocol \u00b6 OutputProtocol \u00b6","title":"NBSDynamics documentation"},{"location":"#nbsdynamics-documentation","text":"On this pages diverse information can be found related to this project.","title":"NBSDynamics documentation"},{"location":"#project-layout","text":"The project is currently being structured as follows: docs/ # Contains the documentation related to this project. guides/ # Contains the documentation related to installation, usage and contribution to this project. reference/ # Contains references to the modules. Docstrings will be used to generate automatically documentation. src/ biota_models/ # Module containing all biota species models that inherit or use the modules from core/ coral/ # Module containing the coral model definition. bioprocess/ # Contains all the different bio processes required by the coral model. model/ # Defines the coral model and related (such as constants). output/ # Contains the definition(s) of output parameters to save. simulation/ # The simulation classes for running different coral configurations. vegetation/ # Module containing the different vegetation model definitions. bioprocess/ # Contains all the different bio processes required by the vegetation model. model/ # Defines the vegetation model and related (such as constants). output/ # Contains the definition(s) of output parameters to save. simulation/ # The simulation classes for running different vegetation configurations. core/ # Module containing all the classes and methods of NBSDynamics. biota/ # The base class biota from which sub models can inherit. hydrodynamics/ # The different hydrodynamic models ('Transect', 'Delft3D', 'Reef0D', 'Reef1D') output/ # The base output models. simulation/ # The base simulation classes. tools/ # Module containing tools used by the coral_model module. test/ # Module based on pytest to mirror and test all the classes from src/","title":"Project layout"},{"location":"#version-control","text":"Currently versioning is done with the help of commitizen using a tag system of v.Major.Minor.Patch . A the changelog.md is generated automatically.","title":"Version control"},{"location":"#project-architecture","text":"At the moment of this edition (version v.0.5.1), the project has undergone several refactorings and is divided in different modules and components as explained in the 'Project layout' section. A summary of the architecture can be seen in the following 'reduced' class diagram:","title":"Project architecture"},{"location":"#simulationprotocol","text":"","title":"SimulationProtocol"},{"location":"#hydrodynamicprotocol","text":"","title":"HydrodynamicProtocol"},{"location":"#coralprotocol","text":"","title":"CoralProtocol"},{"location":"#outputprotocol","text":"","title":"OutputProtocol"},{"location":"changelog/","text":"v0.9.2 (2022-06-14) \u00b6 docs: Manually updated documentation, restored commitizen configuration v0.9.1 (2022-06-14) \u00b6 Fix \u00b6 docs/reference : removed previous references (#84) v0.9.0 (2022-04-20) \u00b6 Feat \u00b6 veg_simulation2_species.py : Now all the biotawrappers will get the simulation constants when not providing biota-constants biota_wrapper.py : Added biota_wrapper concept to reduce code duplicity on multiple biota simulations Refactor \u00b6 src/biota_models/vegetation/simulation/veg_simulation_2species.py : changed vegetation simulutation to use the biota wrapper. multiplebiota : Refactored all multiplebiota protocol and models to include the BiotaWrapper concept v0.8.3 (2022-04-13) \u00b6 Refactor \u00b6 veg_model.py : Now we configure the fields using pydantic v0.8.2 (2022-04-13) \u00b6 Refactor \u00b6 veg_base_simulation.py;veg_delft3d_simulation.py : Changed vegetation simulation naming and reduced code duplicity src/core/simulation/simulation_protocol.py : Removed coral from being a simulation protocol parameter v0.8.1 (2022-04-13) \u00b6 Fix \u00b6 docs/reference : removed previous references (#84) v0.8.0-NBSDynamics_as_package (2021-11-19) \u00b6 v0.8.0 (2021-11-18) \u00b6 Feat \u00b6 RESHAPE as singleton (#73) v0.7.0 (2021-11-18) \u00b6 Feat \u00b6 fix bmi calls (#67) v0.6.0 (2021-11-17) \u00b6 Feat \u00b6 src/core/simulation/base_simulation.py : Added vanilla simulation, adapted reef models to be pydantic src/core/hydrodynamics/transect.py : Transect initializes now as a pydantic model. Smaller related refactorings src/core/hydrodynamics/delft3d.py : dll_path can be now manually set by the user src/core/hydrodynamics/delft3d.py : Now the user can input their own path to the dll to be run Fix \u00b6 src/core/simulation/coral_delft3d_simulation.py : Minor corrections to the outpoint definition src/core/hydrodynamics/delft3d.py : Minor fix to xy_coordinates inital values src/core/output/output_wrapper.py : Adapted output_wrapper to ensure an output_dir is given for all the output_model instances src/core/hydrodynamics/delft3d.py : Renamed method, added explanation of what needs to be done Refactor \u00b6 test/core/simulation : Removed unnecessary class method, adapted tests, fixed failing tests src/core/simulation/base_simulation.py : Adapted simulation logic to initate hydrodynamics in a pydantic way v0.5.1 (2021-11-16) \u00b6 Fix \u00b6 bio_process/test_morphology.py : removed bug from test fixture v0.5.0 (2021-11-15) \u00b6 Feat \u00b6 coral model as protocol (#66) simulation as protocol (#65) v0.4.0 (2021-11-15) \u00b6 Fix \u00b6 test/test_acceptance.py : corrected numpy usage src/core/output/output_wrapper.py : Output wrapper now creates the output dir if it was not there already Feat \u00b6 src/core/simulation.py;test/test_acceptance.py : Now simulations can delegate the initial setup of a hydrodynamic model, adapted test for d3d case src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/hydrodynamics/factory.py;src/core/simulation.py : Refactor output wrapper and simulation classes so they can be instantiated with less attributes v0.3.0 (2021-11-12) \u00b6 Feat \u00b6 Create test bmi coral (#63) v0.2.0 (2021-11-11) \u00b6 Fix \u00b6 src/core/environment.py;src/core/simulation.py;test/core/test_environment.py : Extended validation for dates so they can be added as string from the initialization src/core/output/output_wrapper.py : Now we add the dict attributes from the wrapper to the output models src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/simulation.py;test/core/output/test_wrapper.py : Now we correctly initialize the map_output model. Adapted test output wrapper src;test : Output model generates again the netcdf files correctly. src/tools/plot_output.py : Corrected call to plot tool Feat \u00b6 src/core/environment.py;src/core/simulation.py : Adapted environment and related classes to pydantic approach src/core/coral_model.py;src/core/simulation.py;test/test_acceptance.py : Coral integrated in simulation Refactor \u00b6 src/core/environment.py;src/core/simulation.py;test/core/test_simulation : Improved environment as class src/core/environment.py;src/core/output_model.py;src/core/simulation.py;test/core/test_output : Applying pydantic to Output model. src/core/simulation : Added validator to simulation constants property src/core/simulation.py;test/test_acceptance : Adapted code for better pydantic usage src/core/output_model : Fixed failing tests for TestOutput src/core/output_model : Minor corrections to the model src/core/output_model : Small fix, however model still not running. src/core/output_model : fixed ini/update his/map src/core/environment : Added extra logic to accept str as path. src/core/output/output_model : Extracted two submodels from Output, moved into its own module. src/core/output/output_protocol.py;src/core/output/output_wrapper : Separating concepts to avoid code duplication src/core/output/output_model.py;src/core/output/output_protocol.py;src/core/output/output_wrapper : Refactor output module for better maintainability and reducing its complexity. test/core/output/test_wrapper : Moved test to mirror src structure src/core/output/ : Extended docstrings for output_protocol; Generated coverage tests for output_model. Fixed simulation calls to output initialization. test_output_wrapper : Renamed filename to match src tested file v0.1.4 (2021-11-11) \u00b6 Fix \u00b6 quality gate fix (#62) Feat \u00b6 Create model input v0.1.3 (2021-11-08) \u00b6 Refactor \u00b6 src/core/coral_only.py : Extracted coral only for better maintainability. src/core/output_model.py;src/core/utils.py : further type hinting. src/core/output_model.py : Fixed setting of xy_stations. core/utils.py : Added more type hinting. core/utils.py : Adding type hints. core/loop.py;core/output_model.py;core/utils.py : Extracted output model logic into its own class. Introduced new libraries. v0.1.2 (2021-11-05) \u00b6 v0.1.1 (2021-11-05) \u00b6 Fix \u00b6 .github/workflows/ci.yml : improve code coverage (#44) v0.1.0 (2021-11-04) \u00b6 Fix \u00b6 Fix merged conflict Feat \u00b6 Pull-request 31 normalize versioning (#42) v0.0.4 (2021-11-04) \u00b6 Fix \u00b6 pyproject.toml : Corrected version file for core directory. pyproject.toml : Changed bump pattern and map to include refactor and docs. v0.0.3 (2021-11-04) \u00b6 Refactor \u00b6 hydrodynamics.py : Refactor the update method to use update_ (#30) v0.0.2 (2021-10-29) \u00b6 Fix \u00b6 environment.py-utils.py : Fixed bugs described in sonarcloud (#26) Removed-unused-reference. : removed unused reference","title":"Changelog"},{"location":"changelog/#v092-2022-06-14","text":"docs: Manually updated documentation, restored commitizen configuration","title":"v0.9.2 (2022-06-14)"},{"location":"changelog/#v091-2022-06-14","text":"","title":"v0.9.1 (2022-06-14)"},{"location":"changelog/#fix","text":"docs/reference : removed previous references (#84)","title":"Fix"},{"location":"changelog/#v090-2022-04-20","text":"","title":"v0.9.0 (2022-04-20)"},{"location":"changelog/#feat","text":"veg_simulation2_species.py : Now all the biotawrappers will get the simulation constants when not providing biota-constants biota_wrapper.py : Added biota_wrapper concept to reduce code duplicity on multiple biota simulations","title":"Feat"},{"location":"changelog/#refactor","text":"src/biota_models/vegetation/simulation/veg_simulation_2species.py : changed vegetation simulutation to use the biota wrapper. multiplebiota : Refactored all multiplebiota protocol and models to include the BiotaWrapper concept","title":"Refactor"},{"location":"changelog/#v083-2022-04-13","text":"","title":"v0.8.3 (2022-04-13)"},{"location":"changelog/#refactor_1","text":"veg_model.py : Now we configure the fields using pydantic","title":"Refactor"},{"location":"changelog/#v082-2022-04-13","text":"","title":"v0.8.2 (2022-04-13)"},{"location":"changelog/#refactor_2","text":"veg_base_simulation.py;veg_delft3d_simulation.py : Changed vegetation simulation naming and reduced code duplicity src/core/simulation/simulation_protocol.py : Removed coral from being a simulation protocol parameter","title":"Refactor"},{"location":"changelog/#v081-2022-04-13","text":"","title":"v0.8.1 (2022-04-13)"},{"location":"changelog/#fix_1","text":"docs/reference : removed previous references (#84)","title":"Fix"},{"location":"changelog/#v080-nbsdynamics_as_package-2021-11-19","text":"","title":"v0.8.0-NBSDynamics_as_package (2021-11-19)"},{"location":"changelog/#v080-2021-11-18","text":"","title":"v0.8.0 (2021-11-18)"},{"location":"changelog/#feat_1","text":"RESHAPE as singleton (#73)","title":"Feat"},{"location":"changelog/#v070-2021-11-18","text":"","title":"v0.7.0 (2021-11-18)"},{"location":"changelog/#feat_2","text":"fix bmi calls (#67)","title":"Feat"},{"location":"changelog/#v060-2021-11-17","text":"","title":"v0.6.0 (2021-11-17)"},{"location":"changelog/#feat_3","text":"src/core/simulation/base_simulation.py : Added vanilla simulation, adapted reef models to be pydantic src/core/hydrodynamics/transect.py : Transect initializes now as a pydantic model. Smaller related refactorings src/core/hydrodynamics/delft3d.py : dll_path can be now manually set by the user src/core/hydrodynamics/delft3d.py : Now the user can input their own path to the dll to be run","title":"Feat"},{"location":"changelog/#fix_2","text":"src/core/simulation/coral_delft3d_simulation.py : Minor corrections to the outpoint definition src/core/hydrodynamics/delft3d.py : Minor fix to xy_coordinates inital values src/core/output/output_wrapper.py : Adapted output_wrapper to ensure an output_dir is given for all the output_model instances src/core/hydrodynamics/delft3d.py : Renamed method, added explanation of what needs to be done","title":"Fix"},{"location":"changelog/#refactor_3","text":"test/core/simulation : Removed unnecessary class method, adapted tests, fixed failing tests src/core/simulation/base_simulation.py : Adapted simulation logic to initate hydrodynamics in a pydantic way","title":"Refactor"},{"location":"changelog/#v051-2021-11-16","text":"","title":"v0.5.1 (2021-11-16)"},{"location":"changelog/#fix_3","text":"bio_process/test_morphology.py : removed bug from test fixture","title":"Fix"},{"location":"changelog/#v050-2021-11-15","text":"","title":"v0.5.0 (2021-11-15)"},{"location":"changelog/#feat_4","text":"coral model as protocol (#66) simulation as protocol (#65)","title":"Feat"},{"location":"changelog/#v040-2021-11-15","text":"","title":"v0.4.0 (2021-11-15)"},{"location":"changelog/#fix_4","text":"test/test_acceptance.py : corrected numpy usage src/core/output/output_wrapper.py : Output wrapper now creates the output dir if it was not there already","title":"Fix"},{"location":"changelog/#feat_5","text":"src/core/simulation.py;test/test_acceptance.py : Now simulations can delegate the initial setup of a hydrodynamic model, adapted test for d3d case src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/hydrodynamics/factory.py;src/core/simulation.py : Refactor output wrapper and simulation classes so they can be instantiated with less attributes","title":"Feat"},{"location":"changelog/#v030-2021-11-12","text":"","title":"v0.3.0 (2021-11-12)"},{"location":"changelog/#feat_6","text":"Create test bmi coral (#63)","title":"Feat"},{"location":"changelog/#v020-2021-11-11","text":"","title":"v0.2.0 (2021-11-11)"},{"location":"changelog/#fix_5","text":"src/core/environment.py;src/core/simulation.py;test/core/test_environment.py : Extended validation for dates so they can be added as string from the initialization src/core/output/output_wrapper.py : Now we add the dict attributes from the wrapper to the output models src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/simulation.py;test/core/output/test_wrapper.py : Now we correctly initialize the map_output model. Adapted test output wrapper src;test : Output model generates again the netcdf files correctly. src/tools/plot_output.py : Corrected call to plot tool","title":"Fix"},{"location":"changelog/#feat_7","text":"src/core/environment.py;src/core/simulation.py : Adapted environment and related classes to pydantic approach src/core/coral_model.py;src/core/simulation.py;test/test_acceptance.py : Coral integrated in simulation","title":"Feat"},{"location":"changelog/#refactor_4","text":"src/core/environment.py;src/core/simulation.py;test/core/test_simulation : Improved environment as class src/core/environment.py;src/core/output_model.py;src/core/simulation.py;test/core/test_output : Applying pydantic to Output model. src/core/simulation : Added validator to simulation constants property src/core/simulation.py;test/test_acceptance : Adapted code for better pydantic usage src/core/output_model : Fixed failing tests for TestOutput src/core/output_model : Minor corrections to the model src/core/output_model : Small fix, however model still not running. src/core/output_model : fixed ini/update his/map src/core/environment : Added extra logic to accept str as path. src/core/output/output_model : Extracted two submodels from Output, moved into its own module. src/core/output/output_protocol.py;src/core/output/output_wrapper : Separating concepts to avoid code duplication src/core/output/output_model.py;src/core/output/output_protocol.py;src/core/output/output_wrapper : Refactor output module for better maintainability and reducing its complexity. test/core/output/test_wrapper : Moved test to mirror src structure src/core/output/ : Extended docstrings for output_protocol; Generated coverage tests for output_model. Fixed simulation calls to output initialization. test_output_wrapper : Renamed filename to match src tested file","title":"Refactor"},{"location":"changelog/#v014-2021-11-11","text":"","title":"v0.1.4 (2021-11-11)"},{"location":"changelog/#fix_6","text":"quality gate fix (#62)","title":"Fix"},{"location":"changelog/#feat_8","text":"Create model input","title":"Feat"},{"location":"changelog/#v013-2021-11-08","text":"","title":"v0.1.3 (2021-11-08)"},{"location":"changelog/#refactor_5","text":"src/core/coral_only.py : Extracted coral only for better maintainability. src/core/output_model.py;src/core/utils.py : further type hinting. src/core/output_model.py : Fixed setting of xy_stations. core/utils.py : Added more type hinting. core/utils.py : Adding type hints. core/loop.py;core/output_model.py;core/utils.py : Extracted output model logic into its own class. Introduced new libraries.","title":"Refactor"},{"location":"changelog/#v012-2021-11-05","text":"","title":"v0.1.2 (2021-11-05)"},{"location":"changelog/#v011-2021-11-05","text":"","title":"v0.1.1 (2021-11-05)"},{"location":"changelog/#fix_7","text":".github/workflows/ci.yml : improve code coverage (#44)","title":"Fix"},{"location":"changelog/#v010-2021-11-04","text":"","title":"v0.1.0 (2021-11-04)"},{"location":"changelog/#fix_8","text":"Fix merged conflict","title":"Fix"},{"location":"changelog/#feat_9","text":"Pull-request 31 normalize versioning (#42)","title":"Feat"},{"location":"changelog/#v004-2021-11-04","text":"","title":"v0.0.4 (2021-11-04)"},{"location":"changelog/#fix_9","text":"pyproject.toml : Corrected version file for core directory. pyproject.toml : Changed bump pattern and map to include refactor and docs.","title":"Fix"},{"location":"changelog/#v003-2021-11-04","text":"","title":"v0.0.3 (2021-11-04)"},{"location":"changelog/#refactor_6","text":"hydrodynamics.py : Refactor the update method to use update_ (#30)","title":"Refactor"},{"location":"changelog/#v002-2021-10-29","text":"","title":"v0.0.2 (2021-10-29)"},{"location":"changelog/#fix_10","text":"environment.py-utils.py : Fixed bugs described in sonarcloud (#26) Removed-unused-reference. : removed unused reference","title":"Fix"},{"location":"guides/contribute/","text":"How to contribute to NBSDynamics \u00b6 1. Tooling \u00b6 In this section we describe which tools this repository relays on to guarantee a standardized development. 1.1. Development environment. \u00b6 In order to develop on this project it is recommended the usage of a virtual environment. This can be easily achieved by using poetry (see below). Poetry \u00b6 We use poetry to manage our package and its dependencies, which you can download here . After installation, make sure it's available on your PATH and run it in the HYDROLIB-core directory in your shell of choice. To install the package (by default in editable mode) run poetry install . We advise using virtualenv s, Poetry will create one for you. If you need to use an already existing Python installation, you can activate it and run poetry env use system before poetry install . Pip \u00b6 Latest versions of pip support installing packages from a .toml file. This streamlines the process so that you do not need to use poetry (although we highly recommend it in order to add packages that are compliant with the rest of the repository). You can easily develop your own features using the pip edit mode from the root of the NBSDynamics checked out repository: pip install -e . Known issues \u00b6 We found out that packages such as netcdf4 or pypiwin32 / pywin32 might give problems. In case you run against said problems while installing the package we recommend installing them beforehand. 1.2. Code convention / Linters \u00b6 This project uses both black and isort as an autoformatter. It is recommended following the rules defined in pyproject.toml to avoid conflicts before a merge. 1.2.1. Black \u00b6 We use black as an autoformatter. Black will curate the code follows the PEP8 convention. It is also run during CI and will fail if it's not formatted beforehand. 1.2.2. Isort \u00b6 We use isort as an autoformatter. Isort will curate the imports of each module are ordered. It is also run during CI and will fail if it's not formatted beforehand. 1.3. Continuous Integration \u00b6 Each commit made on a branch of the repository gets analyzed with Sonar Cloud . Before merging, the following rules should be fulfilled regarding new code: - Code coverage remains does not drop. - No new bugs introduced. - No new code smells introduced. - No new vulnerabilities introduced. - No new security hotspots introduced. - No new duplications of code. 1.4. Testing \u00b6 New code should be tested. As a rule of thumb public methods should be tested with unit tests and new workflows with integration tests. Acceptance tests are recommended when introducing new models. We use pytest to test our package. Run it with poetry run pytest to test your code changes locally. 1.5. Version Control \u00b6 We use commitizen to automatically bump the version number. If you use conventional commit messages , the the changelog.md is generated automatically. 1.6. Documentation \u00b6 We use mkdocs to automatically generate documentation. We define documentation in separate sections: /guides: where we include information on how to use the repository, either as maintainer or as user. /reference: where the technical documentation is linked. When creating a new module a new markdown file should be created. To refer to a module, it can be done as follows: ### core ::: src.core.core This will generate documentation based on the docstrings of each class and method in src.core.core.py changelog.md: file automatically generated and updated with the commits to master (see Version Control ) 2. Development. \u00b6 In this section we describe how development is expected to be done in this repository. 2.1. Branches \u00b6 For each issue or feature, a separate branch should be created from the main. To keep the branches organized a feature branch should be created with the feature/ prefix. When starting development on a branch, a pull request should be created for reviews and continous integration. During continuous integration, the checks will be run with python 3.8 on Windows, Ubuntu and MacOS. The checks consist of running the tests, checking the code formatting and running SonarCloud. We advise to use a draft pull request, to prevent the branch to be merged back before developement is finished. When the branch is ready for review, you can update the status of the pull request to \"ready for review\". 2.2. Reviews \u00b6 Reviews should be dona by a member of the development team on a pull-request prior to its merging. 2.3. Merging \u00b6 Merging a branch can only happen when a pull request is accepted through review. When a pull request is accepted the changes should be merged back with the \"squash and merge\" option. 2.4. Coding guidelines \u00b6 Classes and methods should make use of docstrings. If there are any additions or changes to the public API, the documentation should be updated. Files should be added to the appropriate folder to keep modules and objects within the correct scope. If there is code that needs to be tested, there should be tests written for it. Tests should be added \"mirroring\" the structure of src for a cohesive project layout.","title":"How to contribute to NBSDynamics"},{"location":"guides/contribute/#how-to-contribute-to-nbsdynamics","text":"","title":"How to contribute to NBSDynamics"},{"location":"guides/contribute/#1-tooling","text":"In this section we describe which tools this repository relays on to guarantee a standardized development.","title":"1. Tooling"},{"location":"guides/contribute/#11-development-environment","text":"In order to develop on this project it is recommended the usage of a virtual environment. This can be easily achieved by using poetry (see below).","title":"1.1. Development environment."},{"location":"guides/contribute/#poetry","text":"We use poetry to manage our package and its dependencies, which you can download here . After installation, make sure it's available on your PATH and run it in the HYDROLIB-core directory in your shell of choice. To install the package (by default in editable mode) run poetry install . We advise using virtualenv s, Poetry will create one for you. If you need to use an already existing Python installation, you can activate it and run poetry env use system before poetry install .","title":"Poetry"},{"location":"guides/contribute/#pip","text":"Latest versions of pip support installing packages from a .toml file. This streamlines the process so that you do not need to use poetry (although we highly recommend it in order to add packages that are compliant with the rest of the repository). You can easily develop your own features using the pip edit mode from the root of the NBSDynamics checked out repository: pip install -e .","title":"Pip"},{"location":"guides/contribute/#known-issues","text":"We found out that packages such as netcdf4 or pypiwin32 / pywin32 might give problems. In case you run against said problems while installing the package we recommend installing them beforehand.","title":"Known issues"},{"location":"guides/contribute/#12-code-convention-linters","text":"This project uses both black and isort as an autoformatter. It is recommended following the rules defined in pyproject.toml to avoid conflicts before a merge.","title":"1.2. Code convention / Linters"},{"location":"guides/contribute/#121-black","text":"We use black as an autoformatter. Black will curate the code follows the PEP8 convention. It is also run during CI and will fail if it's not formatted beforehand.","title":"1.2.1. Black"},{"location":"guides/contribute/#122-isort","text":"We use isort as an autoformatter. Isort will curate the imports of each module are ordered. It is also run during CI and will fail if it's not formatted beforehand.","title":"1.2.2. Isort"},{"location":"guides/contribute/#13-continuous-integration","text":"Each commit made on a branch of the repository gets analyzed with Sonar Cloud . Before merging, the following rules should be fulfilled regarding new code: - Code coverage remains does not drop. - No new bugs introduced. - No new code smells introduced. - No new vulnerabilities introduced. - No new security hotspots introduced. - No new duplications of code.","title":"1.3. Continuous Integration"},{"location":"guides/contribute/#14-testing","text":"New code should be tested. As a rule of thumb public methods should be tested with unit tests and new workflows with integration tests. Acceptance tests are recommended when introducing new models. We use pytest to test our package. Run it with poetry run pytest to test your code changes locally.","title":"1.4. Testing"},{"location":"guides/contribute/#15-version-control","text":"We use commitizen to automatically bump the version number. If you use conventional commit messages , the the changelog.md is generated automatically.","title":"1.5. Version Control"},{"location":"guides/contribute/#16-documentation","text":"We use mkdocs to automatically generate documentation. We define documentation in separate sections: /guides: where we include information on how to use the repository, either as maintainer or as user. /reference: where the technical documentation is linked. When creating a new module a new markdown file should be created. To refer to a module, it can be done as follows: ### core ::: src.core.core This will generate documentation based on the docstrings of each class and method in src.core.core.py changelog.md: file automatically generated and updated with the commits to master (see Version Control )","title":"1.6. Documentation"},{"location":"guides/contribute/#2-development","text":"In this section we describe how development is expected to be done in this repository.","title":"2. Development."},{"location":"guides/contribute/#21-branches","text":"For each issue or feature, a separate branch should be created from the main. To keep the branches organized a feature branch should be created with the feature/ prefix. When starting development on a branch, a pull request should be created for reviews and continous integration. During continuous integration, the checks will be run with python 3.8 on Windows, Ubuntu and MacOS. The checks consist of running the tests, checking the code formatting and running SonarCloud. We advise to use a draft pull request, to prevent the branch to be merged back before developement is finished. When the branch is ready for review, you can update the status of the pull request to \"ready for review\".","title":"2.1. Branches"},{"location":"guides/contribute/#22-reviews","text":"Reviews should be dona by a member of the development team on a pull-request prior to its merging.","title":"2.2. Reviews"},{"location":"guides/contribute/#23-merging","text":"Merging a branch can only happen when a pull request is accepted through review. When a pull request is accepted the changes should be merged back with the \"squash and merge\" option.","title":"2.3. Merging"},{"location":"guides/contribute/#24-coding-guidelines","text":"Classes and methods should make use of docstrings. If there are any additions or changes to the public API, the documentation should be updated. Files should be added to the appropriate folder to keep modules and objects within the correct scope. If there is code that needs to be tested, there should be tests written for it. Tests should be added \"mirroring\" the structure of src for a cohesive project layout.","title":"2.4. Coding guidelines"},{"location":"guides/run_simulation/","text":"How to create and run a simulation in NBSDynamics \u00b6 The current package offers the user the possibility to run a simulation with the built-in simulation types, or to create their own simulation with their custom attributes. 1. Simulation structure. \u00b6 A simulation is based on the SimulationProtocol . Thus its required attributes are as follows: Constants . Definition of constants to be used during the simulation. Biota . Required to represent a biota entity in the simulation. Environment . Hydrodynamics . Defines the type of simulation that will be run. As per version v0.8.0 the following types are available: Reef0D Reef1D Transect Delft3D . Simulation through usage of a BMI runner: Delft3D - FlowFMModel . Currently under work. Delft3D - DimrModel . Currently under work. Output . Required to define what output should be stored, how, where and when. 2. 'Vanilla' Simulation. \u00b6 The user has the possibility to create its custom simulation by calling to the most simple simulation class Simulation . This class allows the user to combine their own set of Constants , Coral , Environment , Hydrodynamics and Output and then call the predefined initiate , run or finalise methods. Keep in mind this way of running a simulation implies the user will have to manually configure the Simulation attributes. 3. Built-in Simulations. \u00b6 A built-in simulation allows the user to only worry about given the required input parameters and then letting the object pre-configure all the data as required for a regular run. Available \u00b6 As per version NBSDynamics v.0.8.1 the following simulations are fully validated: Coral Transect Simulation Vegetation Delft3D Simulation","title":"How to create and run a simulation in NBSDynamics"},{"location":"guides/run_simulation/#how-to-create-and-run-a-simulation-in-nbsdynamics","text":"The current package offers the user the possibility to run a simulation with the built-in simulation types, or to create their own simulation with their custom attributes.","title":"How to create and run a simulation in NBSDynamics"},{"location":"guides/run_simulation/#1-simulation-structure","text":"A simulation is based on the SimulationProtocol . Thus its required attributes are as follows: Constants . Definition of constants to be used during the simulation. Biota . Required to represent a biota entity in the simulation. Environment . Hydrodynamics . Defines the type of simulation that will be run. As per version v0.8.0 the following types are available: Reef0D Reef1D Transect Delft3D . Simulation through usage of a BMI runner: Delft3D - FlowFMModel . Currently under work. Delft3D - DimrModel . Currently under work. Output . Required to define what output should be stored, how, where and when.","title":"1. Simulation structure."},{"location":"guides/run_simulation/#2-vanilla-simulation","text":"The user has the possibility to create its custom simulation by calling to the most simple simulation class Simulation . This class allows the user to combine their own set of Constants , Coral , Environment , Hydrodynamics and Output and then call the predefined initiate , run or finalise methods. Keep in mind this way of running a simulation implies the user will have to manually configure the Simulation attributes.","title":"2. 'Vanilla' Simulation."},{"location":"guides/run_simulation/#3-built-in-simulations","text":"A built-in simulation allows the user to only worry about given the required input parameters and then letting the object pre-configure all the data as required for a regular run.","title":"3. Built-in Simulations."},{"location":"guides/run_simulation/#available","text":"As per version NBSDynamics v.0.8.1 the following simulations are fully validated: Coral Transect Simulation Vegetation Delft3D Simulation","title":"Available"},{"location":"guides/run_simulation_coral/","text":"How to run a Coral Simulation \u00b6 We have defined an intermediate (internal) CoralSimulation object. This one allows us to easily implement other simulation configurations by simply changing its hydrodynamic properties. Currently we offer definitions for Coral Transect and Coral Delft3D configurations. Coral Transect Simulation \u00b6 A simulation using the CoralTransectSimulation object. Which will build the simulation around a Transect hydrodynamic model. We provide here an example (currently used for testing) of its usage with a Pydantic approach: # 1. Define attributes. test_dir = Path ( \"transect_run\" ) input_dir = test_dir / \"input\" output_dir = test_dir / \"output\" # 2. Prepare model. # Define the basic Simulation object, indicating already here the type of hydrodynamics run_trans = CoralTransectSimulation ( working_dir = test_dir , constants = input_dir / \"coral_input.txt\" , environment = dict ( light = input_dir / \"TS_PAR.txt\" , temperature = input_dir / \"TS_SST.txt\" , storm = input_dir / \"TS_stormcat2.txt\" , dates = ( \"2000-01-01\" , \"2100-01-01\" ), ), hydrodynamics = dict ( definition_file = input_dir / \"TS_waves.txt\" , config_file = input_dir / \"config.csv\" , ), output = dict ( output_dir = test_dir / \"output\" , map_output = dict ( output_params = dict ( fme = False )), his_output = dict ( output_params = dict ( fme = False )), ), biota = dict ( dc = 0.125 , hc = 0.125 , bc = 0.1 , tc = 0.1 , ac = 0.2 , Csp = 0.6 , ), ) # 3. Run simulation run_trans . initiate () run_trans . run () run_trans . finalise () Work in progress \u00b6 The following simulations are defined, however their status is not yet final and can therefore not be guaranteed to work. Coral FlowFm Simulation \u00b6 Open issue: #68 Fix Delft3D - FlowFMModel run. A simulation using the CoralFlowFmSimulation object. Which will build the simulation around a FlowFMModel hydrodynamic model. Coral Dimr Simulation \u00b6 Open issue: #69 Fix / Implement Delft3D - DIMR run. A simulation using the CoralDimrSimulation object. Which will build the simulation around a DimrModel hydrodynamic model.","title":"How to run a Coral Simulation"},{"location":"guides/run_simulation_coral/#how-to-run-a-coral-simulation","text":"We have defined an intermediate (internal) CoralSimulation object. This one allows us to easily implement other simulation configurations by simply changing its hydrodynamic properties. Currently we offer definitions for Coral Transect and Coral Delft3D configurations.","title":"How to run a Coral Simulation"},{"location":"guides/run_simulation_coral/#coral-transect-simulation","text":"A simulation using the CoralTransectSimulation object. Which will build the simulation around a Transect hydrodynamic model. We provide here an example (currently used for testing) of its usage with a Pydantic approach: # 1. Define attributes. test_dir = Path ( \"transect_run\" ) input_dir = test_dir / \"input\" output_dir = test_dir / \"output\" # 2. Prepare model. # Define the basic Simulation object, indicating already here the type of hydrodynamics run_trans = CoralTransectSimulation ( working_dir = test_dir , constants = input_dir / \"coral_input.txt\" , environment = dict ( light = input_dir / \"TS_PAR.txt\" , temperature = input_dir / \"TS_SST.txt\" , storm = input_dir / \"TS_stormcat2.txt\" , dates = ( \"2000-01-01\" , \"2100-01-01\" ), ), hydrodynamics = dict ( definition_file = input_dir / \"TS_waves.txt\" , config_file = input_dir / \"config.csv\" , ), output = dict ( output_dir = test_dir / \"output\" , map_output = dict ( output_params = dict ( fme = False )), his_output = dict ( output_params = dict ( fme = False )), ), biota = dict ( dc = 0.125 , hc = 0.125 , bc = 0.1 , tc = 0.1 , ac = 0.2 , Csp = 0.6 , ), ) # 3. Run simulation run_trans . initiate () run_trans . run () run_trans . finalise ()","title":"Coral Transect Simulation"},{"location":"guides/run_simulation_coral/#work-in-progress","text":"The following simulations are defined, however their status is not yet final and can therefore not be guaranteed to work.","title":"Work in progress"},{"location":"guides/run_simulation_coral/#coral-flowfm-simulation","text":"Open issue: #68 Fix Delft3D - FlowFMModel run. A simulation using the CoralFlowFmSimulation object. Which will build the simulation around a FlowFMModel hydrodynamic model.","title":"Coral FlowFm Simulation"},{"location":"guides/run_simulation_coral/#coral-dimr-simulation","text":"Open issue: #69 Fix / Implement Delft3D - DIMR run. A simulation using the CoralDimrSimulation object. Which will build the simulation around a DimrModel hydrodynamic model.","title":"Coral Dimr Simulation"},{"location":"guides/run_simulation_veg/","text":"How to run a Vegetation simulation \u00b6 To fully understand how to create a simulation object in NBSDynamics we recommend first going through the basic guideline How to create and run a simulation . An example of how a simulation is run can be found in the acceptance tests. 1. Simulation structure. \u00b6 The Vegetation Delft3d Simulation is a concrete implementation of the BaseSimulation which implements the SimulationProtocol already described in the previous mentioned guide . As such, we are allowed to define our own interpretations of the simulation. Here is how we build a Vegetation simulation: Constants -> VegetationConstants . Different species are defined through different constant values, as well as time related constants (e.g. start time and ecological time steps). To initialize the object at least a valid species name is required. This class will load its values looking for the default vegetation constants file . We also allow the user to load their own file by doing the following: VegetationConstants ( species = 'Salicornia' , input_file = 'your_json_filepath_here.json' ) Further species can be added by defining their specific parameters using constants_json_create . Biota -> Vegetation This biota also includes extra characteristics such as LifeStages . Environment -> None (we do not need it for this simulation). Hydrodynamics -> Either of the following two: Delft3D - FlowFMModel . Delft3D - DimrModel . Output -> VegetationOutputWrapper . Our custom wrapper ensures the required output variables are stored to be later evaluated. 2. Simulation steps. \u00b6 When the previous paramaters have been correctly assigned to the object, the simulation is started by using the required methods from BaseSimulation and defined in VegFlowFmSimulation : Initiate: Configures hydrodynamics and output Validates simulation directories Initiated vegetation characteristics for all life stages in the class LifeStages initializes the output VegetationOutputWrapper . Run: When calling the run method (sim_run.run()) , the duration of the simulation needs to be specified (in years) (e.g. sim_run.run(5) ) If duration is not given, the duration specified in the VegetationConstants class will be used. The start date is set to the date specified in VegetationConstants . end date = start date + duration. A loop is started over the duration of the simulation (years). Another loop iterates within the previous over the number of ecological time steps per year (coupling times per year) specified in VegetationConstants . To get the hydro and morphological variables from Delft-FM, the hydro-morphodynamics are retrieved every day. The coupling and retrieving of the values is specified in the class Delft3D Aggregated values are then created in the class Hydro_Morphodynamics and retrieved via the method 'get_hydromorph_values' The vegetation dynamics are initiated: Mortality and Growth criteria for mortality and mortality fractions are determined based on the species and the morpho- & hydrodynamics vegetation growth is initiated based on the number of growth days within the current ecological time step Colonisation method is only called when colonisation is possible during the specific period of the ecological time step criteria for colonisation are determined based on the species and the morpho- & hydrodynamics the vegetation characteristics of the initial lifestage are updated based on the possible colonisation Update_Lifestages the life stages are updates (initial to juvenile and juvenile to mature) initial to juvenile always occurs when new vegetation colonized juvenile to mature only occurs when vegetation in the juvenile stage reached the maximum years in that life stage if the maximum age of vegetation is reached, the vegetation is removed The results are exported using the methods defined in VegetationMapOutput and VegetationHisOutput Finalize (Finalize simulation). Vegetation Delft3D Simulation Example \u00b6 A simulation using the VegFlowFmSimulation object. This example is in our test bench, although we only run it locally due to the DIMR dependencies not being available at the repo level, and makes use of a Pydantic approach to simplify how to initialize an object. from src.biota_models.vegetation.model.veg_constants import VegetationConstants from src.biota_models.vegetation.model.veg_model import Vegetation from src.biota_models.vegetation.simulation.veg_delft3d_simulation import ( VegFlowFmSimulation , ) # 1. Define attributes test_dir = TestUtils . get_local_test_data_dir ( \"sm_testcase6\" ) # We need to specify where the DIMR directory (WITH ALL THE SHARED BINARIES) is located. dll_repo = TestUtils . get_external_repo ( \"DimrDllDependencies\" ) kernels_dir = dll_repo / \"kernels\" output_dir = test_dir / \"output\" test_case = test_dir / \"input\" / \"MinFiles\" # 2. Prepare model. # Create vegetation constants based on the above species. veg_constants = VegetationConstants ( species = \"Salicornia\" ) sim_run = VegFlowFmSimulation ( working_dir = test_dir , constants = veg_constants , hydrodynamics = dict ( working_dir = test_dir / \"d3d_work\" , d3d_home = kernels_dir , dll_path = kernels_dir / \"dflowfm_with_shared\" / \"bin\" / \"dflowfm.dll\" , definition_file = test_case / \"fm\" / \"test_case6.mdu\" , ), output = dict ( output_dir = output_dir , map_output = dict ( output_params = dict ()), his_output = dict ( output_params = dict (), ), ), biota = Vegetation ( species = \"Salicornia\" , constants = veg_constants ), ) # 3. Run simulation. sim_run . initiate () sim_run . run () sim_run . finalise ()","title":"How to run a Vegetation simulation"},{"location":"guides/run_simulation_veg/#how-to-run-a-vegetation-simulation","text":"To fully understand how to create a simulation object in NBSDynamics we recommend first going through the basic guideline How to create and run a simulation . An example of how a simulation is run can be found in the acceptance tests.","title":"How to run a Vegetation simulation"},{"location":"guides/run_simulation_veg/#1-simulation-structure","text":"The Vegetation Delft3d Simulation is a concrete implementation of the BaseSimulation which implements the SimulationProtocol already described in the previous mentioned guide . As such, we are allowed to define our own interpretations of the simulation. Here is how we build a Vegetation simulation: Constants -> VegetationConstants . Different species are defined through different constant values, as well as time related constants (e.g. start time and ecological time steps). To initialize the object at least a valid species name is required. This class will load its values looking for the default vegetation constants file . We also allow the user to load their own file by doing the following: VegetationConstants ( species = 'Salicornia' , input_file = 'your_json_filepath_here.json' ) Further species can be added by defining their specific parameters using constants_json_create . Biota -> Vegetation This biota also includes extra characteristics such as LifeStages . Environment -> None (we do not need it for this simulation). Hydrodynamics -> Either of the following two: Delft3D - FlowFMModel . Delft3D - DimrModel . Output -> VegetationOutputWrapper . Our custom wrapper ensures the required output variables are stored to be later evaluated.","title":"1. Simulation structure."},{"location":"guides/run_simulation_veg/#2-simulation-steps","text":"When the previous paramaters have been correctly assigned to the object, the simulation is started by using the required methods from BaseSimulation and defined in VegFlowFmSimulation : Initiate: Configures hydrodynamics and output Validates simulation directories Initiated vegetation characteristics for all life stages in the class LifeStages initializes the output VegetationOutputWrapper . Run: When calling the run method (sim_run.run()) , the duration of the simulation needs to be specified (in years) (e.g. sim_run.run(5) ) If duration is not given, the duration specified in the VegetationConstants class will be used. The start date is set to the date specified in VegetationConstants . end date = start date + duration. A loop is started over the duration of the simulation (years). Another loop iterates within the previous over the number of ecological time steps per year (coupling times per year) specified in VegetationConstants . To get the hydro and morphological variables from Delft-FM, the hydro-morphodynamics are retrieved every day. The coupling and retrieving of the values is specified in the class Delft3D Aggregated values are then created in the class Hydro_Morphodynamics and retrieved via the method 'get_hydromorph_values' The vegetation dynamics are initiated: Mortality and Growth criteria for mortality and mortality fractions are determined based on the species and the morpho- & hydrodynamics vegetation growth is initiated based on the number of growth days within the current ecological time step Colonisation method is only called when colonisation is possible during the specific period of the ecological time step criteria for colonisation are determined based on the species and the morpho- & hydrodynamics the vegetation characteristics of the initial lifestage are updated based on the possible colonisation Update_Lifestages the life stages are updates (initial to juvenile and juvenile to mature) initial to juvenile always occurs when new vegetation colonized juvenile to mature only occurs when vegetation in the juvenile stage reached the maximum years in that life stage if the maximum age of vegetation is reached, the vegetation is removed The results are exported using the methods defined in VegetationMapOutput and VegetationHisOutput Finalize (Finalize simulation).","title":"2. Simulation steps."},{"location":"guides/run_simulation_veg/#vegetation-delft3d-simulation-example","text":"A simulation using the VegFlowFmSimulation object. This example is in our test bench, although we only run it locally due to the DIMR dependencies not being available at the repo level, and makes use of a Pydantic approach to simplify how to initialize an object. from src.biota_models.vegetation.model.veg_constants import VegetationConstants from src.biota_models.vegetation.model.veg_model import Vegetation from src.biota_models.vegetation.simulation.veg_delft3d_simulation import ( VegFlowFmSimulation , ) # 1. Define attributes test_dir = TestUtils . get_local_test_data_dir ( \"sm_testcase6\" ) # We need to specify where the DIMR directory (WITH ALL THE SHARED BINARIES) is located. dll_repo = TestUtils . get_external_repo ( \"DimrDllDependencies\" ) kernels_dir = dll_repo / \"kernels\" output_dir = test_dir / \"output\" test_case = test_dir / \"input\" / \"MinFiles\" # 2. Prepare model. # Create vegetation constants based on the above species. veg_constants = VegetationConstants ( species = \"Salicornia\" ) sim_run = VegFlowFmSimulation ( working_dir = test_dir , constants = veg_constants , hydrodynamics = dict ( working_dir = test_dir / \"d3d_work\" , d3d_home = kernels_dir , dll_path = kernels_dir / \"dflowfm_with_shared\" / \"bin\" / \"dflowfm.dll\" , definition_file = test_case / \"fm\" / \"test_case6.mdu\" , ), output = dict ( output_dir = output_dir , map_output = dict ( output_params = dict ()), his_output = dict ( output_params = dict (), ), ), biota = Vegetation ( species = \"Salicornia\" , constants = veg_constants ), ) # 3. Run simulation. sim_run . initiate () sim_run . run () sim_run . finalise ()","title":"Vegetation Delft3D Simulation Example"},{"location":"reference/biota_models/coral/about/","text":"CoralModel \u00b6 A biophysical model framework written in Python to make simulations on coral development based on four environmental factors: (1) light; (2) flow; (3) temperature; and (4) acidity. For the hydrodynamics, the model can be coupled to Delft3D Flexible Mesh; a hydrodynamic model developed at Deltares ( more information ). To enable this online coupling, certain configurations of Python are required ( more details ). Note: This model is still in its beta and further development is still being done. coral_model_v0 is used for the study and is rewritten ( coral_model ) to enhance collaboration. (The original version has not been written efficiently and is hard to follow for outsiders.) More information on this version control here . Biophysics \u00b6 This biophysical model framework is part of the result of a master thesis of which the key findings are published in Environmental Modelling and Software (the paper can be found here ). The biophysical relations used in the biophysical model framework are mainly process-based, where for the acidity the proxy of the aragonite saturation state is used. Furthermore, both photo- and thermal-acclimatisation are included, which result in a dynamic behaviour of the corals to their environment. Hence, the corals are modelled such that they can adapt to changing environmental conditions over time. For more details on the biophysics, reference is made to the master thesis and the paper that substitute this repository. Python code \u00b6 The Python code is written in Python 3 and makes use of various packages. Not all of these packages are automatically included in the standard library of Python, such as NetCDF4 ( download ). In case the biophysical model framework is to be coupled to Delft3d Flexible Mesh, the bmi.wrapper package is also required ( download ). The settings of Python and other packages for the online coupling to work properly are the following: Python version 3.6.5 NumPy version 1.14.3 SciPy version 1.1.0 NetCDF4 version 1.4.2 Matplotlib version 2.2.2 BMI-Python Note: These requirements are only required in case the biophysical model framework is to be coupled with Delft3D Flexible Mesh. Version control \u00b6 There are two versions of the CoralModel: coral_model_v0 and coral_model . The first ( coral_model_v0 ) is the original code as used in the study (i.e. master thesis and paper ). The latter ( coral_model ) is an updated version, which is rewritten such that it enhances collaboration. This collaboration was one of the goals to further develop this model, and the biophysical modelling of coral development. coral_model_v0 will be depreciated in the future, when coral_model is fully operational and possibly even incorporates more aspects of coral (reef) development.","title":"CoralModel"},{"location":"reference/biota_models/coral/about/#coralmodel","text":"A biophysical model framework written in Python to make simulations on coral development based on four environmental factors: (1) light; (2) flow; (3) temperature; and (4) acidity. For the hydrodynamics, the model can be coupled to Delft3D Flexible Mesh; a hydrodynamic model developed at Deltares ( more information ). To enable this online coupling, certain configurations of Python are required ( more details ). Note: This model is still in its beta and further development is still being done. coral_model_v0 is used for the study and is rewritten ( coral_model ) to enhance collaboration. (The original version has not been written efficiently and is hard to follow for outsiders.) More information on this version control here .","title":"CoralModel"},{"location":"reference/biota_models/coral/about/#biophysics","text":"This biophysical model framework is part of the result of a master thesis of which the key findings are published in Environmental Modelling and Software (the paper can be found here ). The biophysical relations used in the biophysical model framework are mainly process-based, where for the acidity the proxy of the aragonite saturation state is used. Furthermore, both photo- and thermal-acclimatisation are included, which result in a dynamic behaviour of the corals to their environment. Hence, the corals are modelled such that they can adapt to changing environmental conditions over time. For more details on the biophysics, reference is made to the master thesis and the paper that substitute this repository.","title":"Biophysics "},{"location":"reference/biota_models/coral/about/#python-code","text":"The Python code is written in Python 3 and makes use of various packages. Not all of these packages are automatically included in the standard library of Python, such as NetCDF4 ( download ). In case the biophysical model framework is to be coupled to Delft3d Flexible Mesh, the bmi.wrapper package is also required ( download ). The settings of Python and other packages for the online coupling to work properly are the following: Python version 3.6.5 NumPy version 1.14.3 SciPy version 1.1.0 NetCDF4 version 1.4.2 Matplotlib version 2.2.2 BMI-Python Note: These requirements are only required in case the biophysical model framework is to be coupled with Delft3D Flexible Mesh.","title":"Python code "},{"location":"reference/biota_models/coral/about/#version-control","text":"There are two versions of the CoralModel: coral_model_v0 and coral_model . The first ( coral_model_v0 ) is the original code as used in the study (i.e. master thesis and paper ). The latter ( coral_model ) is an updated version, which is rewritten such that it enhances collaboration. This collaboration was one of the goals to further develop this model, and the biophysical modelling of coral development. coral_model_v0 will be depreciated in the future, when coral_model is fully operational and possibly even incorporates more aspects of coral (reef) development.","title":"Version control "},{"location":"reference/biota_models/coral/coral_model/","text":"Coral models for the NBSDynamics package. \u00b6 Coral Protocol \u00b6 CoralProtocol \u00b6 Bases: Protocol Protocol for all Corals to be used in the NBSDynamics Project. Source code in src/biota_models/coral/model/coral_protocol.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @runtime_checkable class CoralProtocol ( Protocol ): \"\"\" Protocol for all Corals to be used in the `NBSDynamics` Project. \"\"\" @property def constants ( self ) -> CoralConstants : \"\"\" Constants associated to the Coral Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ]): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError constants () -> CoralConstants property \u00b6 Constants associated to the Coral Model to be run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants CoralConstants Instance of constants. Source code in src/biota_models/coral/model/coral_protocol.py 14 15 16 17 18 19 20 21 22 23 24 25 @property def constants ( self ) -> CoralConstants : \"\"\" Constants associated to the Coral Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError initiate_coral_morphology ( cover : Optional [ np . ndarray ]) \u00b6 Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional [ np . ndarray ] Custom coral definition. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/coral/model/coral_protocol.py 27 28 29 30 31 32 33 34 35 36 37 38 39 def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ]): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError update_coral_morphology ( coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]]) \u00b6 Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union [ float , np . ndarray ] Coral volume required morphology_ratios Dict [ str , Union [ float , np . ndarray ]] Morphology ratios (rf, rp, rs, ..) required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/coral/model/coral_protocol.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Coral model \u00b6 Coral \u00b6 Bases: Biota Implements the CoralProtocol . Coral object, representing one coral type. Source code in src/biota_models/coral/model/coral_model.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class Coral ( Biota ): \"\"\" Implements the `CoralProtocol`. Coral object, representing one coral type. \"\"\" constants : CoralConstants = CoralConstants () dc : CoralAttribute # diameter coral plate [m] hc : CoralAttribute # coral height [m] bc : CoralAttribute # diameter coral base [m] tc : CoralAttribute # thickness coral plate [m] ac : CoralAttribute # axial distance corals [m] Csp : Optional [ float ] = 1 # species constant [-] # other attributes. _cover : Optional [ CoralAttribute ] = None # light micro-environment light : Optional [ CoralAttribute ] = None light_bc : Optional [ CoralAttribute ] = None # flow micro environment ucm : Optional [ CoralAttribute ] = None um : Optional [ CoralAttribute ] = None delta_t : Optional [ CoralAttribute ] = None # thermal micro-environment dTc : Optional [ CoralAttribute ] = None temp : Optional [ CoralAttribute ] = None # photosynthesis photo_rate : Optional [ CoralAttribute ] = None Tlo : Optional [ CoralAttribute ] = None Thi : Optional [ CoralAttribute ] = None # population states pop_states : Optional [ CoralAttribute ] = None p0 : Optional [ CoralAttribute ] = None # calcification calc : Optional [ CoralAttribute ] = None @validator ( \"dc\" , \"hc\" , \"bc\" , \"tc\" , \"ac\" ) @classmethod def validate_coral_attribute ( cls , value : Optional [ CoralAttribute ] ) -> Optional [ np . ndarray ]: if value is None : return value return DataReshape . variable2array ( value ) def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Morphology( { self . dc } , { self . hc } , { self . bc } , { self . bc } , { self . ac } )\" def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Coral morphology with: dc = { self . dc } m; hc = { self . hc } ;\" f \"bc = { self . bc } m; tc = { self . tc } m; ac = { self . ac } m\" ) @property def dc_rep ( self ): \"\"\"Representative coral diameter; weighted average of base and plate diameters.\"\"\" return ( self . bc * ( self . hc - self . tc ) + self . dc * self . tc ) / self . hc @property def rf ( self ): \"\"\"Form ratio: height-to-diameter ratio.\"\"\" return self . hc / self . dc @property def rp ( self ): \"\"\"Plate ratio: base-to-diameter ratio.\"\"\" return self . bc / self . dc @property def rs ( self ): \"\"\"Spacing ratio: diameter-to-axial distance ratio.\"\"\" return self . dc / self . ac @property # changed the volume function - assigned the output coral_volume def volume ( self ): \"\"\"Coral volume.\"\"\" coral_volume = ( 0.25 * np . pi * (( self . hc - self . tc ) * self . bc ** 2 + self . tc * self . dc ** 2 ) ) return coral_volume @property def dc_matrix ( self ): \"\"\"self.RESHAPEd coral plate diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc , \"space\" ) @property def hc_matrix ( self ): \"\"\"self.RESHAPEd coral height.\"\"\" return RESHAPE () . variable2matrix ( self . hc , \"space\" ) @property def bc_matrix ( self ): \"\"\"self.RESHAPEd coral base diameter.\"\"\" return RESHAPE () . variable2matrix ( self . bc , \"space\" ) @property def tc_matrix ( self ): \"\"\"self.RESHAPEd coral plate thickness.\"\"\" return RESHAPE () . variable2matrix ( self . tc , \"space\" ) @property def ac_matrix ( self ): \"\"\"self.RESHAPEd axial distance.\"\"\" return RESHAPE () . variable2matrix ( self . ac , \"space\" ) @property def dc_rep_matrix ( self ): \"\"\"self.RESHAPEd representative coral diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc_rep , \"space\" ) @property def as_vegetation_density ( self ): \"\"\"Translation from coral morphology to (vegetation) density.\"\"\" def function ( dc_rep , ac ): return ( 2 * dc_rep ) / ( ac ** 2 ) return CoralOnly () . in_space ( coral = self , function = function , args = ( self . dc_rep , self . ac ) ) @property def cover ( self ): \"\"\"Carrying capacity.\"\"\" if self . _cover is None : cover = np . ones ( np . array ( self . volume ) . shape ) cover [ self . volume == 0.0 ] = 0.0 # 21.09 made 0. instead of just zero return cover return self . _cover @property def living_cover ( self ): \"\"\"Living coral cover based on population states.\"\"\" if self . pop_states is not None : return self . pop_states . sum ( axis = 2 ) def update_coral_volume ( self , coral_volume : CoralAttribute ): \"\"\" Updates the coral morphology based on the given coral volume. Args: coral_volume (CoralAttribute): New coral volume. \"\"\" # TODO what is the difference? And which volume does it call then? # TODO also function update morphology does not update coral volume self . update_coral_morphology ( coral_volume , dict ( rf = self . rf , rp = self . rp , rs = self . rs ) ) def update_cover ( self , carrying_capacity : CoralAttribute ): \"\"\" Update cover value based on given parameters. Args: carrying_capacity (CoralAttribute): Carrying capacity [m2 m-2]. \"\"\" carrying_capacity = RESHAPE () . variable2array ( carrying_capacity ) if not self . volume . shape == carrying_capacity . shape : raise ValueError ( f \"Shapes do not match: \" f \" { self . volume . shape } =/= { carrying_capacity . shape } \" ) if sum ( self . volume [ carrying_capacity == 0.0 ]) > 0.0 : print ( f \"WARNING: Coral volume present where the carrying capacity is zero. This is unrealistic.\" ) self . _cover = carrying_capacity def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ] = None ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. \"\"\" _reshape = RESHAPE () if cover is not None : cover = _reshape . variable2array ( cover ) if not cover . shape [ 0 ] == _reshape . space : msg = f \"Spatial dimension of cover does not match: { cover . shape } =/= { _reshape . space } .\" raise ValueError ( msg ) else : cover = np . ones ( _reshape . space ) self . p0 = np . array ( [ cover , np . zeros ( cover . shape ), np . zeros ( cover . shape ), np . zeros ( cover . shape ), ] ) . transpose () self . dc = cover * self . dc self . hc = cover * self . hc self . bc = cover * self . bc self . tc = cover * self . tc self . ac = cover * self . ac def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) \"\"\" rf = morphology_ratios [ \"rf\" ] rp = morphology_ratios [ \"rp\" ] rs = morphology_ratios [ \"rs\" ] def vc2dc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral plate diameter.\"\"\" dc = (( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 ))) ** ( 1.0 / 3.0 ) return dc def vc2hc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral height.\"\"\" hc = ( ( 4.0 * coral_volume * rf ** 2 ) / ( np . pi * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return hc def vc2bc ( coral_volume , rf , rp ): \"\"\"Coral volume > diameter of the base.\"\"\" bc = ( ( 4.0 * coral_volume * rp ** 2 ) / ( np . pi * rf * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return bc def vc2tc ( coral_volume , rf , rp ): \"\"\"Coral volume > thickness of the plate.\"\"\" tc = ( ( 4.0 * coral_volume * rf ** 2 * rp ** 2 ) / ( np . pi * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return tc def vc2ac ( coral_volume , rf , rp , rs ): \"\"\"Coral volume > axial distance.\"\"\" ac = ( 1.0 / rs ) * ( ( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return ac # # update morphology self . dc = vc2dc ( coral_volume , rf , rp ) self . hc = vc2hc ( coral_volume , rf , rp ) self . bc = vc2bc ( coral_volume , rf , rp ) self . tc = vc2tc ( coral_volume , rf , rp ) self . ac = vc2ac ( coral_volume , rf , rp , rs ) __repr__ () \u00b6 Development representation. Source code in src/biota_models/coral/model/coral_model.py 62 63 64 def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Morphology( { self . dc } , { self . hc } , { self . bc } , { self . bc } , { self . ac } )\" __str__ () \u00b6 Print representation. Source code in src/biota_models/coral/model/coral_model.py 66 67 68 69 70 71 def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Coral morphology with: dc = { self . dc } m; hc = { self . hc } ;\" f \"bc = { self . bc } m; tc = { self . tc } m; ac = { self . ac } m\" ) ac_matrix () property \u00b6 self.RESHAPEd axial distance. Source code in src/biota_models/coral/model/coral_model.py 122 123 124 125 @property def ac_matrix ( self ): \"\"\"self.RESHAPEd axial distance.\"\"\" return RESHAPE () . variable2matrix ( self . ac , \"space\" ) as_vegetation_density () property \u00b6 Translation from coral morphology to (vegetation) density. Source code in src/biota_models/coral/model/coral_model.py 132 133 134 135 136 137 138 139 140 141 @property def as_vegetation_density ( self ): \"\"\"Translation from coral morphology to (vegetation) density.\"\"\" def function ( dc_rep , ac ): return ( 2 * dc_rep ) / ( ac ** 2 ) return CoralOnly () . in_space ( coral = self , function = function , args = ( self . dc_rep , self . ac ) ) bc_matrix () property \u00b6 self.RESHAPEd coral base diameter. Source code in src/biota_models/coral/model/coral_model.py 112 113 114 115 @property def bc_matrix ( self ): \"\"\"self.RESHAPEd coral base diameter.\"\"\" return RESHAPE () . variable2matrix ( self . bc , \"space\" ) cover () property \u00b6 Carrying capacity. Source code in src/biota_models/coral/model/coral_model.py 143 144 145 146 147 148 149 150 151 @property def cover ( self ): \"\"\"Carrying capacity.\"\"\" if self . _cover is None : cover = np . ones ( np . array ( self . volume ) . shape ) cover [ self . volume == 0.0 ] = 0.0 # 21.09 made 0. instead of just zero return cover return self . _cover dc_matrix () property \u00b6 self.RESHAPEd coral plate diameter. Source code in src/biota_models/coral/model/coral_model.py 102 103 104 105 @property def dc_matrix ( self ): \"\"\"self.RESHAPEd coral plate diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc , \"space\" ) dc_rep () property \u00b6 Representative coral diameter; weighted average of base and plate diameters. Source code in src/biota_models/coral/model/coral_model.py 73 74 75 76 @property def dc_rep ( self ): \"\"\"Representative coral diameter; weighted average of base and plate diameters.\"\"\" return ( self . bc * ( self . hc - self . tc ) + self . dc * self . tc ) / self . hc dc_rep_matrix () property \u00b6 self.RESHAPEd representative coral diameter. Source code in src/biota_models/coral/model/coral_model.py 127 128 129 130 @property def dc_rep_matrix ( self ): \"\"\"self.RESHAPEd representative coral diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc_rep , \"space\" ) hc_matrix () property \u00b6 self.RESHAPEd coral height. Source code in src/biota_models/coral/model/coral_model.py 107 108 109 110 @property def hc_matrix ( self ): \"\"\"self.RESHAPEd coral height.\"\"\" return RESHAPE () . variable2matrix ( self . hc , \"space\" ) initiate_coral_morphology ( cover : Optional [ np . ndarray ] = None ) \u00b6 Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional [ np . ndarray ] Custom coral definition. None Source code in src/biota_models/coral/model/coral_model.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ] = None ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. \"\"\" _reshape = RESHAPE () if cover is not None : cover = _reshape . variable2array ( cover ) if not cover . shape [ 0 ] == _reshape . space : msg = f \"Spatial dimension of cover does not match: { cover . shape } =/= { _reshape . space } .\" raise ValueError ( msg ) else : cover = np . ones ( _reshape . space ) self . p0 = np . array ( [ cover , np . zeros ( cover . shape ), np . zeros ( cover . shape ), np . zeros ( cover . shape ), ] ) . transpose () self . dc = cover * self . dc self . hc = cover * self . hc self . bc = cover * self . bc self . tc = cover * self . tc self . ac = cover * self . ac living_cover () property \u00b6 Living coral cover based on population states. Source code in src/biota_models/coral/model/coral_model.py 153 154 155 156 157 @property def living_cover ( self ): \"\"\"Living coral cover based on population states.\"\"\" if self . pop_states is not None : return self . pop_states . sum ( axis = 2 ) rf () property \u00b6 Form ratio: height-to-diameter ratio. Source code in src/biota_models/coral/model/coral_model.py 78 79 80 81 @property def rf ( self ): \"\"\"Form ratio: height-to-diameter ratio.\"\"\" return self . hc / self . dc rp () property \u00b6 Plate ratio: base-to-diameter ratio. Source code in src/biota_models/coral/model/coral_model.py 83 84 85 86 @property def rp ( self ): \"\"\"Plate ratio: base-to-diameter ratio.\"\"\" return self . bc / self . dc rs () property \u00b6 Spacing ratio: diameter-to-axial distance ratio. Source code in src/biota_models/coral/model/coral_model.py 88 89 90 91 @property def rs ( self ): \"\"\"Spacing ratio: diameter-to-axial distance ratio.\"\"\" return self . dc / self . ac tc_matrix () property \u00b6 self.RESHAPEd coral plate thickness. Source code in src/biota_models/coral/model/coral_model.py 117 118 119 120 @property def tc_matrix ( self ): \"\"\"self.RESHAPEd coral plate thickness.\"\"\" return RESHAPE () . variable2matrix ( self . tc , \"space\" ) update_coral_morphology ( coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]]) \u00b6 Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union [ float , np . ndarray ] Coral volume required morphology_ratios Dict [ str , Union [ float , np . ndarray ]] Morphology ratios (rf, rp, rs, ..) required Source code in src/biota_models/coral/model/coral_model.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) \"\"\" rf = morphology_ratios [ \"rf\" ] rp = morphology_ratios [ \"rp\" ] rs = morphology_ratios [ \"rs\" ] def vc2dc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral plate diameter.\"\"\" dc = (( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 ))) ** ( 1.0 / 3.0 ) return dc def vc2hc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral height.\"\"\" hc = ( ( 4.0 * coral_volume * rf ** 2 ) / ( np . pi * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return hc def vc2bc ( coral_volume , rf , rp ): \"\"\"Coral volume > diameter of the base.\"\"\" bc = ( ( 4.0 * coral_volume * rp ** 2 ) / ( np . pi * rf * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return bc def vc2tc ( coral_volume , rf , rp ): \"\"\"Coral volume > thickness of the plate.\"\"\" tc = ( ( 4.0 * coral_volume * rf ** 2 * rp ** 2 ) / ( np . pi * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return tc def vc2ac ( coral_volume , rf , rp , rs ): \"\"\"Coral volume > axial distance.\"\"\" ac = ( 1.0 / rs ) * ( ( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return ac # # update morphology self . dc = vc2dc ( coral_volume , rf , rp ) self . hc = vc2hc ( coral_volume , rf , rp ) self . bc = vc2bc ( coral_volume , rf , rp ) self . tc = vc2tc ( coral_volume , rf , rp ) self . ac = vc2ac ( coral_volume , rf , rp , rs ) update_coral_volume ( coral_volume : CoralAttribute ) \u00b6 Updates the coral morphology based on the given coral volume. Parameters: Name Type Description Default coral_volume CoralAttribute New coral volume. required Source code in src/biota_models/coral/model/coral_model.py 159 160 161 162 163 164 165 166 167 168 169 170 def update_coral_volume ( self , coral_volume : CoralAttribute ): \"\"\" Updates the coral morphology based on the given coral volume. Args: coral_volume (CoralAttribute): New coral volume. \"\"\" # TODO what is the difference? And which volume does it call then? # TODO also function update morphology does not update coral volume self . update_coral_morphology ( coral_volume , dict ( rf = self . rf , rp = self . rp , rs = self . rs ) ) update_cover ( carrying_capacity : CoralAttribute ) \u00b6 Update cover value based on given parameters. Parameters: Name Type Description Default carrying_capacity CoralAttribute Carrying capacity [m2 m-2]. required Source code in src/biota_models/coral/model/coral_model.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def update_cover ( self , carrying_capacity : CoralAttribute ): \"\"\" Update cover value based on given parameters. Args: carrying_capacity (CoralAttribute): Carrying capacity [m2 m-2]. \"\"\" carrying_capacity = RESHAPE () . variable2array ( carrying_capacity ) if not self . volume . shape == carrying_capacity . shape : raise ValueError ( f \"Shapes do not match: \" f \" { self . volume . shape } =/= { carrying_capacity . shape } \" ) if sum ( self . volume [ carrying_capacity == 0.0 ]) > 0.0 : print ( f \"WARNING: Coral volume present where the carrying capacity is zero. This is unrealistic.\" ) self . _cover = carrying_capacity volume () property \u00b6 Coral volume. Source code in src/biota_models/coral/model/coral_model.py 93 94 95 96 97 98 99 100 @property # changed the volume function - assigned the output coral_volume def volume ( self ): \"\"\"Coral volume.\"\"\" coral_volume = ( 0.25 * np . pi * (( self . hc - self . tc ) * self . bc ** 2 + self . tc * self . dc ** 2 ) ) return coral_volume Coral Constants \u00b6 CoralConstants \u00b6 Bases: BaseConstants Object containing all constants used in coral_model simulations. Source code in src/biota_models/coral/model/coral_constants.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class CoralConstants ( BaseConstants ): \"\"\"Object containing all constants used in coral_model simulations.\"\"\" # Processes fme : bool = False tme : bool = False pfd : bool = False warn_proc : bool = True # light micro-environment Kd0 : float = 0.1 theta_max : float = 0.5 * np . pi # flow micro-environment Cs : float = 0.17 Cm : float = 1.7 Cf : float = 0.01 nu : float = 1e-6 alpha : float = 1e-7 psi : float = 2 wcAngle : float = 0.0 rd : float = 500 numericTheta : float = 0.5 err : float = 1e-3 maxiter_k : int = int ( 1e5 ) maxiter_aw : int = int ( 1e5 ) # thermal micro-environment K0 : float = 80.0 ap : float = 0.4 k : float = 0.6089 # photosynthetic light dependency iota : float = 0.6 ik_max : float = 372.32 pm_max : float = 1.0 betaI : float = 0.34 betaP : float = 0.09 Icomp : float = 0.01 # photosynthetic thermal dependency Ea : float = 6e4 R : float = 8.31446261815324 k_var : float = 2.45 nn : float = 60 # photosynthetic flow dependency pfd_min : float = 0.68886964 ucr : float = 0.5173 # population dynamics r_growth : float = 0.002 r_recovery : float = 0.2 r_mortality : float = 0.04 r_bleaching : float = 8.0 # calcification gC : float = 0.5 omegaA0 : float = 5.0 omega0 : float = 0.14587415 kappaA : float = 0.66236107 # morphological development rf : float = 1.0 rp : float = 1.0 prop_form : float = 0.1 prop_plate : float = 0.5 prop_plate_flow : float = 0.1 prop_space : float = 0.5 / np . sqrt ( 2.0 ) prop_space_light : float = 0.1 prop_space_flow : float = 0.1 u0 : float = 0.2 rho_c : float = 1600.0 # dislodgement criterion sigma_t : float = 2e5 Cd : float = 1.0 rho_w : float = 1025.0 # coral recruitment no_larvae : float = 1e6 prob_settle : float = 1e-4 d_larvae : float = 1e-3 @validator ( \"maxiter_k\" , \"maxiter_aw\" , pre = True , always = True ) @classmethod def validate_scientific_int_value ( cls , v ) -> int : \"\"\" Validates the parameters that can be provided with scientific notation. Args: v (Any): Scientific value to validate. Returns: int: Validated value as integer. \"\"\" if isinstance ( v , int ): return v if isinstance ( v , float ): return int ( v ) if isinstance ( v , str ): return int ( float ( v )) raise NotImplementedError ( f \"No converter available for { type ( v ) } .\" ) @root_validator @classmethod def check_processes ( cls , values : dict ) -> dict : \"\"\" Validates the input values so that the processes are compatible between themselves. Args: values (dict): Dictionary of values already validated individually. Returns: dict: Dictionary of validated values as a whole. \"\"\" if not values [ \"pfd\" ]: if values [ \"fme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Flow micro-environment (FME) not possible \" \"when photosynthetic flow dependency (PFD) is disabled.\" ) values [ \"fme\" ] = False values [ \"tme\" ] = False else : if not values [ \"fme\" ]: if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment (TME) not possible \" \"when flow micro-environment is disabled.\" ) values [ \"tme\" ] = False if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment not fully implemented yet.\" ) if not values [ \"pfd\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Exclusion of photosynthetic flow dependency not fully implemented yet.\" ) return values def correct_values ( self ): \"\"\" Corrects values that require extra operations, such as theta_max and prop_space. \"\"\" self . theta_max *= np . pi self . prop_space /= np . sqrt ( 2.0 ) check_processes ( values : dict ) -> dict classmethod \u00b6 Validates the input values so that the processes are compatible between themselves. Parameters: Name Type Description Default values dict Dictionary of values already validated individually. required Returns: Name Type Description dict dict Dictionary of validated values as a whole. Source code in src/biota_models/coral/model/coral_constants.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @root_validator @classmethod def check_processes ( cls , values : dict ) -> dict : \"\"\" Validates the input values so that the processes are compatible between themselves. Args: values (dict): Dictionary of values already validated individually. Returns: dict: Dictionary of validated values as a whole. \"\"\" if not values [ \"pfd\" ]: if values [ \"fme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Flow micro-environment (FME) not possible \" \"when photosynthetic flow dependency (PFD) is disabled.\" ) values [ \"fme\" ] = False values [ \"tme\" ] = False else : if not values [ \"fme\" ]: if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment (TME) not possible \" \"when flow micro-environment is disabled.\" ) values [ \"tme\" ] = False if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment not fully implemented yet.\" ) if not values [ \"pfd\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Exclusion of photosynthetic flow dependency not fully implemented yet.\" ) return values correct_values () \u00b6 Corrects values that require extra operations, such as theta_max and prop_space. Source code in src/biota_models/coral/model/coral_constants.py 155 156 157 158 159 160 def correct_values ( self ): \"\"\" Corrects values that require extra operations, such as theta_max and prop_space. \"\"\" self . theta_max *= np . pi self . prop_space /= np . sqrt ( 2.0 ) validate_scientific_int_value ( v ) -> int classmethod \u00b6 Validates the parameters that can be provided with scientific notation. Parameters: Name Type Description Default v Any Scientific value to validate. required Returns: Name Type Description int int Validated value as integer. Source code in src/biota_models/coral/model/coral_constants.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @validator ( \"maxiter_k\" , \"maxiter_aw\" , pre = True , always = True ) @classmethod def validate_scientific_int_value ( cls , v ) -> int : \"\"\" Validates the parameters that can be provided with scientific notation. Args: v (Any): Scientific value to validate. Returns: int: Validated value as integer. \"\"\" if isinstance ( v , int ): return v if isinstance ( v , float ): return int ( v ) if isinstance ( v , str ): return int ( float ( v )) raise NotImplementedError ( f \"No converter available for { type ( v ) } .\" ) Coral utils \u00b6 CoralOnly \u00b6 Execute functions only in the presence of corals. Source code in src/biota_models/coral/model/coral_only.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class CoralOnly : \"\"\"Execute functions only in the presence of corals.\"\"\" spacetime = None @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ] @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ] def in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is coral cover. Args: coral (Coral): Coral object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of coral cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the coral function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output def in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == coral . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output in_space ( coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 ) -> np . ndarray \u00b6 Only execute the function when there is coral cover. Parameters: Name Type Description Default coral Coral Coral object. required function Callable Function to be executed. required args Tuple input arguments of the function. required no_cover_value Optional [ float ] Default value in absence of coral cover. Defaults to 0. 0 Raises: Type Description ValueError When sizes do not match. Returns: Type Description np . ndarray np.ndarray: Result of the coral function. Source code in src/biota_models/coral/model/coral_only.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is coral cover. Args: coral (Coral): Coral object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of coral cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the coral function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output in_spacetime ( coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 ) \u00b6 Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional Source code in src/biota_models/coral/model/coral_only.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == coral . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output space () property \u00b6 Space dimension. Source code in src/biota_models/coral/model/coral_only.py 11 12 13 14 @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ] time () property \u00b6 Time dimension. Source code in src/biota_models/coral/model/coral_only.py 16 17 18 19 @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ]","title":"Coral model"},{"location":"reference/biota_models/coral/coral_model/#coral-models-for-the-nbsdynamics-package","text":"","title":"Coral models for the NBSDynamics package."},{"location":"reference/biota_models/coral/coral_model/#coral-protocol","text":"","title":"Coral Protocol"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_protocol.CoralProtocol","text":"Bases: Protocol Protocol for all Corals to be used in the NBSDynamics Project. Source code in src/biota_models/coral/model/coral_protocol.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @runtime_checkable class CoralProtocol ( Protocol ): \"\"\" Protocol for all Corals to be used in the `NBSDynamics` Project. \"\"\" @property def constants ( self ) -> CoralConstants : \"\"\" Constants associated to the Coral Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ]): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"CoralProtocol"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_protocol.CoralProtocol.constants","text":"Constants associated to the Coral Model to be run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants CoralConstants Instance of constants. Source code in src/biota_models/coral/model/coral_protocol.py 14 15 16 17 18 19 20 21 22 23 24 25 @property def constants ( self ) -> CoralConstants : \"\"\" Constants associated to the Coral Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError","title":"constants()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_protocol.CoralProtocol.initiate_coral_morphology","text":"Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional [ np . ndarray ] Custom coral definition. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/coral/model/coral_protocol.py 27 28 29 30 31 32 33 34 35 36 37 38 39 def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ]): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"initiate_coral_morphology()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_protocol.CoralProtocol.update_coral_morphology","text":"Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union [ float , np . ndarray ] Coral volume required morphology_ratios Dict [ str , Union [ float , np . ndarray ]] Morphology ratios (rf, rp, rs, ..) required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/coral/model/coral_protocol.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update_coral_morphology()"},{"location":"reference/biota_models/coral/coral_model/#coral-model","text":"","title":"Coral model"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral","text":"Bases: Biota Implements the CoralProtocol . Coral object, representing one coral type. Source code in src/biota_models/coral/model/coral_model.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class Coral ( Biota ): \"\"\" Implements the `CoralProtocol`. Coral object, representing one coral type. \"\"\" constants : CoralConstants = CoralConstants () dc : CoralAttribute # diameter coral plate [m] hc : CoralAttribute # coral height [m] bc : CoralAttribute # diameter coral base [m] tc : CoralAttribute # thickness coral plate [m] ac : CoralAttribute # axial distance corals [m] Csp : Optional [ float ] = 1 # species constant [-] # other attributes. _cover : Optional [ CoralAttribute ] = None # light micro-environment light : Optional [ CoralAttribute ] = None light_bc : Optional [ CoralAttribute ] = None # flow micro environment ucm : Optional [ CoralAttribute ] = None um : Optional [ CoralAttribute ] = None delta_t : Optional [ CoralAttribute ] = None # thermal micro-environment dTc : Optional [ CoralAttribute ] = None temp : Optional [ CoralAttribute ] = None # photosynthesis photo_rate : Optional [ CoralAttribute ] = None Tlo : Optional [ CoralAttribute ] = None Thi : Optional [ CoralAttribute ] = None # population states pop_states : Optional [ CoralAttribute ] = None p0 : Optional [ CoralAttribute ] = None # calcification calc : Optional [ CoralAttribute ] = None @validator ( \"dc\" , \"hc\" , \"bc\" , \"tc\" , \"ac\" ) @classmethod def validate_coral_attribute ( cls , value : Optional [ CoralAttribute ] ) -> Optional [ np . ndarray ]: if value is None : return value return DataReshape . variable2array ( value ) def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Morphology( { self . dc } , { self . hc } , { self . bc } , { self . bc } , { self . ac } )\" def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Coral morphology with: dc = { self . dc } m; hc = { self . hc } ;\" f \"bc = { self . bc } m; tc = { self . tc } m; ac = { self . ac } m\" ) @property def dc_rep ( self ): \"\"\"Representative coral diameter; weighted average of base and plate diameters.\"\"\" return ( self . bc * ( self . hc - self . tc ) + self . dc * self . tc ) / self . hc @property def rf ( self ): \"\"\"Form ratio: height-to-diameter ratio.\"\"\" return self . hc / self . dc @property def rp ( self ): \"\"\"Plate ratio: base-to-diameter ratio.\"\"\" return self . bc / self . dc @property def rs ( self ): \"\"\"Spacing ratio: diameter-to-axial distance ratio.\"\"\" return self . dc / self . ac @property # changed the volume function - assigned the output coral_volume def volume ( self ): \"\"\"Coral volume.\"\"\" coral_volume = ( 0.25 * np . pi * (( self . hc - self . tc ) * self . bc ** 2 + self . tc * self . dc ** 2 ) ) return coral_volume @property def dc_matrix ( self ): \"\"\"self.RESHAPEd coral plate diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc , \"space\" ) @property def hc_matrix ( self ): \"\"\"self.RESHAPEd coral height.\"\"\" return RESHAPE () . variable2matrix ( self . hc , \"space\" ) @property def bc_matrix ( self ): \"\"\"self.RESHAPEd coral base diameter.\"\"\" return RESHAPE () . variable2matrix ( self . bc , \"space\" ) @property def tc_matrix ( self ): \"\"\"self.RESHAPEd coral plate thickness.\"\"\" return RESHAPE () . variable2matrix ( self . tc , \"space\" ) @property def ac_matrix ( self ): \"\"\"self.RESHAPEd axial distance.\"\"\" return RESHAPE () . variable2matrix ( self . ac , \"space\" ) @property def dc_rep_matrix ( self ): \"\"\"self.RESHAPEd representative coral diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc_rep , \"space\" ) @property def as_vegetation_density ( self ): \"\"\"Translation from coral morphology to (vegetation) density.\"\"\" def function ( dc_rep , ac ): return ( 2 * dc_rep ) / ( ac ** 2 ) return CoralOnly () . in_space ( coral = self , function = function , args = ( self . dc_rep , self . ac ) ) @property def cover ( self ): \"\"\"Carrying capacity.\"\"\" if self . _cover is None : cover = np . ones ( np . array ( self . volume ) . shape ) cover [ self . volume == 0.0 ] = 0.0 # 21.09 made 0. instead of just zero return cover return self . _cover @property def living_cover ( self ): \"\"\"Living coral cover based on population states.\"\"\" if self . pop_states is not None : return self . pop_states . sum ( axis = 2 ) def update_coral_volume ( self , coral_volume : CoralAttribute ): \"\"\" Updates the coral morphology based on the given coral volume. Args: coral_volume (CoralAttribute): New coral volume. \"\"\" # TODO what is the difference? And which volume does it call then? # TODO also function update morphology does not update coral volume self . update_coral_morphology ( coral_volume , dict ( rf = self . rf , rp = self . rp , rs = self . rs ) ) def update_cover ( self , carrying_capacity : CoralAttribute ): \"\"\" Update cover value based on given parameters. Args: carrying_capacity (CoralAttribute): Carrying capacity [m2 m-2]. \"\"\" carrying_capacity = RESHAPE () . variable2array ( carrying_capacity ) if not self . volume . shape == carrying_capacity . shape : raise ValueError ( f \"Shapes do not match: \" f \" { self . volume . shape } =/= { carrying_capacity . shape } \" ) if sum ( self . volume [ carrying_capacity == 0.0 ]) > 0.0 : print ( f \"WARNING: Coral volume present where the carrying capacity is zero. This is unrealistic.\" ) self . _cover = carrying_capacity def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ] = None ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. \"\"\" _reshape = RESHAPE () if cover is not None : cover = _reshape . variable2array ( cover ) if not cover . shape [ 0 ] == _reshape . space : msg = f \"Spatial dimension of cover does not match: { cover . shape } =/= { _reshape . space } .\" raise ValueError ( msg ) else : cover = np . ones ( _reshape . space ) self . p0 = np . array ( [ cover , np . zeros ( cover . shape ), np . zeros ( cover . shape ), np . zeros ( cover . shape ), ] ) . transpose () self . dc = cover * self . dc self . hc = cover * self . hc self . bc = cover * self . bc self . tc = cover * self . tc self . ac = cover * self . ac def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) \"\"\" rf = morphology_ratios [ \"rf\" ] rp = morphology_ratios [ \"rp\" ] rs = morphology_ratios [ \"rs\" ] def vc2dc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral plate diameter.\"\"\" dc = (( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 ))) ** ( 1.0 / 3.0 ) return dc def vc2hc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral height.\"\"\" hc = ( ( 4.0 * coral_volume * rf ** 2 ) / ( np . pi * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return hc def vc2bc ( coral_volume , rf , rp ): \"\"\"Coral volume > diameter of the base.\"\"\" bc = ( ( 4.0 * coral_volume * rp ** 2 ) / ( np . pi * rf * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return bc def vc2tc ( coral_volume , rf , rp ): \"\"\"Coral volume > thickness of the plate.\"\"\" tc = ( ( 4.0 * coral_volume * rf ** 2 * rp ** 2 ) / ( np . pi * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return tc def vc2ac ( coral_volume , rf , rp , rs ): \"\"\"Coral volume > axial distance.\"\"\" ac = ( 1.0 / rs ) * ( ( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return ac # # update morphology self . dc = vc2dc ( coral_volume , rf , rp ) self . hc = vc2hc ( coral_volume , rf , rp ) self . bc = vc2bc ( coral_volume , rf , rp ) self . tc = vc2tc ( coral_volume , rf , rp ) self . ac = vc2ac ( coral_volume , rf , rp , rs )","title":"Coral"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.__repr__","text":"Development representation. Source code in src/biota_models/coral/model/coral_model.py 62 63 64 def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Morphology( { self . dc } , { self . hc } , { self . bc } , { self . bc } , { self . ac } )\"","title":"__repr__()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.__str__","text":"Print representation. Source code in src/biota_models/coral/model/coral_model.py 66 67 68 69 70 71 def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Coral morphology with: dc = { self . dc } m; hc = { self . hc } ;\" f \"bc = { self . bc } m; tc = { self . tc } m; ac = { self . ac } m\" )","title":"__str__()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.ac_matrix","text":"self.RESHAPEd axial distance. Source code in src/biota_models/coral/model/coral_model.py 122 123 124 125 @property def ac_matrix ( self ): \"\"\"self.RESHAPEd axial distance.\"\"\" return RESHAPE () . variable2matrix ( self . ac , \"space\" )","title":"ac_matrix()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.as_vegetation_density","text":"Translation from coral morphology to (vegetation) density. Source code in src/biota_models/coral/model/coral_model.py 132 133 134 135 136 137 138 139 140 141 @property def as_vegetation_density ( self ): \"\"\"Translation from coral morphology to (vegetation) density.\"\"\" def function ( dc_rep , ac ): return ( 2 * dc_rep ) / ( ac ** 2 ) return CoralOnly () . in_space ( coral = self , function = function , args = ( self . dc_rep , self . ac ) )","title":"as_vegetation_density()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.bc_matrix","text":"self.RESHAPEd coral base diameter. Source code in src/biota_models/coral/model/coral_model.py 112 113 114 115 @property def bc_matrix ( self ): \"\"\"self.RESHAPEd coral base diameter.\"\"\" return RESHAPE () . variable2matrix ( self . bc , \"space\" )","title":"bc_matrix()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.cover","text":"Carrying capacity. Source code in src/biota_models/coral/model/coral_model.py 143 144 145 146 147 148 149 150 151 @property def cover ( self ): \"\"\"Carrying capacity.\"\"\" if self . _cover is None : cover = np . ones ( np . array ( self . volume ) . shape ) cover [ self . volume == 0.0 ] = 0.0 # 21.09 made 0. instead of just zero return cover return self . _cover","title":"cover()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.dc_matrix","text":"self.RESHAPEd coral plate diameter. Source code in src/biota_models/coral/model/coral_model.py 102 103 104 105 @property def dc_matrix ( self ): \"\"\"self.RESHAPEd coral plate diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc , \"space\" )","title":"dc_matrix()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.dc_rep","text":"Representative coral diameter; weighted average of base and plate diameters. Source code in src/biota_models/coral/model/coral_model.py 73 74 75 76 @property def dc_rep ( self ): \"\"\"Representative coral diameter; weighted average of base and plate diameters.\"\"\" return ( self . bc * ( self . hc - self . tc ) + self . dc * self . tc ) / self . hc","title":"dc_rep()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.dc_rep_matrix","text":"self.RESHAPEd representative coral diameter. Source code in src/biota_models/coral/model/coral_model.py 127 128 129 130 @property def dc_rep_matrix ( self ): \"\"\"self.RESHAPEd representative coral diameter.\"\"\" return RESHAPE () . variable2matrix ( self . dc_rep , \"space\" )","title":"dc_rep_matrix()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.hc_matrix","text":"self.RESHAPEd coral height. Source code in src/biota_models/coral/model/coral_model.py 107 108 109 110 @property def hc_matrix ( self ): \"\"\"self.RESHAPEd coral height.\"\"\" return RESHAPE () . variable2matrix ( self . hc , \"space\" )","title":"hc_matrix()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.initiate_coral_morphology","text":"Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional [ np . ndarray ] Custom coral definition. None Source code in src/biota_models/coral/model/coral_model.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ] = None ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. \"\"\" _reshape = RESHAPE () if cover is not None : cover = _reshape . variable2array ( cover ) if not cover . shape [ 0 ] == _reshape . space : msg = f \"Spatial dimension of cover does not match: { cover . shape } =/= { _reshape . space } .\" raise ValueError ( msg ) else : cover = np . ones ( _reshape . space ) self . p0 = np . array ( [ cover , np . zeros ( cover . shape ), np . zeros ( cover . shape ), np . zeros ( cover . shape ), ] ) . transpose () self . dc = cover * self . dc self . hc = cover * self . hc self . bc = cover * self . bc self . tc = cover * self . tc self . ac = cover * self . ac","title":"initiate_coral_morphology()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.living_cover","text":"Living coral cover based on population states. Source code in src/biota_models/coral/model/coral_model.py 153 154 155 156 157 @property def living_cover ( self ): \"\"\"Living coral cover based on population states.\"\"\" if self . pop_states is not None : return self . pop_states . sum ( axis = 2 )","title":"living_cover()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.rf","text":"Form ratio: height-to-diameter ratio. Source code in src/biota_models/coral/model/coral_model.py 78 79 80 81 @property def rf ( self ): \"\"\"Form ratio: height-to-diameter ratio.\"\"\" return self . hc / self . dc","title":"rf()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.rp","text":"Plate ratio: base-to-diameter ratio. Source code in src/biota_models/coral/model/coral_model.py 83 84 85 86 @property def rp ( self ): \"\"\"Plate ratio: base-to-diameter ratio.\"\"\" return self . bc / self . dc","title":"rp()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.rs","text":"Spacing ratio: diameter-to-axial distance ratio. Source code in src/biota_models/coral/model/coral_model.py 88 89 90 91 @property def rs ( self ): \"\"\"Spacing ratio: diameter-to-axial distance ratio.\"\"\" return self . dc / self . ac","title":"rs()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.tc_matrix","text":"self.RESHAPEd coral plate thickness. Source code in src/biota_models/coral/model/coral_model.py 117 118 119 120 @property def tc_matrix ( self ): \"\"\"self.RESHAPEd coral plate thickness.\"\"\" return RESHAPE () . variable2matrix ( self . tc , \"space\" )","title":"tc_matrix()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.update_coral_morphology","text":"Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union [ float , np . ndarray ] Coral volume required morphology_ratios Dict [ str , Union [ float , np . ndarray ]] Morphology ratios (rf, rp, rs, ..) required Source code in src/biota_models/coral/model/coral_model.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) \"\"\" rf = morphology_ratios [ \"rf\" ] rp = morphology_ratios [ \"rp\" ] rs = morphology_ratios [ \"rs\" ] def vc2dc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral plate diameter.\"\"\" dc = (( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 ))) ** ( 1.0 / 3.0 ) return dc def vc2hc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral height.\"\"\" hc = ( ( 4.0 * coral_volume * rf ** 2 ) / ( np . pi * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return hc def vc2bc ( coral_volume , rf , rp ): \"\"\"Coral volume > diameter of the base.\"\"\" bc = ( ( 4.0 * coral_volume * rp ** 2 ) / ( np . pi * rf * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return bc def vc2tc ( coral_volume , rf , rp ): \"\"\"Coral volume > thickness of the plate.\"\"\" tc = ( ( 4.0 * coral_volume * rf ** 2 * rp ** 2 ) / ( np . pi * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return tc def vc2ac ( coral_volume , rf , rp , rs ): \"\"\"Coral volume > axial distance.\"\"\" ac = ( 1.0 / rs ) * ( ( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return ac # # update morphology self . dc = vc2dc ( coral_volume , rf , rp ) self . hc = vc2hc ( coral_volume , rf , rp ) self . bc = vc2bc ( coral_volume , rf , rp ) self . tc = vc2tc ( coral_volume , rf , rp ) self . ac = vc2ac ( coral_volume , rf , rp , rs )","title":"update_coral_morphology()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.update_coral_volume","text":"Updates the coral morphology based on the given coral volume. Parameters: Name Type Description Default coral_volume CoralAttribute New coral volume. required Source code in src/biota_models/coral/model/coral_model.py 159 160 161 162 163 164 165 166 167 168 169 170 def update_coral_volume ( self , coral_volume : CoralAttribute ): \"\"\" Updates the coral morphology based on the given coral volume. Args: coral_volume (CoralAttribute): New coral volume. \"\"\" # TODO what is the difference? And which volume does it call then? # TODO also function update morphology does not update coral volume self . update_coral_morphology ( coral_volume , dict ( rf = self . rf , rp = self . rp , rs = self . rs ) )","title":"update_coral_volume()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.update_cover","text":"Update cover value based on given parameters. Parameters: Name Type Description Default carrying_capacity CoralAttribute Carrying capacity [m2 m-2]. required Source code in src/biota_models/coral/model/coral_model.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def update_cover ( self , carrying_capacity : CoralAttribute ): \"\"\" Update cover value based on given parameters. Args: carrying_capacity (CoralAttribute): Carrying capacity [m2 m-2]. \"\"\" carrying_capacity = RESHAPE () . variable2array ( carrying_capacity ) if not self . volume . shape == carrying_capacity . shape : raise ValueError ( f \"Shapes do not match: \" f \" { self . volume . shape } =/= { carrying_capacity . shape } \" ) if sum ( self . volume [ carrying_capacity == 0.0 ]) > 0.0 : print ( f \"WARNING: Coral volume present where the carrying capacity is zero. This is unrealistic.\" ) self . _cover = carrying_capacity","title":"update_cover()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_model.Coral.volume","text":"Coral volume. Source code in src/biota_models/coral/model/coral_model.py 93 94 95 96 97 98 99 100 @property # changed the volume function - assigned the output coral_volume def volume ( self ): \"\"\"Coral volume.\"\"\" coral_volume = ( 0.25 * np . pi * (( self . hc - self . tc ) * self . bc ** 2 + self . tc * self . dc ** 2 ) ) return coral_volume","title":"volume()"},{"location":"reference/biota_models/coral/coral_model/#coral-constants","text":"","title":"Coral Constants"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_constants.CoralConstants","text":"Bases: BaseConstants Object containing all constants used in coral_model simulations. Source code in src/biota_models/coral/model/coral_constants.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class CoralConstants ( BaseConstants ): \"\"\"Object containing all constants used in coral_model simulations.\"\"\" # Processes fme : bool = False tme : bool = False pfd : bool = False warn_proc : bool = True # light micro-environment Kd0 : float = 0.1 theta_max : float = 0.5 * np . pi # flow micro-environment Cs : float = 0.17 Cm : float = 1.7 Cf : float = 0.01 nu : float = 1e-6 alpha : float = 1e-7 psi : float = 2 wcAngle : float = 0.0 rd : float = 500 numericTheta : float = 0.5 err : float = 1e-3 maxiter_k : int = int ( 1e5 ) maxiter_aw : int = int ( 1e5 ) # thermal micro-environment K0 : float = 80.0 ap : float = 0.4 k : float = 0.6089 # photosynthetic light dependency iota : float = 0.6 ik_max : float = 372.32 pm_max : float = 1.0 betaI : float = 0.34 betaP : float = 0.09 Icomp : float = 0.01 # photosynthetic thermal dependency Ea : float = 6e4 R : float = 8.31446261815324 k_var : float = 2.45 nn : float = 60 # photosynthetic flow dependency pfd_min : float = 0.68886964 ucr : float = 0.5173 # population dynamics r_growth : float = 0.002 r_recovery : float = 0.2 r_mortality : float = 0.04 r_bleaching : float = 8.0 # calcification gC : float = 0.5 omegaA0 : float = 5.0 omega0 : float = 0.14587415 kappaA : float = 0.66236107 # morphological development rf : float = 1.0 rp : float = 1.0 prop_form : float = 0.1 prop_plate : float = 0.5 prop_plate_flow : float = 0.1 prop_space : float = 0.5 / np . sqrt ( 2.0 ) prop_space_light : float = 0.1 prop_space_flow : float = 0.1 u0 : float = 0.2 rho_c : float = 1600.0 # dislodgement criterion sigma_t : float = 2e5 Cd : float = 1.0 rho_w : float = 1025.0 # coral recruitment no_larvae : float = 1e6 prob_settle : float = 1e-4 d_larvae : float = 1e-3 @validator ( \"maxiter_k\" , \"maxiter_aw\" , pre = True , always = True ) @classmethod def validate_scientific_int_value ( cls , v ) -> int : \"\"\" Validates the parameters that can be provided with scientific notation. Args: v (Any): Scientific value to validate. Returns: int: Validated value as integer. \"\"\" if isinstance ( v , int ): return v if isinstance ( v , float ): return int ( v ) if isinstance ( v , str ): return int ( float ( v )) raise NotImplementedError ( f \"No converter available for { type ( v ) } .\" ) @root_validator @classmethod def check_processes ( cls , values : dict ) -> dict : \"\"\" Validates the input values so that the processes are compatible between themselves. Args: values (dict): Dictionary of values already validated individually. Returns: dict: Dictionary of validated values as a whole. \"\"\" if not values [ \"pfd\" ]: if values [ \"fme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Flow micro-environment (FME) not possible \" \"when photosynthetic flow dependency (PFD) is disabled.\" ) values [ \"fme\" ] = False values [ \"tme\" ] = False else : if not values [ \"fme\" ]: if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment (TME) not possible \" \"when flow micro-environment is disabled.\" ) values [ \"tme\" ] = False if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment not fully implemented yet.\" ) if not values [ \"pfd\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Exclusion of photosynthetic flow dependency not fully implemented yet.\" ) return values def correct_values ( self ): \"\"\" Corrects values that require extra operations, such as theta_max and prop_space. \"\"\" self . theta_max *= np . pi self . prop_space /= np . sqrt ( 2.0 )","title":"CoralConstants"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_constants.CoralConstants.check_processes","text":"Validates the input values so that the processes are compatible between themselves. Parameters: Name Type Description Default values dict Dictionary of values already validated individually. required Returns: Name Type Description dict dict Dictionary of validated values as a whole. Source code in src/biota_models/coral/model/coral_constants.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @root_validator @classmethod def check_processes ( cls , values : dict ) -> dict : \"\"\" Validates the input values so that the processes are compatible between themselves. Args: values (dict): Dictionary of values already validated individually. Returns: dict: Dictionary of validated values as a whole. \"\"\" if not values [ \"pfd\" ]: if values [ \"fme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Flow micro-environment (FME) not possible \" \"when photosynthetic flow dependency (PFD) is disabled.\" ) values [ \"fme\" ] = False values [ \"tme\" ] = False else : if not values [ \"fme\" ]: if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment (TME) not possible \" \"when flow micro-environment is disabled.\" ) values [ \"tme\" ] = False if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment not fully implemented yet.\" ) if not values [ \"pfd\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Exclusion of photosynthetic flow dependency not fully implemented yet.\" ) return values","title":"check_processes()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_constants.CoralConstants.correct_values","text":"Corrects values that require extra operations, such as theta_max and prop_space. Source code in src/biota_models/coral/model/coral_constants.py 155 156 157 158 159 160 def correct_values ( self ): \"\"\" Corrects values that require extra operations, such as theta_max and prop_space. \"\"\" self . theta_max *= np . pi self . prop_space /= np . sqrt ( 2.0 )","title":"correct_values()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_constants.CoralConstants.validate_scientific_int_value","text":"Validates the parameters that can be provided with scientific notation. Parameters: Name Type Description Default v Any Scientific value to validate. required Returns: Name Type Description int int Validated value as integer. Source code in src/biota_models/coral/model/coral_constants.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @validator ( \"maxiter_k\" , \"maxiter_aw\" , pre = True , always = True ) @classmethod def validate_scientific_int_value ( cls , v ) -> int : \"\"\" Validates the parameters that can be provided with scientific notation. Args: v (Any): Scientific value to validate. Returns: int: Validated value as integer. \"\"\" if isinstance ( v , int ): return v if isinstance ( v , float ): return int ( v ) if isinstance ( v , str ): return int ( float ( v )) raise NotImplementedError ( f \"No converter available for { type ( v ) } .\" )","title":"validate_scientific_int_value()"},{"location":"reference/biota_models/coral/coral_model/#coral-utils","text":"","title":"Coral utils"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_only.CoralOnly","text":"Execute functions only in the presence of corals. Source code in src/biota_models/coral/model/coral_only.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class CoralOnly : \"\"\"Execute functions only in the presence of corals.\"\"\" spacetime = None @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ] @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ] def in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is coral cover. Args: coral (Coral): Coral object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of coral cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the coral function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output def in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == coral . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output","title":"CoralOnly"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_only.CoralOnly.in_space","text":"Only execute the function when there is coral cover. Parameters: Name Type Description Default coral Coral Coral object. required function Callable Function to be executed. required args Tuple input arguments of the function. required no_cover_value Optional [ float ] Default value in absence of coral cover. Defaults to 0. 0 Raises: Type Description ValueError When sizes do not match. Returns: Type Description np . ndarray np.ndarray: Result of the coral function. Source code in src/biota_models/coral/model/coral_only.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is coral cover. Args: coral (Coral): Coral object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of coral cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the coral function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output","title":"in_space()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_only.CoralOnly.in_spacetime","text":"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional Source code in src/biota_models/coral/model/coral_only.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == coral . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output","title":"in_spacetime()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_only.CoralOnly.space","text":"Space dimension. Source code in src/biota_models/coral/model/coral_only.py 11 12 13 14 @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ]","title":"space()"},{"location":"reference/biota_models/coral/coral_model/#src.biota_models.coral.model.coral_only.CoralOnly.time","text":"Time dimension. Source code in src/biota_models/coral/model/coral_only.py 16 17 18 19 @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ]","title":"time()"},{"location":"reference/biota_models/coral/coral_output/","text":"Output classes for the NBSDynamics coral model. \u00b6 Wrapper \u00b6 CoralOutputWrapper \u00b6 Bases: BaseOutputWrapper Output files based on predefined output content. Generate output files of CoralModel simulation. Output files are formatted as NetCDF4-files. Source code in src/biota_models/coral/output/coral_output_wrapper.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class CoralOutputWrapper ( BaseOutputWrapper ): \"\"\" Output files based on predefined output content. Generate output files of CoralModel simulation. Output files are formatted as NetCDF4-files. \"\"\" # Output models. map_output : Optional [ CoralMapOutput ] his_output : Optional [ CoralHisOutput ] def initialize ( self , coral : Coral ): \"\"\" Initializes all available output models (His and Map). Args: coral (Coral): Coral model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( coral ) self . map_output . initialize ( coral ) initialize ( coral : Coral ) \u00b6 Initializes all available output models (His and Map). Parameters: Name Type Description Default coral Coral Coral model to be used in the output. required Source code in src/biota_models/coral/output/coral_output_wrapper.py 21 22 23 24 25 26 27 28 29 30 31 32 33 def initialize ( self , coral : Coral ): \"\"\" Initializes all available output models (His and Map). Args: coral (Coral): Coral model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( coral ) self . map_output . initialize ( coral ) Output models \u00b6 CoralHisOutput \u00b6 Bases: _CoralOutput Object representing a His output. Implements the 'OutputProtocol'. Source code in src/biota_models/coral/output/coral_output_model.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 class CoralHisOutput ( _CoralOutput ): \"\"\" Object representing a His output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"CoralModel_his.nc\" xy_stations : Optional [ np . ndarray ] idx_stations : Optional [ np . ndarray ] first_date : Optional [ Union [ np . datetime64 , datetime ]] def initialize ( self , _ : Coral ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the CoralModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_lme (): light_set = _his_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"stations\" )) light_set . long_name = \"representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" def init_fme (): flow_set = _his_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"stations\" )) flow_set . long_name = \"in-canopy flow\" flow_set . units = \"m s-1\" def init_tme (): temp_set = _his_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"stations\" )) temp_set . long_name = \"coral temperature\" temp_set . units = \"K\" low_temp_set = _his_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"stations\" ) ) low_temp_set . long_name = \"lower thermal limit\" low_temp_set . units = \"K\" high_temp_set = _his_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"stations\" ) ) high_temp_set . long_name = \"upper thermal limit\" high_temp_set . units = \"K\" def init_pd (): pd_set = _his_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"stations\" )) pd_set . long_name = \"photosynthetic rate\" pd_set . units = \"-\" def init_ps (): pt_set = _his_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"stations\" )) pt_set . long_name = \"total coral population\" pt_set . units = \"-\" ph_set = _his_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"stations\" )) ph_set . long_name = \"healthy coral population\" ph_set . units = \"-\" pr_set = _his_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"stations\" )) pr_set . long_name = \"recovering coral population\" pr_set . units = \"-\" pp_set = _his_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"stations\" )) pp_set . long_name = \"pale coral population\" pp_set . units = \"-\" pb_set = _his_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"stations\" )) pb_set . long_name = \"bleached coral population\" pb_set . units = \"-\" def init_calc (): calc_set = _his_data . createVariable ( \"G\" , \"f8\" , ( \"time\" , \"stations\" )) calc_set . long_name = \"calcification\" calc_set . units = \"kg m-2 d-1\" def init_md (): dc_set = _his_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"stations\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" hc_set = _his_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"stations\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" bc_set = _his_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"stations\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" tc_set = _his_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"stations\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" ac_set = _his_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"stations\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" vc_set = _his_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"stations\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" # initial conditions conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , coral : Coral , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = ( y_dates - self . first_date ) . dt . days . values _his_data [ \"time\" ][ ti ] = y_dates . values def update_lme (): _his_data [ \"Iz\" ][ ti , :] = coral . light [ self . idx_stations , :] . transpose () def update_fme (): _his_data [ \"ucm\" ][ ti , :] = np . tile ( coral . ucm , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_tme (): _his_data [ \"Tc\" ][ ti , :] = coral . temp [ self . idx_stations , :] . transpose () if ( len ( DataReshape . variable2array ( coral . Tlo )) > 1 and len ( DataReshape . variable2array ( coral . Thi )) > 1 ): _his_data [ \"Tlo\" ][ ti , :] = np . tile ( coral . Tlo , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Thi\" ][ ti , :] = np . tile ( coral . Thi , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] else : _his_data [ \"Tlo\" ][ ti , :] = coral . Tlo * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) _his_data [ \"Thi\" ][ ti , :] = coral . Thi * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) def update_pd (): _his_data [ \"PD\" ][ ti , :] = coral . photo_rate [ self . idx_stations , : ] . transpose () def update_ps (): _his_data [ \"PT\" ][ ti , :] = ( coral . pop_states [ self . idx_stations , :, :] . sum ( axis = 2 ) . transpose () ) _his_data [ \"PH\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 0 ] . transpose () _his_data [ \"PR\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 1 ] . transpose () _his_data [ \"PP\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 2 ] . transpose () _his_data [ \"PB\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 3 ] . transpose () def update_calc (): _his_data [ \"G\" ][ ti , :] = coral . calc [ self . idx_stations , :] . transpose () def update_md (): _his_data [ \"dc\" ][ ti , :] = np . tile ( coral . dc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"hc\" ][ ti , :] = np . tile ( coral . hc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bc\" ][ ti , :] = np . tile ( coral . bc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"tc\" ][ ti , :] = np . tile ( coral . tc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"ac\" ][ ti , :] = np . tile ( coral . ac , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Vc\" ][ ti , :] = np . tile ( coral . volume , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () initialize ( _ : Coral ) \u00b6 Initiate history output file in which daily output at predefined locations within the model is stored. Source code in src/biota_models/coral/output/coral_output_model.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def initialize ( self , _ : Coral ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the CoralModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_lme (): light_set = _his_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"stations\" )) light_set . long_name = \"representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" def init_fme (): flow_set = _his_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"stations\" )) flow_set . long_name = \"in-canopy flow\" flow_set . units = \"m s-1\" def init_tme (): temp_set = _his_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"stations\" )) temp_set . long_name = \"coral temperature\" temp_set . units = \"K\" low_temp_set = _his_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"stations\" ) ) low_temp_set . long_name = \"lower thermal limit\" low_temp_set . units = \"K\" high_temp_set = _his_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"stations\" ) ) high_temp_set . long_name = \"upper thermal limit\" high_temp_set . units = \"K\" def init_pd (): pd_set = _his_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"stations\" )) pd_set . long_name = \"photosynthetic rate\" pd_set . units = \"-\" def init_ps (): pt_set = _his_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"stations\" )) pt_set . long_name = \"total coral population\" pt_set . units = \"-\" ph_set = _his_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"stations\" )) ph_set . long_name = \"healthy coral population\" ph_set . units = \"-\" pr_set = _his_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"stations\" )) pr_set . long_name = \"recovering coral population\" pr_set . units = \"-\" pp_set = _his_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"stations\" )) pp_set . long_name = \"pale coral population\" pp_set . units = \"-\" pb_set = _his_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"stations\" )) pb_set . long_name = \"bleached coral population\" pb_set . units = \"-\" def init_calc (): calc_set = _his_data . createVariable ( \"G\" , \"f8\" , ( \"time\" , \"stations\" )) calc_set . long_name = \"calcification\" calc_set . units = \"kg m-2 d-1\" def init_md (): dc_set = _his_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"stations\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" hc_set = _his_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"stations\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" bc_set = _his_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"stations\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" tc_set = _his_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"stations\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" ac_set = _his_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"stations\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" vc_set = _his_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"stations\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" # initial conditions conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () update ( coral : Coral , dates : DataFrame ) \u00b6 Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame Source code in src/biota_models/coral/output/coral_output_model.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def update ( self , coral : Coral , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = ( y_dates - self . first_date ) . dt . days . values _his_data [ \"time\" ][ ti ] = y_dates . values def update_lme (): _his_data [ \"Iz\" ][ ti , :] = coral . light [ self . idx_stations , :] . transpose () def update_fme (): _his_data [ \"ucm\" ][ ti , :] = np . tile ( coral . ucm , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_tme (): _his_data [ \"Tc\" ][ ti , :] = coral . temp [ self . idx_stations , :] . transpose () if ( len ( DataReshape . variable2array ( coral . Tlo )) > 1 and len ( DataReshape . variable2array ( coral . Thi )) > 1 ): _his_data [ \"Tlo\" ][ ti , :] = np . tile ( coral . Tlo , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Thi\" ][ ti , :] = np . tile ( coral . Thi , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] else : _his_data [ \"Tlo\" ][ ti , :] = coral . Tlo * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) _his_data [ \"Thi\" ][ ti , :] = coral . Thi * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) def update_pd (): _his_data [ \"PD\" ][ ti , :] = coral . photo_rate [ self . idx_stations , : ] . transpose () def update_ps (): _his_data [ \"PT\" ][ ti , :] = ( coral . pop_states [ self . idx_stations , :, :] . sum ( axis = 2 ) . transpose () ) _his_data [ \"PH\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 0 ] . transpose () _his_data [ \"PR\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 1 ] . transpose () _his_data [ \"PP\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 2 ] . transpose () _his_data [ \"PB\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 3 ] . transpose () def update_calc (): _his_data [ \"G\" ][ ti , :] = coral . calc [ self . idx_stations , :] . transpose () def update_md (): _his_data [ \"dc\" ][ ti , :] = np . tile ( coral . dc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"hc\" ][ ti , :] = np . tile ( coral . hc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bc\" ][ ti , :] = np . tile ( coral . bc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"tc\" ][ ti , :] = np . tile ( coral . tc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"ac\" ][ ti , :] = np . tile ( coral . ac , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Vc\" ][ ti , :] = np . tile ( coral . volume , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () CoralMapOutput \u00b6 Bases: _CoralOutput Object representing a Map output. Implements the 'OutputProtocol'. Source code in src/biota_models/coral/output/coral_output_model.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class CoralMapOutput ( _CoralOutput ): \"\"\" Object representing a Map output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"CoralModel_map.nc\" xy_coordinates : Optional [ np . ndarray ] first_year : Optional [ int ] @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates ) def initialize ( self , coral : Coral ): \"\"\"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral \"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the CoralModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"year\" t . units = \"years since 0 B.C.\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" t [:] = self . first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_lme (): light_set = _map_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) light_set . long_name = \"annual mean representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" light_set [:, :] = 0 def init_fme (): flow_set = _map_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) flow_set . long_name = \"annual mean in-canopy flow\" flow_set . units = \"m s-1\" flow_set [:, :] = 0 def init_tme (): temp_set = _map_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) temp_set . long_name = \"annual mean coral temperature\" temp_set . units = \"K\" temp_set [:, :] = 0 low_temp_set = _map_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) low_temp_set . long_name = \"annual mean lower thermal limit\" low_temp_set . units = \"K\" low_temp_set [:, :] = 0 high_temp_set = _map_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) high_temp_set . long_name = \"annual mean upper thermal limit\" high_temp_set . units = \"K\" high_temp_set [:, :] = 0 def init_pd (): pd_set = _map_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pd_set . long_name = \"annual sum photosynthetic rate\" pd_set . units = \"-\" pd_set [:, :] = 0 def init_ps (): pt_set = _map_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pt_set . long_name = ( \"total living coral population at the end of the year\" ) pt_set . units = \"-\" pt_set [:, :] = coral . living_cover ph_set = _map_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ph_set . long_name = \"healthy coral population at the end of the year\" ph_set . units = \"-\" ph_set [:, :] = coral . living_cover pr_set = _map_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pr_set . long_name = \"recovering coral population at the end of the year\" pr_set . units = \"-\" pr_set [:, :] = 0 pp_set = _map_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pp_set . long_name = \"pale coral population at the end of the year\" pp_set . units = \"-\" pp_set [:, :] = 0 pb_set = _map_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pb_set . long_name = \"bleached coral population at the end of the year\" pb_set . units = \"-\" pb_set [:, :] = 0 def init_calc (): calc_set = _map_data . createVariable ( \"calc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) calc_set . long_name = \"annual sum calcification rate\" calc_set . units = \"kg m-2 yr-1\" calc_set [:, :] = 0 def init_md (): dc_set = _map_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" dc_set [ 0 , :] = coral . dc hc_set = _map_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" hc_set [ 0 , :] = coral . hc bc_set = _map_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" bc_set [ 0 , :] = coral . bc tc_set = _map_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" tc_set [ 0 , :] = coral . tc ac_set = _map_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" ac_set [ 0 , :] = coral . ac vc_set = _map_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" vc_set [ 0 , :] = coral . volume conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , coral : Coral , year : int ): \"\"\"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = int ( year - self . first_year ) _map_data [ \"time\" ][ i ] = year def update_lme (): _map_data [ \"Iz\" ][ - 1 , :] = coral . light [:, - 1 ] def update_fme (): _map_data [ \"ucm\" ][ - 1 , :] = coral . ucm def update_tme (): _map_data [ \"Tc\" ][ - 1 , :] = coral . temp [:, - 1 ] _map_data [ \"Tlo\" ][ - 1 , :] = ( coral . Tlo if len ( DataReshape . variable2array ( coral . Tlo )) > 1 else coral . Tlo * np . ones ( self . space ) ) _map_data [ \"Thi\" ][ - 1 , :] = ( coral . Thi if len ( DataReshape . variable2array ( coral . Thi )) > 1 else coral . Thi * np . ones ( self . space ) ) def update_pd (): _map_data [ \"PD\" ][ - 1 , :] = coral . photo_rate . mean ( axis = 1 ) def update_ps (): _map_data [ \"PT\" ][ - 1 , :] = coral . pop_states [:, - 1 , :] . sum ( axis = 1 ) _map_data [ \"PH\" ][ - 1 , :] = coral . pop_states [:, - 1 , 0 ] _map_data [ \"PR\" ][ - 1 , :] = coral . pop_states [:, - 1 , 1 ] _map_data [ \"PP\" ][ - 1 , :] = coral . pop_states [:, - 1 , 2 ] _map_data [ \"PB\" ][ - 1 , :] = coral . pop_states [:, - 1 , 3 ] def update_calc (): _map_data [ \"calc\" ][ - 1 , :] = coral . calc . sum ( axis = 1 ) def update_md (): _map_data [ \"dc\" ][ - 1 , :] = coral . dc _map_data [ \"hc\" ][ - 1 , :] = coral . hc _map_data [ \"bc\" ][ - 1 , :] = coral . bc _map_data [ \"tc\" ][ - 1 , :] = coral . tc _map_data [ \"ac\" ][ - 1 , :] = coral . ac _map_data [ \"Vc\" ][ - 1 , :] = coral . volume conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () initialize ( coral : Coral ) \u00b6 Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/output/coral_output_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def initialize ( self , coral : Coral ): \"\"\"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral \"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the CoralModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"year\" t . units = \"years since 0 B.C.\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" t [:] = self . first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_lme (): light_set = _map_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) light_set . long_name = \"annual mean representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" light_set [:, :] = 0 def init_fme (): flow_set = _map_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) flow_set . long_name = \"annual mean in-canopy flow\" flow_set . units = \"m s-1\" flow_set [:, :] = 0 def init_tme (): temp_set = _map_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) temp_set . long_name = \"annual mean coral temperature\" temp_set . units = \"K\" temp_set [:, :] = 0 low_temp_set = _map_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) low_temp_set . long_name = \"annual mean lower thermal limit\" low_temp_set . units = \"K\" low_temp_set [:, :] = 0 high_temp_set = _map_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) high_temp_set . long_name = \"annual mean upper thermal limit\" high_temp_set . units = \"K\" high_temp_set [:, :] = 0 def init_pd (): pd_set = _map_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pd_set . long_name = \"annual sum photosynthetic rate\" pd_set . units = \"-\" pd_set [:, :] = 0 def init_ps (): pt_set = _map_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pt_set . long_name = ( \"total living coral population at the end of the year\" ) pt_set . units = \"-\" pt_set [:, :] = coral . living_cover ph_set = _map_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ph_set . long_name = \"healthy coral population at the end of the year\" ph_set . units = \"-\" ph_set [:, :] = coral . living_cover pr_set = _map_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pr_set . long_name = \"recovering coral population at the end of the year\" pr_set . units = \"-\" pr_set [:, :] = 0 pp_set = _map_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pp_set . long_name = \"pale coral population at the end of the year\" pp_set . units = \"-\" pp_set [:, :] = 0 pb_set = _map_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pb_set . long_name = \"bleached coral population at the end of the year\" pb_set . units = \"-\" pb_set [:, :] = 0 def init_calc (): calc_set = _map_data . createVariable ( \"calc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) calc_set . long_name = \"annual sum calcification rate\" calc_set . units = \"kg m-2 yr-1\" calc_set [:, :] = 0 def init_md (): dc_set = _map_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" dc_set [ 0 , :] = coral . dc hc_set = _map_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" hc_set [ 0 , :] = coral . hc bc_set = _map_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" bc_set [ 0 , :] = coral . bc tc_set = _map_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" tc_set [ 0 , :] = coral . tc ac_set = _map_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" ac_set [ 0 , :] = coral . ac vc_set = _map_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" vc_set [ 0 , :] = coral . volume conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () space () -> int property \u00b6 Gets the total space for the model-defined xy-coordinates. Returns: Name Type Description int int length of 'xy_coordinates'. Source code in src/biota_models/coral/output/coral_output_model.py 37 38 39 40 41 42 43 44 45 @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates ) update ( coral : Coral , year : int ) \u00b6 Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int Source code in src/biota_models/coral/output/coral_output_model.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def update ( self , coral : Coral , year : int ): \"\"\"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = int ( year - self . first_year ) _map_data [ \"time\" ][ i ] = year def update_lme (): _map_data [ \"Iz\" ][ - 1 , :] = coral . light [:, - 1 ] def update_fme (): _map_data [ \"ucm\" ][ - 1 , :] = coral . ucm def update_tme (): _map_data [ \"Tc\" ][ - 1 , :] = coral . temp [:, - 1 ] _map_data [ \"Tlo\" ][ - 1 , :] = ( coral . Tlo if len ( DataReshape . variable2array ( coral . Tlo )) > 1 else coral . Tlo * np . ones ( self . space ) ) _map_data [ \"Thi\" ][ - 1 , :] = ( coral . Thi if len ( DataReshape . variable2array ( coral . Thi )) > 1 else coral . Thi * np . ones ( self . space ) ) def update_pd (): _map_data [ \"PD\" ][ - 1 , :] = coral . photo_rate . mean ( axis = 1 ) def update_ps (): _map_data [ \"PT\" ][ - 1 , :] = coral . pop_states [:, - 1 , :] . sum ( axis = 1 ) _map_data [ \"PH\" ][ - 1 , :] = coral . pop_states [:, - 1 , 0 ] _map_data [ \"PR\" ][ - 1 , :] = coral . pop_states [:, - 1 , 1 ] _map_data [ \"PP\" ][ - 1 , :] = coral . pop_states [:, - 1 , 2 ] _map_data [ \"PB\" ][ - 1 , :] = coral . pop_states [:, - 1 , 3 ] def update_calc (): _map_data [ \"calc\" ][ - 1 , :] = coral . calc . sum ( axis = 1 ) def update_md (): _map_data [ \"dc\" ][ - 1 , :] = coral . dc _map_data [ \"hc\" ][ - 1 , :] = coral . hc _map_data [ \"bc\" ][ - 1 , :] = coral . bc _map_data [ \"tc\" ][ - 1 , :] = coral . tc _map_data [ \"ac\" ][ - 1 , :] = coral . ac _map_data [ \"Vc\" ][ - 1 , :] = coral . volume conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"Coral output"},{"location":"reference/biota_models/coral/coral_output/#output-classes-for-the-nbsdynamics-coral-model","text":"","title":"Output classes for the NBSDynamics coral model."},{"location":"reference/biota_models/coral/coral_output/#wrapper","text":"","title":"Wrapper"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_wrapper.CoralOutputWrapper","text":"Bases: BaseOutputWrapper Output files based on predefined output content. Generate output files of CoralModel simulation. Output files are formatted as NetCDF4-files. Source code in src/biota_models/coral/output/coral_output_wrapper.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class CoralOutputWrapper ( BaseOutputWrapper ): \"\"\" Output files based on predefined output content. Generate output files of CoralModel simulation. Output files are formatted as NetCDF4-files. \"\"\" # Output models. map_output : Optional [ CoralMapOutput ] his_output : Optional [ CoralHisOutput ] def initialize ( self , coral : Coral ): \"\"\" Initializes all available output models (His and Map). Args: coral (Coral): Coral model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( coral ) self . map_output . initialize ( coral )","title":"CoralOutputWrapper"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_wrapper.CoralOutputWrapper.initialize","text":"Initializes all available output models (His and Map). Parameters: Name Type Description Default coral Coral Coral model to be used in the output. required Source code in src/biota_models/coral/output/coral_output_wrapper.py 21 22 23 24 25 26 27 28 29 30 31 32 33 def initialize ( self , coral : Coral ): \"\"\" Initializes all available output models (His and Map). Args: coral (Coral): Coral model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( coral ) self . map_output . initialize ( coral )","title":"initialize()"},{"location":"reference/biota_models/coral/coral_output/#output-models","text":"","title":"Output models"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralHisOutput","text":"Bases: _CoralOutput Object representing a His output. Implements the 'OutputProtocol'. Source code in src/biota_models/coral/output/coral_output_model.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 class CoralHisOutput ( _CoralOutput ): \"\"\" Object representing a His output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"CoralModel_his.nc\" xy_stations : Optional [ np . ndarray ] idx_stations : Optional [ np . ndarray ] first_date : Optional [ Union [ np . datetime64 , datetime ]] def initialize ( self , _ : Coral ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the CoralModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_lme (): light_set = _his_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"stations\" )) light_set . long_name = \"representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" def init_fme (): flow_set = _his_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"stations\" )) flow_set . long_name = \"in-canopy flow\" flow_set . units = \"m s-1\" def init_tme (): temp_set = _his_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"stations\" )) temp_set . long_name = \"coral temperature\" temp_set . units = \"K\" low_temp_set = _his_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"stations\" ) ) low_temp_set . long_name = \"lower thermal limit\" low_temp_set . units = \"K\" high_temp_set = _his_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"stations\" ) ) high_temp_set . long_name = \"upper thermal limit\" high_temp_set . units = \"K\" def init_pd (): pd_set = _his_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"stations\" )) pd_set . long_name = \"photosynthetic rate\" pd_set . units = \"-\" def init_ps (): pt_set = _his_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"stations\" )) pt_set . long_name = \"total coral population\" pt_set . units = \"-\" ph_set = _his_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"stations\" )) ph_set . long_name = \"healthy coral population\" ph_set . units = \"-\" pr_set = _his_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"stations\" )) pr_set . long_name = \"recovering coral population\" pr_set . units = \"-\" pp_set = _his_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"stations\" )) pp_set . long_name = \"pale coral population\" pp_set . units = \"-\" pb_set = _his_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"stations\" )) pb_set . long_name = \"bleached coral population\" pb_set . units = \"-\" def init_calc (): calc_set = _his_data . createVariable ( \"G\" , \"f8\" , ( \"time\" , \"stations\" )) calc_set . long_name = \"calcification\" calc_set . units = \"kg m-2 d-1\" def init_md (): dc_set = _his_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"stations\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" hc_set = _his_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"stations\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" bc_set = _his_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"stations\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" tc_set = _his_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"stations\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" ac_set = _his_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"stations\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" vc_set = _his_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"stations\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" # initial conditions conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , coral : Coral , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = ( y_dates - self . first_date ) . dt . days . values _his_data [ \"time\" ][ ti ] = y_dates . values def update_lme (): _his_data [ \"Iz\" ][ ti , :] = coral . light [ self . idx_stations , :] . transpose () def update_fme (): _his_data [ \"ucm\" ][ ti , :] = np . tile ( coral . ucm , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_tme (): _his_data [ \"Tc\" ][ ti , :] = coral . temp [ self . idx_stations , :] . transpose () if ( len ( DataReshape . variable2array ( coral . Tlo )) > 1 and len ( DataReshape . variable2array ( coral . Thi )) > 1 ): _his_data [ \"Tlo\" ][ ti , :] = np . tile ( coral . Tlo , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Thi\" ][ ti , :] = np . tile ( coral . Thi , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] else : _his_data [ \"Tlo\" ][ ti , :] = coral . Tlo * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) _his_data [ \"Thi\" ][ ti , :] = coral . Thi * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) def update_pd (): _his_data [ \"PD\" ][ ti , :] = coral . photo_rate [ self . idx_stations , : ] . transpose () def update_ps (): _his_data [ \"PT\" ][ ti , :] = ( coral . pop_states [ self . idx_stations , :, :] . sum ( axis = 2 ) . transpose () ) _his_data [ \"PH\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 0 ] . transpose () _his_data [ \"PR\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 1 ] . transpose () _his_data [ \"PP\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 2 ] . transpose () _his_data [ \"PB\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 3 ] . transpose () def update_calc (): _his_data [ \"G\" ][ ti , :] = coral . calc [ self . idx_stations , :] . transpose () def update_md (): _his_data [ \"dc\" ][ ti , :] = np . tile ( coral . dc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"hc\" ][ ti , :] = np . tile ( coral . hc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bc\" ][ ti , :] = np . tile ( coral . bc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"tc\" ][ ti , :] = np . tile ( coral . tc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"ac\" ][ ti , :] = np . tile ( coral . ac , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Vc\" ][ ti , :] = np . tile ( coral . volume , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"CoralHisOutput"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralHisOutput.initialize","text":"Initiate history output file in which daily output at predefined locations within the model is stored. Source code in src/biota_models/coral/output/coral_output_model.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def initialize ( self , _ : Coral ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the CoralModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_lme (): light_set = _his_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"stations\" )) light_set . long_name = \"representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" def init_fme (): flow_set = _his_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"stations\" )) flow_set . long_name = \"in-canopy flow\" flow_set . units = \"m s-1\" def init_tme (): temp_set = _his_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"stations\" )) temp_set . long_name = \"coral temperature\" temp_set . units = \"K\" low_temp_set = _his_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"stations\" ) ) low_temp_set . long_name = \"lower thermal limit\" low_temp_set . units = \"K\" high_temp_set = _his_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"stations\" ) ) high_temp_set . long_name = \"upper thermal limit\" high_temp_set . units = \"K\" def init_pd (): pd_set = _his_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"stations\" )) pd_set . long_name = \"photosynthetic rate\" pd_set . units = \"-\" def init_ps (): pt_set = _his_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"stations\" )) pt_set . long_name = \"total coral population\" pt_set . units = \"-\" ph_set = _his_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"stations\" )) ph_set . long_name = \"healthy coral population\" ph_set . units = \"-\" pr_set = _his_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"stations\" )) pr_set . long_name = \"recovering coral population\" pr_set . units = \"-\" pp_set = _his_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"stations\" )) pp_set . long_name = \"pale coral population\" pp_set . units = \"-\" pb_set = _his_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"stations\" )) pb_set . long_name = \"bleached coral population\" pb_set . units = \"-\" def init_calc (): calc_set = _his_data . createVariable ( \"G\" , \"f8\" , ( \"time\" , \"stations\" )) calc_set . long_name = \"calcification\" calc_set . units = \"kg m-2 d-1\" def init_md (): dc_set = _his_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"stations\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" hc_set = _his_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"stations\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" bc_set = _his_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"stations\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" tc_set = _his_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"stations\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" ac_set = _his_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"stations\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" vc_set = _his_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"stations\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" # initial conditions conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"initialize()"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralHisOutput.update","text":"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame Source code in src/biota_models/coral/output/coral_output_model.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def update ( self , coral : Coral , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = ( y_dates - self . first_date ) . dt . days . values _his_data [ \"time\" ][ ti ] = y_dates . values def update_lme (): _his_data [ \"Iz\" ][ ti , :] = coral . light [ self . idx_stations , :] . transpose () def update_fme (): _his_data [ \"ucm\" ][ ti , :] = np . tile ( coral . ucm , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_tme (): _his_data [ \"Tc\" ][ ti , :] = coral . temp [ self . idx_stations , :] . transpose () if ( len ( DataReshape . variable2array ( coral . Tlo )) > 1 and len ( DataReshape . variable2array ( coral . Thi )) > 1 ): _his_data [ \"Tlo\" ][ ti , :] = np . tile ( coral . Tlo , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Thi\" ][ ti , :] = np . tile ( coral . Thi , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] else : _his_data [ \"Tlo\" ][ ti , :] = coral . Tlo * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) _his_data [ \"Thi\" ][ ti , :] = coral . Thi * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) def update_pd (): _his_data [ \"PD\" ][ ti , :] = coral . photo_rate [ self . idx_stations , : ] . transpose () def update_ps (): _his_data [ \"PT\" ][ ti , :] = ( coral . pop_states [ self . idx_stations , :, :] . sum ( axis = 2 ) . transpose () ) _his_data [ \"PH\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 0 ] . transpose () _his_data [ \"PR\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 1 ] . transpose () _his_data [ \"PP\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 2 ] . transpose () _his_data [ \"PB\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 3 ] . transpose () def update_calc (): _his_data [ \"G\" ][ ti , :] = coral . calc [ self . idx_stations , :] . transpose () def update_md (): _his_data [ \"dc\" ][ ti , :] = np . tile ( coral . dc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"hc\" ][ ti , :] = np . tile ( coral . hc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bc\" ][ ti , :] = np . tile ( coral . bc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"tc\" ][ ti , :] = np . tile ( coral . tc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"ac\" ][ ti , :] = np . tile ( coral . ac , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Vc\" ][ ti , :] = np . tile ( coral . volume , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"update()"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralMapOutput","text":"Bases: _CoralOutput Object representing a Map output. Implements the 'OutputProtocol'. Source code in src/biota_models/coral/output/coral_output_model.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class CoralMapOutput ( _CoralOutput ): \"\"\" Object representing a Map output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"CoralModel_map.nc\" xy_coordinates : Optional [ np . ndarray ] first_year : Optional [ int ] @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates ) def initialize ( self , coral : Coral ): \"\"\"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral \"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the CoralModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"year\" t . units = \"years since 0 B.C.\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" t [:] = self . first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_lme (): light_set = _map_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) light_set . long_name = \"annual mean representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" light_set [:, :] = 0 def init_fme (): flow_set = _map_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) flow_set . long_name = \"annual mean in-canopy flow\" flow_set . units = \"m s-1\" flow_set [:, :] = 0 def init_tme (): temp_set = _map_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) temp_set . long_name = \"annual mean coral temperature\" temp_set . units = \"K\" temp_set [:, :] = 0 low_temp_set = _map_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) low_temp_set . long_name = \"annual mean lower thermal limit\" low_temp_set . units = \"K\" low_temp_set [:, :] = 0 high_temp_set = _map_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) high_temp_set . long_name = \"annual mean upper thermal limit\" high_temp_set . units = \"K\" high_temp_set [:, :] = 0 def init_pd (): pd_set = _map_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pd_set . long_name = \"annual sum photosynthetic rate\" pd_set . units = \"-\" pd_set [:, :] = 0 def init_ps (): pt_set = _map_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pt_set . long_name = ( \"total living coral population at the end of the year\" ) pt_set . units = \"-\" pt_set [:, :] = coral . living_cover ph_set = _map_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ph_set . long_name = \"healthy coral population at the end of the year\" ph_set . units = \"-\" ph_set [:, :] = coral . living_cover pr_set = _map_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pr_set . long_name = \"recovering coral population at the end of the year\" pr_set . units = \"-\" pr_set [:, :] = 0 pp_set = _map_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pp_set . long_name = \"pale coral population at the end of the year\" pp_set . units = \"-\" pp_set [:, :] = 0 pb_set = _map_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pb_set . long_name = \"bleached coral population at the end of the year\" pb_set . units = \"-\" pb_set [:, :] = 0 def init_calc (): calc_set = _map_data . createVariable ( \"calc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) calc_set . long_name = \"annual sum calcification rate\" calc_set . units = \"kg m-2 yr-1\" calc_set [:, :] = 0 def init_md (): dc_set = _map_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" dc_set [ 0 , :] = coral . dc hc_set = _map_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" hc_set [ 0 , :] = coral . hc bc_set = _map_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" bc_set [ 0 , :] = coral . bc tc_set = _map_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" tc_set [ 0 , :] = coral . tc ac_set = _map_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" ac_set [ 0 , :] = coral . ac vc_set = _map_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" vc_set [ 0 , :] = coral . volume conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , coral : Coral , year : int ): \"\"\"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = int ( year - self . first_year ) _map_data [ \"time\" ][ i ] = year def update_lme (): _map_data [ \"Iz\" ][ - 1 , :] = coral . light [:, - 1 ] def update_fme (): _map_data [ \"ucm\" ][ - 1 , :] = coral . ucm def update_tme (): _map_data [ \"Tc\" ][ - 1 , :] = coral . temp [:, - 1 ] _map_data [ \"Tlo\" ][ - 1 , :] = ( coral . Tlo if len ( DataReshape . variable2array ( coral . Tlo )) > 1 else coral . Tlo * np . ones ( self . space ) ) _map_data [ \"Thi\" ][ - 1 , :] = ( coral . Thi if len ( DataReshape . variable2array ( coral . Thi )) > 1 else coral . Thi * np . ones ( self . space ) ) def update_pd (): _map_data [ \"PD\" ][ - 1 , :] = coral . photo_rate . mean ( axis = 1 ) def update_ps (): _map_data [ \"PT\" ][ - 1 , :] = coral . pop_states [:, - 1 , :] . sum ( axis = 1 ) _map_data [ \"PH\" ][ - 1 , :] = coral . pop_states [:, - 1 , 0 ] _map_data [ \"PR\" ][ - 1 , :] = coral . pop_states [:, - 1 , 1 ] _map_data [ \"PP\" ][ - 1 , :] = coral . pop_states [:, - 1 , 2 ] _map_data [ \"PB\" ][ - 1 , :] = coral . pop_states [:, - 1 , 3 ] def update_calc (): _map_data [ \"calc\" ][ - 1 , :] = coral . calc . sum ( axis = 1 ) def update_md (): _map_data [ \"dc\" ][ - 1 , :] = coral . dc _map_data [ \"hc\" ][ - 1 , :] = coral . hc _map_data [ \"bc\" ][ - 1 , :] = coral . bc _map_data [ \"tc\" ][ - 1 , :] = coral . tc _map_data [ \"ac\" ][ - 1 , :] = coral . ac _map_data [ \"Vc\" ][ - 1 , :] = coral . volume conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"CoralMapOutput"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralMapOutput.initialize","text":"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/output/coral_output_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def initialize ( self , coral : Coral ): \"\"\"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral \"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the CoralModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"year\" t . units = \"years since 0 B.C.\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" t [:] = self . first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_lme (): light_set = _map_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) light_set . long_name = \"annual mean representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" light_set [:, :] = 0 def init_fme (): flow_set = _map_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) flow_set . long_name = \"annual mean in-canopy flow\" flow_set . units = \"m s-1\" flow_set [:, :] = 0 def init_tme (): temp_set = _map_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) temp_set . long_name = \"annual mean coral temperature\" temp_set . units = \"K\" temp_set [:, :] = 0 low_temp_set = _map_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) low_temp_set . long_name = \"annual mean lower thermal limit\" low_temp_set . units = \"K\" low_temp_set [:, :] = 0 high_temp_set = _map_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) high_temp_set . long_name = \"annual mean upper thermal limit\" high_temp_set . units = \"K\" high_temp_set [:, :] = 0 def init_pd (): pd_set = _map_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pd_set . long_name = \"annual sum photosynthetic rate\" pd_set . units = \"-\" pd_set [:, :] = 0 def init_ps (): pt_set = _map_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pt_set . long_name = ( \"total living coral population at the end of the year\" ) pt_set . units = \"-\" pt_set [:, :] = coral . living_cover ph_set = _map_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ph_set . long_name = \"healthy coral population at the end of the year\" ph_set . units = \"-\" ph_set [:, :] = coral . living_cover pr_set = _map_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pr_set . long_name = \"recovering coral population at the end of the year\" pr_set . units = \"-\" pr_set [:, :] = 0 pp_set = _map_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pp_set . long_name = \"pale coral population at the end of the year\" pp_set . units = \"-\" pp_set [:, :] = 0 pb_set = _map_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pb_set . long_name = \"bleached coral population at the end of the year\" pb_set . units = \"-\" pb_set [:, :] = 0 def init_calc (): calc_set = _map_data . createVariable ( \"calc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) calc_set . long_name = \"annual sum calcification rate\" calc_set . units = \"kg m-2 yr-1\" calc_set [:, :] = 0 def init_md (): dc_set = _map_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" dc_set [ 0 , :] = coral . dc hc_set = _map_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" hc_set [ 0 , :] = coral . hc bc_set = _map_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" bc_set [ 0 , :] = coral . bc tc_set = _map_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" tc_set [ 0 , :] = coral . tc ac_set = _map_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" ac_set [ 0 , :] = coral . ac vc_set = _map_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" vc_set [ 0 , :] = coral . volume conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"initialize()"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralMapOutput.space","text":"Gets the total space for the model-defined xy-coordinates. Returns: Name Type Description int int length of 'xy_coordinates'. Source code in src/biota_models/coral/output/coral_output_model.py 37 38 39 40 41 42 43 44 45 @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates )","title":"space()"},{"location":"reference/biota_models/coral/coral_output/#src.biota_models.coral.output.coral_output_model.CoralMapOutput.update","text":"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int Source code in src/biota_models/coral/output/coral_output_model.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def update ( self , coral : Coral , year : int ): \"\"\"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = int ( year - self . first_year ) _map_data [ \"time\" ][ i ] = year def update_lme (): _map_data [ \"Iz\" ][ - 1 , :] = coral . light [:, - 1 ] def update_fme (): _map_data [ \"ucm\" ][ - 1 , :] = coral . ucm def update_tme (): _map_data [ \"Tc\" ][ - 1 , :] = coral . temp [:, - 1 ] _map_data [ \"Tlo\" ][ - 1 , :] = ( coral . Tlo if len ( DataReshape . variable2array ( coral . Tlo )) > 1 else coral . Tlo * np . ones ( self . space ) ) _map_data [ \"Thi\" ][ - 1 , :] = ( coral . Thi if len ( DataReshape . variable2array ( coral . Thi )) > 1 else coral . Thi * np . ones ( self . space ) ) def update_pd (): _map_data [ \"PD\" ][ - 1 , :] = coral . photo_rate . mean ( axis = 1 ) def update_ps (): _map_data [ \"PT\" ][ - 1 , :] = coral . pop_states [:, - 1 , :] . sum ( axis = 1 ) _map_data [ \"PH\" ][ - 1 , :] = coral . pop_states [:, - 1 , 0 ] _map_data [ \"PR\" ][ - 1 , :] = coral . pop_states [:, - 1 , 1 ] _map_data [ \"PP\" ][ - 1 , :] = coral . pop_states [:, - 1 , 2 ] _map_data [ \"PB\" ][ - 1 , :] = coral . pop_states [:, - 1 , 3 ] def update_calc (): _map_data [ \"calc\" ][ - 1 , :] = coral . calc . sum ( axis = 1 ) def update_md (): _map_data [ \"dc\" ][ - 1 , :] = coral . dc _map_data [ \"hc\" ][ - 1 , :] = coral . hc _map_data [ \"bc\" ][ - 1 , :] = coral . bc _map_data [ \"tc\" ][ - 1 , :] = coral . tc _map_data [ \"ac\" ][ - 1 , :] = coral . ac _map_data [ \"Vc\" ][ - 1 , :] = coral . volume conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"update()"},{"location":"reference/biota_models/coral/coral_processes/","text":"Biophysical processes \u00b6 Calcification \u00b6 Calcification \u00b6 Calcification rate. Source code in src/biota_models/coral/bio_process/calcification.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Calcification : \"\"\"Calcification rate.\"\"\" def __init__ ( self , constants : CoralConstants = CoralConstants ()): \"\"\"Calcification rate.\"\"\" self . ad = 1 self . constants = constants def calcification_rate ( self , coral , omega ): \"\"\"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray \"\"\" def aragonite_dependency ( calcification_object ): \"\"\"Aragonite dependency.\"\"\" calcification_object . ad = ( omega - self . constants . omega0 ) / ( self . constants . kappaA + omega - self . constants . omega0 ) calcification_object . ad = RESHAPE () . variable2matrix ( calcification_object . ad , \"time\" ) aragonite_dependency ( self ) coral . calc = ( self . constants . gC * coral . Csp * coral . pop_states [:, :, 0 ] * self . ad * coral . photo_rate ) __init__ ( constants : CoralConstants = CoralConstants ()) \u00b6 Calcification rate. Source code in src/biota_models/coral/bio_process/calcification.py 8 9 10 11 def __init__ ( self , constants : CoralConstants = CoralConstants ()): \"\"\"Calcification rate.\"\"\" self . ad = 1 self . constants = constants calcification_rate ( coral , omega ) \u00b6 Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray Source code in src/biota_models/coral/bio_process/calcification.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def calcification_rate ( self , coral , omega ): \"\"\"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray \"\"\" def aragonite_dependency ( calcification_object ): \"\"\"Aragonite dependency.\"\"\" calcification_object . ad = ( omega - self . constants . omega0 ) / ( self . constants . kappaA + omega - self . constants . omega0 ) calcification_object . ad = RESHAPE () . variable2matrix ( calcification_object . ad , \"time\" ) aragonite_dependency ( self ) coral . calc = ( self . constants . gC * coral . Csp * coral . pop_states [:, :, 0 ] * self . ad * coral . photo_rate ) Dislodgement \u00b6 Dislodgement \u00b6 Bases: ExtraModel Dislodgement due to storm conditions. Source code in src/biota_models/coral/bio_process/dislodgment.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class Dislodgement ( ExtraModel ): \"\"\"Dislodgement due to storm conditions.\"\"\" constants : CoralConstants = CoralConstants () dmt : Optional [ np . ndarray ] = None csf : Optional [ np . ndarray ] = None survival : Optional [ np . ndarray ] = None def update ( self , coral : Coral , survival_coefficient = 1 ): \"\"\"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # # partial dislodgement Dislodgement . partial_dislodgement ( self , coral , survival_coefficient ) # # update # population states for s in range ( 4 ): coral . p0 [:, s ] *= self . survival # morphology coral . update_coral_volume ( coral . volume * self . survival ) def partial_dislodgement ( self , coral , survival_coefficient = 1.0 ): \"\"\"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # TODO: Rewrite such that the distinction between an array or a float is well build in. try : self . survival = np . ones ( coral . dc . shape ) except TypeError : if Dislodgement . dislodgement_criterion ( self , coral ): self . survival = survival_coefficient * self . dmt / self . csf else : self . survival = 1.0 else : dislodged = Dislodgement . dislodgement_criterion ( self , coral ) self . survival [ dislodged ] = survival_coefficient * ( self . dmt [ dislodged ] / self . csf [ dislodged ] ) def dislodgement_criterion ( self , coral : Coral ): \"\"\"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral \"\"\" self . dislodgement_mechanical_threshold ( coral ) self . colony_shape_factor ( coral ) return self . dmt <= self . csf def dislodgement_mechanical_threshold ( self , coral : Coral ): \"\"\" Dislodgement Mechanical Threshold. Args: coral (Coral): Coral animal. \"\"\" # # check input if not hasattr ( coral . um , \"__iter__\" ): coral . um = np . array ([ coral . um ]) if isinstance ( coral . um , ( list , tuple )): coral . um = np . array ( coral . um ) # # calculations self . dmt = 1e20 * np . ones ( coral . um . shape ) self . dmt [ coral . um > 0 ] = self . dmt_formula ( self . constants , coral . um [ coral . um > 0 ] ) @staticmethod def dmt_formula ( constants , flow_velocity ): \"\"\"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray \"\"\" return constants . sigma_t / ( constants . rho_w * constants . Cd * flow_velocity ** 2 ) def colony_shape_factor ( self , coral : Coral ): \"\"\" Colony Shape Factor. Args: coral (Coral): Coral animal. \"\"\" self . csf = CoralOnly () . in_space ( coral = coral , function = self . csf_formula , args = ( coral . dc , coral . hc , coral . bc , coral . tc ), ) @staticmethod def csf_formula ( dc , hc , bc , tc ): \"\"\"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray \"\"\" # arms of moment arm_top = hc - 0.5 * tc arm_bottom = 0.5 * ( hc - tc ) # area of moment area_top = dc * tc area_bottom = bc * ( hc - tc ) # integral integral = arm_top * area_top + arm_bottom * area_bottom # colony shape factor return 16.0 / ( np . pi * bc ** 3 ) * integral colony_shape_factor ( coral : Coral ) \u00b6 Colony Shape Factor. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/biota_models/coral/bio_process/dislodgment.py 98 99 100 101 102 103 104 105 106 107 108 109 def colony_shape_factor ( self , coral : Coral ): \"\"\" Colony Shape Factor. Args: coral (Coral): Coral animal. \"\"\" self . csf = CoralOnly () . in_space ( coral = coral , function = self . csf_formula , args = ( coral . dc , coral . hc , coral . bc , coral . tc ), ) csf_formula ( dc , hc , bc , tc ) staticmethod \u00b6 Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/dislodgment.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @staticmethod def csf_formula ( dc , hc , bc , tc ): \"\"\"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray \"\"\" # arms of moment arm_top = hc - 0.5 * tc arm_bottom = 0.5 * ( hc - tc ) # area of moment area_top = dc * tc area_bottom = bc * ( hc - tc ) # integral integral = arm_top * area_top + arm_bottom * area_bottom # colony shape factor return 16.0 / ( np . pi * bc ** 3 ) * integral dislodgement_criterion ( coral : Coral ) \u00b6 Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/dislodgment.py 60 61 62 63 64 65 66 67 68 def dislodgement_criterion ( self , coral : Coral ): \"\"\"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral \"\"\" self . dislodgement_mechanical_threshold ( coral ) self . colony_shape_factor ( coral ) return self . dmt <= self . csf dislodgement_mechanical_threshold ( coral : Coral ) \u00b6 Dislodgement Mechanical Threshold. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/biota_models/coral/bio_process/dislodgment.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def dislodgement_mechanical_threshold ( self , coral : Coral ): \"\"\" Dislodgement Mechanical Threshold. Args: coral (Coral): Coral animal. \"\"\" # # check input if not hasattr ( coral . um , \"__iter__\" ): coral . um = np . array ([ coral . um ]) if isinstance ( coral . um , ( list , tuple )): coral . um = np . array ( coral . um ) # # calculations self . dmt = 1e20 * np . ones ( coral . um . shape ) self . dmt [ coral . um > 0 ] = self . dmt_formula ( self . constants , coral . um [ coral . um > 0 ] ) dmt_formula ( constants , flow_velocity ) staticmethod \u00b6 Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/dislodgment.py 89 90 91 92 93 94 95 96 @staticmethod def dmt_formula ( constants , flow_velocity ): \"\"\"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray \"\"\" return constants . sigma_t / ( constants . rho_w * constants . Cd * flow_velocity ** 2 ) partial_dislodgement ( coral , survival_coefficient = 1.0 ) \u00b6 Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/biota_models/coral/bio_process/dislodgment.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def partial_dislodgement ( self , coral , survival_coefficient = 1.0 ): \"\"\"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # TODO: Rewrite such that the distinction between an array or a float is well build in. try : self . survival = np . ones ( coral . dc . shape ) except TypeError : if Dislodgement . dislodgement_criterion ( self , coral ): self . survival = survival_coefficient * self . dmt / self . csf else : self . survival = 1.0 else : dislodged = Dislodgement . dislodgement_criterion ( self , coral ) self . survival [ dislodged ] = survival_coefficient * ( self . dmt [ dislodged ] / self . csf [ dislodged ] ) update ( coral : Coral , survival_coefficient = 1 ) \u00b6 Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/biota_models/coral/bio_process/dislodgment.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def update ( self , coral : Coral , survival_coefficient = 1 ): \"\"\"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # # partial dislodgement Dislodgement . partial_dislodgement ( self , coral , survival_coefficient ) # # update # population states for s in range ( 4 ): coral . p0 [:, s ] *= self . survival # morphology coral . update_coral_volume ( coral . volume * self . survival ) Flow \u00b6 Flow \u00b6 Flow micro-environment. Source code in src/biota_models/coral/bio_process/flow.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 class Flow : \"\"\"Flow micro-environment.\"\"\" def __init__ ( self , u_current , u_wave , h , peak_period , constants : CoralConstants = CoralConstants (), ): \"\"\" :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray \"\"\" _reshape = RESHAPE () self . uc = _reshape . variable2array ( u_current ) self . uw = _reshape . variable2array ( u_wave ) self . h = _reshape . variable2matrix ( h , \"space\" ) self . Tp = _reshape . variable2array ( peak_period ) self . active = False if u_current is None and u_wave is None else True self . constants = constants @property def uc_matrix ( self ): \"\"\"Reshaped current flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uc , \"space\" ) @property def uw_matrix ( self ): \"\"\"Reshaped wave flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uw , \"space\" ) def velocities ( self , coral , in_canopy = True ): \"\"\"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional \"\"\" if self . active : alpha_w = np . ones ( self . uw . shape ) alpha_c = np . ones ( self . uc . shape ) if in_canopy : idx = coral . volume > 0 for i in idx : alpha_w [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uw [ i ], self . Tp [ i ], self . h [ i ], wac_type = \"wave\" , ) alpha_c [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uc [ i ], 1e3 , self . h [ i ], wac_type = \"current\" , ) coral . ucm = self . wave_current ( alpha_w , alpha_c ) coral . um = self . wave_current () else : coral . ucm = 9999 * np . ones ( RESHAPE () . space ) def wave_current ( self , alpha_w = 1 , alpha_c = 1 ): \"\"\"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray \"\"\" return np . sqrt ( ( alpha_w * self . uw ) ** 2 + ( alpha_c * self . uc ) ** 2 + 2 * alpha_w * self . uw * alpha_c * self . uc * np . cos ( self . constants . wcAngle ) ) @staticmethod def wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ): \"\"\"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str \"\"\" # TODO: Split this method in one solely focusing on the wave attenuation coefficient; # and one implementing this method to dynamically determine the drag coefficient. # Thus, reformat this method as in coral_model_v0. # # function and derivative definitions def function ( beta ): \"\"\"Complex-valued function to be solved, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * shear_length ) * ( abs ( 1.0 - beta ) * ( 1.0 - beta )) ) drag = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * drag_length ) * ( abs ( beta ) * beta ) ) inertia = ( 1 j * beta * (( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar )) ) # combined f = 1 j * ( beta - 1.0 ) - shear + drag + inertia # output return f def derivative ( beta ): \"\"\"Complex-valued derivative to be used to solve the complex-valued function, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 1.0 - beta ) ** 2 / abs ( 1.0 - beta ) - abs ( 1.0 - beta ) ) / shear_length drag = ( beta ** 2 / abs ( beta ) + beta ) / drag_length inertia = 1 j * ( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar ) # combined df = 1 j + ( 8.0 * above_motion ) / ( 3.0 * np . pi ) * ( - shear + drag ) + inertia # output return df # # Input check def wave_wac (): return abs ( newton ( function , x0 = complex ( 0.1 , 0.1 ), fprime = derivative , maxiter = constants . maxiter_aw , ) ) def current_wac (): x = drag_length / shear_length * ( height / ( depth - height ) + 1 ) return ( x - np . sqrt ( x )) / ( x - 1 ) wac_type_funcs = dict ( current = current_wac , wave = wave_wac ) wac_function = wac_type_funcs . get ( wac_type , None ) if wac_function is None : raise ValueError ( f \"WAC-type ( { wac_type } ) not in { wac_type_funcs . keys () } .\" ) # # parameter definitions # geometric parameters planar_area = 0.25 * np . pi * diameter ** 2 frontal_area = diameter * height total_area = 0.5 * distance ** 2 lambda_planar = planar_area / total_area lambda_frontal = frontal_area / total_area shear_length = height / ( constants . Cs ** 2 ) # # calculations wac = 1.0 if depth <= height : return wac # If depth > height # initial iteration values above_flow = velocity drag_coefficient = 1.0 # iteration for k in range ( int ( constants . maxiter_k )): drag_length = ( 2 * height * ( 1 - lambda_planar )) / ( drag_coefficient * lambda_frontal ) above_motion = ( above_flow * period ) / ( 2 * np . pi ) wac = wac_function () porous_flow = wac * above_flow constricted_flow = ( ( 1 - lambda_planar ) / ( 1 - np . sqrt (( 4 * lambda_planar ) / ( constants . psi * np . pi ))) * porous_flow ) reynolds = ( constricted_flow * diameter ) / constants . nu new_drag = 1 + 10 * reynolds ** ( - 2.0 / 3 ) if abs (( new_drag - drag_coefficient ) / new_drag ) <= constants . err : break else : drag_coefficient = float ( new_drag ) above_flow = abs ( ( 1 - constants . numericTheta ) * above_flow + constants . numericTheta * ( depth * velocity - height * porous_flow ) / ( depth - height ) ) if k == constants . maxiter_k : print ( f \"WARNING: maximum number of iterations reached \" f \"( { constants . maxiter_k } )\" ) return wac def thermal_boundary_layer ( self , coral ): \"\"\"Thermal boundary layer. :param coral: coral animal :type coral: Coral \"\"\" if self . active and self . constants . tme : delta = self . velocity_boundary_layer ( self . constants , coral ) coral . delta_t = delta * ( ( self . constants . alpha / self . constants . nu ) ** ( 1 / 3 ) ) @staticmethod def velocity_boundary_layer ( constants , coral ): \"\"\"Velocity boundary layer. :param coral: coral animal :type coral: Coral \"\"\" def boundary_layer ( rd , nu , cf , ucm ): \"\"\"Thickness velocity boundary layer.\"\"\" return ( rd * nu ) / ( np . sqrt ( cf ) * ucm ) return CoralOnly () . in_space ( coral = coral , function = boundary_layer , args = ( constants . rd , constants . nu , constants . Cf , coral . ucm ), ) __init__ ( u_current , u_wave , h , peak_period , constants : CoralConstants = CoralConstants ()) \u00b6 :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray Source code in src/biota_models/coral/bio_process/flow.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , u_current , u_wave , h , peak_period , constants : CoralConstants = CoralConstants (), ): \"\"\" :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray \"\"\" _reshape = RESHAPE () self . uc = _reshape . variable2array ( u_current ) self . uw = _reshape . variable2array ( u_wave ) self . h = _reshape . variable2matrix ( h , \"space\" ) self . Tp = _reshape . variable2array ( peak_period ) self . active = False if u_current is None and u_wave is None else True self . constants = constants thermal_boundary_layer ( coral ) \u00b6 Thermal boundary layer. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/flow.py 241 242 243 244 245 246 247 248 249 250 251 def thermal_boundary_layer ( self , coral ): \"\"\"Thermal boundary layer. :param coral: coral animal :type coral: Coral \"\"\" if self . active and self . constants . tme : delta = self . velocity_boundary_layer ( self . constants , coral ) coral . delta_t = delta * ( ( self . constants . alpha / self . constants . nu ) ** ( 1 / 3 ) ) uc_matrix () property \u00b6 Reshaped current flow velocity. Source code in src/biota_models/coral/bio_process/flow.py 39 40 41 42 @property def uc_matrix ( self ): \"\"\"Reshaped current flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uc , \"space\" ) uw_matrix () property \u00b6 Reshaped wave flow velocity. Source code in src/biota_models/coral/bio_process/flow.py 44 45 46 47 @property def uw_matrix ( self ): \"\"\"Reshaped wave flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uw , \"space\" ) velocities ( coral , in_canopy = True ) \u00b6 In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional Source code in src/biota_models/coral/bio_process/flow.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def velocities ( self , coral , in_canopy = True ): \"\"\"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional \"\"\" if self . active : alpha_w = np . ones ( self . uw . shape ) alpha_c = np . ones ( self . uc . shape ) if in_canopy : idx = coral . volume > 0 for i in idx : alpha_w [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uw [ i ], self . Tp [ i ], self . h [ i ], wac_type = \"wave\" , ) alpha_c [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uc [ i ], 1e3 , self . h [ i ], wac_type = \"current\" , ) coral . ucm = self . wave_current ( alpha_w , alpha_c ) coral . um = self . wave_current () else : coral . ucm = 9999 * np . ones ( RESHAPE () . space ) velocity_boundary_layer ( constants , coral ) staticmethod \u00b6 Velocity boundary layer. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/flow.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def velocity_boundary_layer ( constants , coral ): \"\"\"Velocity boundary layer. :param coral: coral animal :type coral: Coral \"\"\" def boundary_layer ( rd , nu , cf , ucm ): \"\"\"Thickness velocity boundary layer.\"\"\" return ( rd * nu ) / ( np . sqrt ( cf ) * ucm ) return CoralOnly () . in_space ( coral = coral , function = boundary_layer , args = ( constants . rd , constants . nu , constants . Cf , coral . ucm ), ) wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ) staticmethod \u00b6 Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str Source code in src/biota_models/coral/bio_process/flow.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @staticmethod def wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ): \"\"\"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str \"\"\" # TODO: Split this method in one solely focusing on the wave attenuation coefficient; # and one implementing this method to dynamically determine the drag coefficient. # Thus, reformat this method as in coral_model_v0. # # function and derivative definitions def function ( beta ): \"\"\"Complex-valued function to be solved, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * shear_length ) * ( abs ( 1.0 - beta ) * ( 1.0 - beta )) ) drag = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * drag_length ) * ( abs ( beta ) * beta ) ) inertia = ( 1 j * beta * (( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar )) ) # combined f = 1 j * ( beta - 1.0 ) - shear + drag + inertia # output return f def derivative ( beta ): \"\"\"Complex-valued derivative to be used to solve the complex-valued function, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 1.0 - beta ) ** 2 / abs ( 1.0 - beta ) - abs ( 1.0 - beta ) ) / shear_length drag = ( beta ** 2 / abs ( beta ) + beta ) / drag_length inertia = 1 j * ( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar ) # combined df = 1 j + ( 8.0 * above_motion ) / ( 3.0 * np . pi ) * ( - shear + drag ) + inertia # output return df # # Input check def wave_wac (): return abs ( newton ( function , x0 = complex ( 0.1 , 0.1 ), fprime = derivative , maxiter = constants . maxiter_aw , ) ) def current_wac (): x = drag_length / shear_length * ( height / ( depth - height ) + 1 ) return ( x - np . sqrt ( x )) / ( x - 1 ) wac_type_funcs = dict ( current = current_wac , wave = wave_wac ) wac_function = wac_type_funcs . get ( wac_type , None ) if wac_function is None : raise ValueError ( f \"WAC-type ( { wac_type } ) not in { wac_type_funcs . keys () } .\" ) # # parameter definitions # geometric parameters planar_area = 0.25 * np . pi * diameter ** 2 frontal_area = diameter * height total_area = 0.5 * distance ** 2 lambda_planar = planar_area / total_area lambda_frontal = frontal_area / total_area shear_length = height / ( constants . Cs ** 2 ) # # calculations wac = 1.0 if depth <= height : return wac # If depth > height # initial iteration values above_flow = velocity drag_coefficient = 1.0 # iteration for k in range ( int ( constants . maxiter_k )): drag_length = ( 2 * height * ( 1 - lambda_planar )) / ( drag_coefficient * lambda_frontal ) above_motion = ( above_flow * period ) / ( 2 * np . pi ) wac = wac_function () porous_flow = wac * above_flow constricted_flow = ( ( 1 - lambda_planar ) / ( 1 - np . sqrt (( 4 * lambda_planar ) / ( constants . psi * np . pi ))) * porous_flow ) reynolds = ( constricted_flow * diameter ) / constants . nu new_drag = 1 + 10 * reynolds ** ( - 2.0 / 3 ) if abs (( new_drag - drag_coefficient ) / new_drag ) <= constants . err : break else : drag_coefficient = float ( new_drag ) above_flow = abs ( ( 1 - constants . numericTheta ) * above_flow + constants . numericTheta * ( depth * velocity - height * porous_flow ) / ( depth - height ) ) if k == constants . maxiter_k : print ( f \"WARNING: maximum number of iterations reached \" f \"( { constants . maxiter_k } )\" ) return wac wave_current ( alpha_w = 1 , alpha_c = 1 ) \u00b6 Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/flow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def wave_current ( self , alpha_w = 1 , alpha_c = 1 ): \"\"\"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray \"\"\" return np . sqrt ( ( alpha_w * self . uw ) ** 2 + ( alpha_c * self . uc ) ** 2 + 2 * alpha_w * self . uw * alpha_c * self . uc * np . cos ( self . constants . wcAngle ) ) Light \u00b6 Light \u00b6 Light micro-environment. Source code in src/biota_models/coral/bio_process/light.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class Light : \"\"\"Light micro-environment.\"\"\" def __init__ ( self , light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : CoralConstants = CoralConstants (), ): \"\"\" Light micro-environment. Args: light_in (LightVariable): Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] lac (LightVariable): light-attenuation coefficient [m-1] depth (LightVariable): water depth [m] constants (Constants): List of constants to be used for this object. \"\"\" _reshape = RESHAPE () self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . Kd = _reshape . variable2matrix ( lac , \"time\" ) self . h = _reshape . variable2matrix ( depth , \"space\" ) self . constants = constants def rep_light ( self , coral ): \"\"\"Representative light-intensity. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) # # light catchment per coral section # top of plate top = ( 0.25 * np . pi * coral . dc_matrix ** 2 * self . I0 * np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) ) # side of plate side = ( ( np . pi * coral . dc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) - np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix )) ) * self . side_correction ( coral ) ) # side of base base = ( ( np . pi * coral . bc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - base_section )) - np . exp ( - self . Kd * self . h )) * self . side_correction ( coral ) ) # total total = top + side + base # # biomass-averaged self . biomass ( coral ) def averaged_light ( total_light , biomass ): \"\"\"Averaged light-intensity.\"\"\" return total_light / biomass coral . light = CoralOnly () . in_spacetime ( coral = coral , function = averaged_light , args = ( total , coral . light_bc ), no_cover_value = self . I0 * np . exp ( - self . Kd * self . h ), ) def biomass ( self , coral ): \"\"\"Coral biomass; as surface. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) coral . light_bc = np . pi * ( 0.25 * coral . dc_matrix ** 2 + coral . dc_matrix * coral . tc_matrix + coral . bc_matrix * base_section ) def base_light ( self , coral ): \"\"\"Section of coral base receiving light. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # coral base section base_section = ( coral . hc_matrix - coral . tc_matrix - (( coral . dc_matrix - coral . bc_matrix ) / ( 2.0 * np . tan ( 0.5 * theta ))) ) # no negative lengths base_section [ base_section < 0 ] = 0 return base_section def light_spreading ( self , coral ): \"\"\"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral \"\"\" return self . constants . theta_max * np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix ) ) def side_correction ( self , coral ): \"\"\"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # correction factor return np . sin ( 0.5 * theta ) __init__ ( light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : CoralConstants = CoralConstants ()) \u00b6 Light micro-environment. Parameters: Name Type Description Default light_in LightVariable Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] required lac LightVariable light-attenuation coefficient [m-1] required depth LightVariable water depth [m] required constants Constants List of constants to be used for this object. CoralConstants() Source code in src/biota_models/coral/bio_process/light.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : CoralConstants = CoralConstants (), ): \"\"\" Light micro-environment. Args: light_in (LightVariable): Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] lac (LightVariable): light-attenuation coefficient [m-1] depth (LightVariable): water depth [m] constants (Constants): List of constants to be used for this object. \"\"\" _reshape = RESHAPE () self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . Kd = _reshape . variable2matrix ( lac , \"time\" ) self . h = _reshape . variable2matrix ( depth , \"space\" ) self . constants = constants base_light ( coral ) \u00b6 Section of coral base receiving light. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def base_light ( self , coral ): \"\"\"Section of coral base receiving light. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # coral base section base_section = ( coral . hc_matrix - coral . tc_matrix - (( coral . dc_matrix - coral . bc_matrix ) / ( 2.0 * np . tan ( 0.5 * theta ))) ) # no negative lengths base_section [ base_section < 0 ] = 0 return base_section biomass ( coral ) \u00b6 Coral biomass; as surface. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 88 89 90 91 92 93 94 95 96 97 98 99 def biomass ( self , coral ): \"\"\"Coral biomass; as surface. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) coral . light_bc = np . pi * ( 0.25 * coral . dc_matrix ** 2 + coral . dc_matrix * coral . tc_matrix + coral . bc_matrix * base_section ) light_spreading ( coral ) \u00b6 Spreading of light as function of depth. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 121 122 123 124 125 126 127 128 129 def light_spreading ( self , coral ): \"\"\"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral \"\"\" return self . constants . theta_max * np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix ) ) rep_light ( coral ) \u00b6 Representative light-intensity. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def rep_light ( self , coral ): \"\"\"Representative light-intensity. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) # # light catchment per coral section # top of plate top = ( 0.25 * np . pi * coral . dc_matrix ** 2 * self . I0 * np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) ) # side of plate side = ( ( np . pi * coral . dc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) - np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix )) ) * self . side_correction ( coral ) ) # side of base base = ( ( np . pi * coral . bc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - base_section )) - np . exp ( - self . Kd * self . h )) * self . side_correction ( coral ) ) # total total = top + side + base # # biomass-averaged self . biomass ( coral ) def averaged_light ( total_light , biomass ): \"\"\"Averaged light-intensity.\"\"\" return total_light / biomass coral . light = CoralOnly () . in_spacetime ( coral = coral , function = averaged_light , args = ( total , coral . light_bc ), no_cover_value = self . I0 * np . exp ( - self . Kd * self . h ), ) side_correction ( coral ) \u00b6 Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 131 132 133 134 135 136 137 138 139 140 141 def side_correction ( self , coral ): \"\"\"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # correction factor return np . sin ( 0.5 * theta ) Morphology \u00b6 Morphology \u00b6 Morphological development. Source code in src/biota_models/coral/bio_process/morphology.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class Morphology : \"\"\"Morphological development.\"\"\" __rf_optimal = None __rp_optimal = None __rs_optimal = None def __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : CoralConstants = CoralConstants (), ): \"\"\" Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int \"\"\" _reshape = RESHAPE () try : _ = len ( calc_sum [ 0 ]) except TypeError : self . calc_sum = calc_sum else : self . calc_sum = _reshape . matrix2array ( calc_sum , \"space\" , \"sum\" ) self . dt_year = dt_year self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . vol_increase = 0 self . constants = constants @staticmethod def __coral_object_checker ( coral ): \"\"\"Check the suitability of the coral-object for the morphological development. :param coral: coral animal :type coral: Coral \"\"\" # coral must be of type Coral if not isinstance ( coral , Coral ): msg = f \"The optimal ratios are set using the Coral-object, { type ( coral ) } is given.\" raise TypeError ( msg ) # coral must have light and flow condition attributes if not hasattr ( coral , \"light\" ) and not hasattr ( coral , \"ucm\" ): msg = ( f \"The optimal ratios are determined based on the coral's light and flow conditions; \" f \"none are provided.\" ) raise AttributeError ( msg ) @property def rf_optimal ( self ): \"\"\"Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rf_optimal @rf_optimal . setter def rf_optimal ( self , coral ): \"\"\" :param coral: coral animal :type coral: Coral \"\"\" self . __coral_object_checker ( coral ) rf = self . constants . rf # rf = ( # self.constants.prop_form # * (coral.light.mean(axis=1) / self.I0.mean(axis=1)) # * (self.constants.u0 / 1e-6) # ) # rf[coral.ucm > 0] = ( # self.constants.prop_form # * ( # coral.light.mean(axis=1)[coral.ucm > 0] # / self.I0.mean(axis=1)[coral.ucm > 0] # ) # * (self.constants.u0 / coral.ucm[coral.ucm > 0]) # ) self . __rf_optimal = rf @property def rp_optimal ( self ): \"\"\"Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rp_optimal @rp_optimal . setter def rp_optimal ( self , coral ): \"\"\" :param coral: coral animal :type coral: Coral \"\"\" self . __coral_object_checker ( coral ) self . __rp_optimal = self . constants . rp # self.__rp_optimal = self.constants.prop_plate * ( # 1.0 # + np.tanh( # self.constants.prop_plate_flow # * (coral.ucm - self.constants.u0) # / self.constants.u0 # ) # ) @property def rs_optimal ( self ): \"\"\"Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray \"\"\" return self . __rs_optimal @rs_optimal . setter def rs_optimal ( self , coral ): \"\"\" :param coral: coral animal :type coral: Coral \"\"\" self . __coral_object_checker ( coral ) # self.__rs_optimal = 0.5 / np.sqrt(2.0) * 0.25 self . __rs_optimal = ( self . constants . prop_space * ( 1.0 - np . tanh ( self . constants . prop_space_light * coral . light . mean ( axis = 1 ) / self . I0 . mean ( axis = 1 ) ) ) * ( 1.0 + np . tanh ( self . constants . prop_space_flow * ( coral . ucm - self . constants . u0 ) / self . constants . u0 ) ) ) def delta_volume ( self , coral ): \"\"\" :param coral: coral object :type coral: Coral \"\"\" self . vol_increase = ( 0.5 * coral . ac ** 2 * self . calc_sum * self . dt_year / self . constants . rho_c * coral . light_bc . mean ( axis = 1 ) ) return self . vol_increase def ratio_update ( self , coral , ratio ): \"\"\" :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str \"\"\" # partial differential equation - mass balance def mass_balance ( r_old , r_opt ): \"\"\"Mass balance.\"\"\" return ( coral . volume * r_old + self . vol_increase * r_opt ) / ( coral . volume + self . vol_increase ) # input check ratios = ( \"rf\" , \"rp\" , \"rs\" ) if ratio not in ratios : msg = f \" { ratio } not in { ratios } .\" raise ValueError ( msg ) # calculations self . delta_volume ( coral ) # optimal ratio setattr ( self , f \" { ratio } _optimal\" , coral ) # update morphological ratio if hasattr ( self , f \" { ratio } _optimal\" ) and hasattr ( coral , ratio ): return mass_balance ( getattr ( coral , ratio ), getattr ( self , f \" { ratio } _optimal\" ) ) def update ( self , coral : Coral ): \"\"\"Update morphology. :param coral: coral animal :type coral: Coral \"\"\" # # calculations # updated ratios ratios = { ratio : self . ratio_update ( coral , ratio ) for ratio in ( \"rf\" , \"rp\" , \"rs\" ) } # updated volume volume = coral . volume + self . vol_increase # update coral morphology coral . update_coral_morphology ( volume , ratios ) __coral_object_checker ( coral ) staticmethod \u00b6 Check the suitability of the coral-object for the morphological development. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/morphology.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @staticmethod def __coral_object_checker ( coral ): \"\"\"Check the suitability of the coral-object for the morphological development. :param coral: coral animal :type coral: Coral \"\"\" # coral must be of type Coral if not isinstance ( coral , Coral ): msg = f \"The optimal ratios are set using the Coral-object, { type ( coral ) } is given.\" raise TypeError ( msg ) # coral must have light and flow condition attributes if not hasattr ( coral , \"light\" ) and not hasattr ( coral , \"ucm\" ): msg = ( f \"The optimal ratios are determined based on the coral's light and flow conditions; \" f \"none are provided.\" ) raise AttributeError ( msg ) __init__ ( calc_sum , light_in , dt_year = 1 , constants : CoralConstants = CoralConstants ()) \u00b6 Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int Source code in src/biota_models/coral/bio_process/morphology.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : CoralConstants = CoralConstants (), ): \"\"\" Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int \"\"\" _reshape = RESHAPE () try : _ = len ( calc_sum [ 0 ]) except TypeError : self . calc_sum = calc_sum else : self . calc_sum = _reshape . matrix2array ( calc_sum , \"space\" , \"sum\" ) self . dt_year = dt_year self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . vol_increase = 0 self . constants = constants delta_volume ( coral ) \u00b6 :param coral: coral object :type coral: Coral Source code in src/biota_models/coral/bio_process/morphology.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def delta_volume ( self , coral ): \"\"\" :param coral: coral object :type coral: Coral \"\"\" self . vol_increase = ( 0.5 * coral . ac ** 2 * self . calc_sum * self . dt_year / self . constants . rho_c * coral . light_bc . mean ( axis = 1 ) ) return self . vol_increase ratio_update ( coral , ratio ) \u00b6 :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str Source code in src/biota_models/coral/bio_process/morphology.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def ratio_update ( self , coral , ratio ): \"\"\" :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str \"\"\" # partial differential equation - mass balance def mass_balance ( r_old , r_opt ): \"\"\"Mass balance.\"\"\" return ( coral . volume * r_old + self . vol_increase * r_opt ) / ( coral . volume + self . vol_increase ) # input check ratios = ( \"rf\" , \"rp\" , \"rs\" ) if ratio not in ratios : msg = f \" { ratio } not in { ratios } .\" raise ValueError ( msg ) # calculations self . delta_volume ( coral ) # optimal ratio setattr ( self , f \" { ratio } _optimal\" , coral ) # update morphological ratio if hasattr ( self , f \" { ratio } _optimal\" ) and hasattr ( coral , ratio ): return mass_balance ( getattr ( coral , ratio ), getattr ( self , f \" { ratio } _optimal\" ) ) rf_optimal () property writable \u00b6 Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/morphology.py 67 68 69 70 71 72 73 @property def rf_optimal ( self ): \"\"\"Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rf_optimal rp_optimal () property writable \u00b6 Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/morphology.py 100 101 102 103 104 105 106 @property def rp_optimal ( self ): \"\"\"Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rp_optimal rs_optimal () property writable \u00b6 Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/morphology.py 126 127 128 129 130 131 132 @property def rs_optimal ( self ): \"\"\"Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray \"\"\" return self . __rs_optimal update ( coral : Coral ) \u00b6 Update morphology. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/morphology.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def update ( self , coral : Coral ): \"\"\"Update morphology. :param coral: coral animal :type coral: Coral \"\"\" # # calculations # updated ratios ratios = { ratio : self . ratio_update ( coral , ratio ) for ratio in ( \"rf\" , \"rp\" , \"rs\" ) } # updated volume volume = coral . volume + self . vol_increase # update coral morphology coral . update_coral_morphology ( volume , ratios ) Photosynthesis \u00b6 Photosynthesis \u00b6 Photosynthesis. Source code in src/biota_models/coral/bio_process/photosynthesis.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class Photosynthesis : \"\"\"Photosynthesis.\"\"\" def __init__ ( self , light_in , first_year , constants : CoralConstants = CoralConstants () ): \"\"\" Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool \"\"\" self . I0 = RESHAPE () . variable2matrix ( light_in , \"time\" ) self . first_year = first_year self . pld = 1 self . ptd = 1 self . pfd = 1 self . constants = constants def photo_rate ( self , coral , environment , year ): \"\"\"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int \"\"\" # components self . light_dependency ( coral , \"qss\" ) self . thermal_dependency ( coral , environment , year ) self . flow_dependency ( coral ) # combined coral . photo_rate = self . pld * self . ptd * self . pfd def light_dependency ( self , coral , output ): \"\"\"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str \"\"\" def photo_acclimation ( x_old , param ): \"\"\"Photo-acclimation.\"\"\" # input check params = ( \"Ik\" , \"Pmax\" ) if param not in params : message = f \" { param } not in { params } .\" raise ValueError ( message ) # parameter definitions x_max = self . constants . ik_max if param == \"Ik\" else self . constants . pm_max beta_x = self . constants . betaI if param == \"Ik\" else self . constants . betaP # calculations xs = x_max * ( coral . light / self . I0 ) ** beta_x if output == \"qss\" : return xs elif output == \"new\" : return xs + ( x_old - xs ) * np . exp ( - self . constants . iota ) # # parameter definitions if output == \"qss\" : ik = photo_acclimation ( None , \"Ik\" ) p_max = photo_acclimation ( None , \"Pmax\" ) else : msg = f \"Only the quasi-steady state solution is currently implemented; use key-word 'qss'.\" raise NotImplementedError ( msg ) # # calculations self . pld = p_max * ( np . tanh ( coral . light / ik ) - np . tanh ( self . constants . Icomp * self . I0 / ik ) ) def thermal_dependency ( self , coral : Coral , env , year ): \"\"\"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int \"\"\" _reshape = RESHAPE () def thermal_acc (): \"\"\"Thermal-acclimation.\"\"\" if self . constants . tme : if self . first_year : env . tmeMMMmin = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"min\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) env . tmeMMMmax = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"max\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) else : env . tmeMMMmin [ env . tmeMMM . index == year ] += coral . dTc env . tmeMMMmax [ env . tmeMMm . index == year ] += coral . dTc mmm_min = env . tmeMMMmin [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min = mmm_min . mean ( axis = 0 ) s_min = mmm_min . std ( axis = 0 ) mmm_max = env . tmeMMMmax [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_max = mmm_max . mean ( axis = 0 ) s_max = mmm_max . std ( axis = 0 ) else : mmm = env . temp_mmm [ np . logical_and ( env . temp_mmm . index < year , env . temp_mmm . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min , m_max = mmm . mean ( axis = 0 ) s_min , s_max = mmm . std ( axis = 0 ) coral . Tlo = m_min - self . constants . k_var * s_min coral . Thi = m_max + self . constants . k_var * s_max def adapted_temp (): \"\"\"Adapted temperature response.\"\"\" def spec (): \"\"\"Specialisation term.\"\"\" return 4e-4 * np . exp ( - 0.33 * ( delta_temp - 10 )) response = - ( coral . temp - coral . Tlo ) * ( ( coral . temp - coral . Tlo ) ** 2 - delta_temp ** 2 ) temp_cr = coral . Tlo - ( 1 / np . sqrt ( 3 )) * delta_temp try : if self . constants . tme : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp [ coral . temp <= temp_cr ] ** 3 ) else : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 ) except TypeError : if coral . temp <= temp_cr : response = ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 return response * spec () def thermal_env (): \"\"\"Thermal envelope.\"\"\" return np . exp ( ( self . constants . Ea / self . constants . R ) * ( 1 / 300 - 1 / temp_opt ) ) # # parameter definitions thermal_acc () delta_temp = coral . Thi - coral . Tlo temp_opt = coral . Tlo + ( 1 / np . sqrt ( 3 )) * delta_temp # # calculations f1 = adapted_temp () f2 = thermal_env () self . ptd = f1 * f2 def flow_dependency ( self , coral : Coral ): \"\"\"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . pfd : pfd = self . constants . pfd_min + ( 1 - self . constants . pfd_min ) * np . tanh ( 2 * coral . ucm / self . constants . ucr ) self . pfd = RESHAPE () . variable2matrix ( pfd , \"space\" ) else : self . pfd = 1 __init__ ( light_in , first_year , constants : CoralConstants = CoralConstants ()) \u00b6 Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool Source code in src/biota_models/coral/bio_process/photosynthesis.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def __init__ ( self , light_in , first_year , constants : CoralConstants = CoralConstants () ): \"\"\" Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool \"\"\" self . I0 = RESHAPE () . variable2matrix ( light_in , \"time\" ) self . first_year = first_year self . pld = 1 self . ptd = 1 self . pfd = 1 self . constants = constants flow_dependency ( coral : Coral ) \u00b6 Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/photosynthesis.py 206 207 208 209 210 211 212 213 214 215 216 217 218 def flow_dependency ( self , coral : Coral ): \"\"\"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . pfd : pfd = self . constants . pfd_min + ( 1 - self . constants . pfd_min ) * np . tanh ( 2 * coral . ucm / self . constants . ucr ) self . pfd = RESHAPE () . variable2matrix ( pfd , \"space\" ) else : self . pfd = 1 light_dependency ( coral , output ) \u00b6 Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str Source code in src/biota_models/coral/bio_process/photosynthesis.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def light_dependency ( self , coral , output ): \"\"\"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str \"\"\" def photo_acclimation ( x_old , param ): \"\"\"Photo-acclimation.\"\"\" # input check params = ( \"Ik\" , \"Pmax\" ) if param not in params : message = f \" { param } not in { params } .\" raise ValueError ( message ) # parameter definitions x_max = self . constants . ik_max if param == \"Ik\" else self . constants . pm_max beta_x = self . constants . betaI if param == \"Ik\" else self . constants . betaP # calculations xs = x_max * ( coral . light / self . I0 ) ** beta_x if output == \"qss\" : return xs elif output == \"new\" : return xs + ( x_old - xs ) * np . exp ( - self . constants . iota ) # # parameter definitions if output == \"qss\" : ik = photo_acclimation ( None , \"Ik\" ) p_max = photo_acclimation ( None , \"Pmax\" ) else : msg = f \"Only the quasi-steady state solution is currently implemented; use key-word 'qss'.\" raise NotImplementedError ( msg ) # # calculations self . pld = p_max * ( np . tanh ( coral . light / ik ) - np . tanh ( self . constants . Icomp * self . I0 / ik ) ) photo_rate ( coral , environment , year ) \u00b6 Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int Source code in src/biota_models/coral/bio_process/photosynthesis.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def photo_rate ( self , coral , environment , year ): \"\"\"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int \"\"\" # components self . light_dependency ( coral , \"qss\" ) self . thermal_dependency ( coral , environment , year ) self . flow_dependency ( coral ) # combined coral . photo_rate = self . pld * self . ptd * self . pfd thermal_dependency ( coral : Coral , env , year ) \u00b6 Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int Source code in src/biota_models/coral/bio_process/photosynthesis.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def thermal_dependency ( self , coral : Coral , env , year ): \"\"\"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int \"\"\" _reshape = RESHAPE () def thermal_acc (): \"\"\"Thermal-acclimation.\"\"\" if self . constants . tme : if self . first_year : env . tmeMMMmin = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"min\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) env . tmeMMMmax = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"max\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) else : env . tmeMMMmin [ env . tmeMMM . index == year ] += coral . dTc env . tmeMMMmax [ env . tmeMMm . index == year ] += coral . dTc mmm_min = env . tmeMMMmin [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min = mmm_min . mean ( axis = 0 ) s_min = mmm_min . std ( axis = 0 ) mmm_max = env . tmeMMMmax [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_max = mmm_max . mean ( axis = 0 ) s_max = mmm_max . std ( axis = 0 ) else : mmm = env . temp_mmm [ np . logical_and ( env . temp_mmm . index < year , env . temp_mmm . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min , m_max = mmm . mean ( axis = 0 ) s_min , s_max = mmm . std ( axis = 0 ) coral . Tlo = m_min - self . constants . k_var * s_min coral . Thi = m_max + self . constants . k_var * s_max def adapted_temp (): \"\"\"Adapted temperature response.\"\"\" def spec (): \"\"\"Specialisation term.\"\"\" return 4e-4 * np . exp ( - 0.33 * ( delta_temp - 10 )) response = - ( coral . temp - coral . Tlo ) * ( ( coral . temp - coral . Tlo ) ** 2 - delta_temp ** 2 ) temp_cr = coral . Tlo - ( 1 / np . sqrt ( 3 )) * delta_temp try : if self . constants . tme : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp [ coral . temp <= temp_cr ] ** 3 ) else : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 ) except TypeError : if coral . temp <= temp_cr : response = ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 return response * spec () def thermal_env (): \"\"\"Thermal envelope.\"\"\" return np . exp ( ( self . constants . Ea / self . constants . R ) * ( 1 / 300 - 1 / temp_opt ) ) # # parameter definitions thermal_acc () delta_temp = coral . Thi - coral . Tlo temp_opt = coral . Tlo + ( 1 / np . sqrt ( 3 )) * delta_temp # # calculations f1 = adapted_temp () f2 = thermal_env () self . ptd = f1 * f2 Population states \u00b6 PopulationStates \u00b6 Bleaching response following the population dynamics. Source code in src/biota_models/coral/bio_process/population_states.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 class PopulationStates : \"\"\"Bleaching response following the population dynamics.\"\"\" # TODO: Check this class; incl. writing tests def __init__ ( self , constants : CoralConstants = CoralConstants (), dt : Optional [ float ] = 1 ): \"\"\"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional \"\"\" self . dt = dt self . constants = constants def pop_states_t ( self , coral : Coral ): \"\"\"Population dynamics over time. :param coral: coral animal :type coral: Coral \"\"\" _reshape = RESHAPE () coral . pop_states = np . zeros (( * _reshape . spacetime , 4 )) for n in range ( _reshape . time ): photosynthesis = np . zeros ( _reshape . space ) photosynthesis [ coral . cover > 0.0 ] = coral . photo_rate [ coral . cover > 0.0 , n ] # 21_09 have changed coral.cover>0 to .0. coral . pop_states [:, n , :] = self . pop_states_xy ( coral , photosynthesis ) coral . p0 [ coral . cover > 0.0 , :] = coral . pop_states [ coral . cover > 0.0 , n , :] def pop_states_xy ( self , coral : Coral , ps ): \"\"\"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray \"\"\" p = np . zeros (( RESHAPE () . space , 4 )) # # calculations # growing conditions # > bleached pop. # ps>0. here represents ps>tsh that is the value of the bleaching treshold light and 1. where 1.0 is a number, not column reference p [ ps > 0.0 , 3 ] = coral . p0 [ ps > 0.0 , 3 ] / ( 1 + self . dt * ( 8.0 * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp + self . constants . r_mortality * coral . Csp ) ) # > pale pop. p [ ps > 0.0 , 2 ] = ( coral . p0 [ ps > 0.0 , 2 ] + ( 8.0 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp ) * p [ ps > 0.0 , 3 ] ) / ( 1.0 + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > recovering pop. p [ ps > 0.0 , 1 ] = ( coral . p0 [ ps > 0.0 , 1 ] + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 2 ] ) / ( 1.0 + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > healthy pop. a = ( self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp / coral . cover [ ps > 0.0 ] ) b = 1.0 - self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp * ( 1.0 - p [ ps > 0.0 , 1 :] . sum ( axis = 1 ) / coral . cover [ ps > 0.0 ] ) c = - ( coral . p0 [ ps > 0.0 , 0 ] + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 1 ] ) p [ ps > 0.0 , 0 ] = ( - b + np . sqrt ( b ** 2 - 4.0 * a * c )) / ( 2.0 * a ) # bleaching conditions # > healthy pop. p [ ps <= 0.0 , 0 ] = coral . p0 [ ps <= 0.0 , 0 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > recovering pop. p [ ps <= 0.0 , 1 ] = coral . p0 [ ps <= 0.0 , 1 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > pale pop. p [ ps <= 0.0 , 2 ] = ( coral . p0 [ ps <= 0.0 , 2 ] - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp * ( p [ ps <= 0.0 , 0 ] + p [ ps <= 0.0 , 1 ]) ) / ( 1.0 - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > bleached pop. p [ ps <= 0.0 , 3 ] = ( coral . p0 [ ps <= 0.0 , 3 ] - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0 ] * coral . Csp * p [ ps <= 0.0 , 2 ] ) / ( 1.0 - 0.25 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # # check on carrying capacity if any ( p . sum ( axis = 1 ) > 1.0001 * coral . cover ): slot_1 = np . arange ( len ( coral . cover ))[ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_2 = p [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_3 = coral . cover [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] print ( f \"WARNING: Total population than carrying capacity at { slot_1 } . \" f \" \\n\\t PT = { slot_2 } ; K = { slot_3 } \" ) # # output return p __init__ ( constants : CoralConstants = CoralConstants (), dt : Optional [ float ] = 1 ) \u00b6 Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional Source code in src/biota_models/coral/bio_process/population_states.py 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , constants : CoralConstants = CoralConstants (), dt : Optional [ float ] = 1 ): \"\"\"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional \"\"\" self . dt = dt self . constants = constants pop_states_t ( coral : Coral ) \u00b6 Population dynamics over time. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/population_states.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def pop_states_t ( self , coral : Coral ): \"\"\"Population dynamics over time. :param coral: coral animal :type coral: Coral \"\"\" _reshape = RESHAPE () coral . pop_states = np . zeros (( * _reshape . spacetime , 4 )) for n in range ( _reshape . time ): photosynthesis = np . zeros ( _reshape . space ) photosynthesis [ coral . cover > 0.0 ] = coral . photo_rate [ coral . cover > 0.0 , n ] # 21_09 have changed coral.cover>0 to .0. coral . pop_states [:, n , :] = self . pop_states_xy ( coral , photosynthesis ) coral . p0 [ coral . cover > 0.0 , :] = coral . pop_states [ coral . cover > 0.0 , n , :] pop_states_xy ( coral : Coral , ps ) \u00b6 Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray Source code in src/biota_models/coral/bio_process/population_states.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def pop_states_xy ( self , coral : Coral , ps ): \"\"\"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray \"\"\" p = np . zeros (( RESHAPE () . space , 4 )) # # calculations # growing conditions # > bleached pop. # ps>0. here represents ps>tsh that is the value of the bleaching treshold light and 1. where 1.0 is a number, not column reference p [ ps > 0.0 , 3 ] = coral . p0 [ ps > 0.0 , 3 ] / ( 1 + self . dt * ( 8.0 * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp + self . constants . r_mortality * coral . Csp ) ) # > pale pop. p [ ps > 0.0 , 2 ] = ( coral . p0 [ ps > 0.0 , 2 ] + ( 8.0 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp ) * p [ ps > 0.0 , 3 ] ) / ( 1.0 + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > recovering pop. p [ ps > 0.0 , 1 ] = ( coral . p0 [ ps > 0.0 , 1 ] + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 2 ] ) / ( 1.0 + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > healthy pop. a = ( self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp / coral . cover [ ps > 0.0 ] ) b = 1.0 - self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp * ( 1.0 - p [ ps > 0.0 , 1 :] . sum ( axis = 1 ) / coral . cover [ ps > 0.0 ] ) c = - ( coral . p0 [ ps > 0.0 , 0 ] + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 1 ] ) p [ ps > 0.0 , 0 ] = ( - b + np . sqrt ( b ** 2 - 4.0 * a * c )) / ( 2.0 * a ) # bleaching conditions # > healthy pop. p [ ps <= 0.0 , 0 ] = coral . p0 [ ps <= 0.0 , 0 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > recovering pop. p [ ps <= 0.0 , 1 ] = coral . p0 [ ps <= 0.0 , 1 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > pale pop. p [ ps <= 0.0 , 2 ] = ( coral . p0 [ ps <= 0.0 , 2 ] - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp * ( p [ ps <= 0.0 , 0 ] + p [ ps <= 0.0 , 1 ]) ) / ( 1.0 - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > bleached pop. p [ ps <= 0.0 , 3 ] = ( coral . p0 [ ps <= 0.0 , 3 ] - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0 ] * coral . Csp * p [ ps <= 0.0 , 2 ] ) / ( 1.0 - 0.25 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # # check on carrying capacity if any ( p . sum ( axis = 1 ) > 1.0001 * coral . cover ): slot_1 = np . arange ( len ( coral . cover ))[ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_2 = p [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_3 = coral . cover [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] print ( f \"WARNING: Total population than carrying capacity at { slot_1 } . \" f \" \\n\\t PT = { slot_2 } ; K = { slot_3 } \" ) # # output return p Recruitment \u00b6 Recruitment \u00b6 Bases: ExtraModel Recruitment dynamics. Source code in src/biota_models/coral/bio_process/recruitment.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Recruitment ( ExtraModel ): \"\"\"Recruitment dynamics.\"\"\" constants : CoralConstants = CoralConstants () def update ( self , coral : Coral ): \"\"\"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral \"\"\" coral . p0 [:, 0 ] += Recruitment . spawning ( self , coral , \"P\" ) coral . update_coral_volume ( coral . volume + Recruitment . spawning ( self , coral , \"V\" )) def spawning ( self , coral : Coral , param ): \"\"\"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str \"\"\" # # input check params = ( \"P\" , \"V\" ) if param not in params : msg = f \" { param } not in { params } .\" raise ValueError ( msg ) # # calculations # potential power = 2 if param == \"P\" else 3 potential = ( self . constants . prob_settle * self . constants . no_larvae * self . constants . d_larvae ** power ) # recruitment averaged_healthy_pop = coral . pop_states [:, - 1 , 0 ] . mean () # living cover living_cover = RESHAPE () . matrix2array ( coral . living_cover , \"space\" ) recruited = CoralOnly () . in_space ( coral = coral , function = self . recruited , args = ( potential , averaged_healthy_pop , living_cover , coral . cover ), ) # # output return recruited @staticmethod def recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ): \"\"\"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float \"\"\" return potential * averaged_healthy_pop * ( 1 - cover_real / cover_potential ) recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ) staticmethod \u00b6 Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float Source code in src/biota_models/coral/bio_process/recruitment.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ): \"\"\"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float \"\"\" return potential * averaged_healthy_pop * ( 1 - cover_real / cover_potential ) spawning ( coral : Coral , param ) \u00b6 Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str Source code in src/biota_models/coral/bio_process/recruitment.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def spawning ( self , coral : Coral , param ): \"\"\"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str \"\"\" # # input check params = ( \"P\" , \"V\" ) if param not in params : msg = f \" { param } not in { params } .\" raise ValueError ( msg ) # # calculations # potential power = 2 if param == \"P\" else 3 potential = ( self . constants . prob_settle * self . constants . no_larvae * self . constants . d_larvae ** power ) # recruitment averaged_healthy_pop = coral . pop_states [:, - 1 , 0 ] . mean () # living cover living_cover = RESHAPE () . matrix2array ( coral . living_cover , \"space\" ) recruited = CoralOnly () . in_space ( coral = coral , function = self . recruited , args = ( potential , averaged_healthy_pop , living_cover , coral . cover ), ) # # output return recruited update ( coral : Coral ) \u00b6 Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/recruitment.py 13 14 15 16 17 18 19 20 def update ( self , coral : Coral ): \"\"\"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral \"\"\" coral . p0 [:, 0 ] += Recruitment . spawning ( self , coral , \"P\" ) coral . update_coral_volume ( coral . volume + Recruitment . spawning ( self , coral , \"V\" )) Temperature \u00b6 Temperature \u00b6 Source code in src/biota_models/coral/bio_process/temperature.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Temperature : def __init__ ( self , temperature , constants : CoralConstants = CoralConstants ()): \"\"\" Thermal micro-environment. Parameters ---------- temperature : numeric Temperature of water [K]. \"\"\" self . T = RESHAPE () . variable2matrix ( temperature , \"time\" ) self . constants = constants def coral_temperature ( self , coral : Coral ): \"\"\"Coral temperature. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . tme : delta_t = RESHAPE () . variable2matrix ( coral . delta_t , \"space\" ) coral . dTc = ( ( delta_t * self . constants . ap ) / ( self . constants . k * self . constants . K0 ) * coral . light ) coral . temp = self . T + coral . dTc else : coral . temp = self . T __init__ ( temperature , constants : CoralConstants = CoralConstants ()) \u00b6 Thermal micro-environment. Parameters \u00b6 numeric Temperature of water [K]. Source code in src/biota_models/coral/bio_process/temperature.py 7 8 9 10 11 12 13 14 15 16 17 def __init__ ( self , temperature , constants : CoralConstants = CoralConstants ()): \"\"\" Thermal micro-environment. Parameters ---------- temperature : numeric Temperature of water [K]. \"\"\" self . T = RESHAPE () . variable2matrix ( temperature , \"time\" ) self . constants = constants coral_temperature ( coral : Coral ) \u00b6 Coral temperature. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/temperature.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def coral_temperature ( self , coral : Coral ): \"\"\"Coral temperature. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . tme : delta_t = RESHAPE () . variable2matrix ( coral . delta_t , \"space\" ) coral . dTc = ( ( delta_t * self . constants . ap ) / ( self . constants . k * self . constants . K0 ) * coral . light ) coral . temp = self . T + coral . dTc else : coral . temp = self . T","title":"Coral processes"},{"location":"reference/biota_models/coral/coral_processes/#biophysical-processes","text":"","title":"Biophysical processes"},{"location":"reference/biota_models/coral/coral_processes/#calcification","text":"","title":"Calcification"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.calcification.Calcification","text":"Calcification rate. Source code in src/biota_models/coral/bio_process/calcification.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Calcification : \"\"\"Calcification rate.\"\"\" def __init__ ( self , constants : CoralConstants = CoralConstants ()): \"\"\"Calcification rate.\"\"\" self . ad = 1 self . constants = constants def calcification_rate ( self , coral , omega ): \"\"\"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray \"\"\" def aragonite_dependency ( calcification_object ): \"\"\"Aragonite dependency.\"\"\" calcification_object . ad = ( omega - self . constants . omega0 ) / ( self . constants . kappaA + omega - self . constants . omega0 ) calcification_object . ad = RESHAPE () . variable2matrix ( calcification_object . ad , \"time\" ) aragonite_dependency ( self ) coral . calc = ( self . constants . gC * coral . Csp * coral . pop_states [:, :, 0 ] * self . ad * coral . photo_rate )","title":"Calcification"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.calcification.Calcification.__init__","text":"Calcification rate. Source code in src/biota_models/coral/bio_process/calcification.py 8 9 10 11 def __init__ ( self , constants : CoralConstants = CoralConstants ()): \"\"\"Calcification rate.\"\"\" self . ad = 1 self . constants = constants","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.calcification.Calcification.calcification_rate","text":"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray Source code in src/biota_models/coral/bio_process/calcification.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def calcification_rate ( self , coral , omega ): \"\"\"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray \"\"\" def aragonite_dependency ( calcification_object ): \"\"\"Aragonite dependency.\"\"\" calcification_object . ad = ( omega - self . constants . omega0 ) / ( self . constants . kappaA + omega - self . constants . omega0 ) calcification_object . ad = RESHAPE () . variable2matrix ( calcification_object . ad , \"time\" ) aragonite_dependency ( self ) coral . calc = ( self . constants . gC * coral . Csp * coral . pop_states [:, :, 0 ] * self . ad * coral . photo_rate )","title":"calcification_rate()"},{"location":"reference/biota_models/coral/coral_processes/#dislodgement","text":"","title":"Dislodgement"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement","text":"Bases: ExtraModel Dislodgement due to storm conditions. Source code in src/biota_models/coral/bio_process/dislodgment.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class Dislodgement ( ExtraModel ): \"\"\"Dislodgement due to storm conditions.\"\"\" constants : CoralConstants = CoralConstants () dmt : Optional [ np . ndarray ] = None csf : Optional [ np . ndarray ] = None survival : Optional [ np . ndarray ] = None def update ( self , coral : Coral , survival_coefficient = 1 ): \"\"\"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # # partial dislodgement Dislodgement . partial_dislodgement ( self , coral , survival_coefficient ) # # update # population states for s in range ( 4 ): coral . p0 [:, s ] *= self . survival # morphology coral . update_coral_volume ( coral . volume * self . survival ) def partial_dislodgement ( self , coral , survival_coefficient = 1.0 ): \"\"\"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # TODO: Rewrite such that the distinction between an array or a float is well build in. try : self . survival = np . ones ( coral . dc . shape ) except TypeError : if Dislodgement . dislodgement_criterion ( self , coral ): self . survival = survival_coefficient * self . dmt / self . csf else : self . survival = 1.0 else : dislodged = Dislodgement . dislodgement_criterion ( self , coral ) self . survival [ dislodged ] = survival_coefficient * ( self . dmt [ dislodged ] / self . csf [ dislodged ] ) def dislodgement_criterion ( self , coral : Coral ): \"\"\"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral \"\"\" self . dislodgement_mechanical_threshold ( coral ) self . colony_shape_factor ( coral ) return self . dmt <= self . csf def dislodgement_mechanical_threshold ( self , coral : Coral ): \"\"\" Dislodgement Mechanical Threshold. Args: coral (Coral): Coral animal. \"\"\" # # check input if not hasattr ( coral . um , \"__iter__\" ): coral . um = np . array ([ coral . um ]) if isinstance ( coral . um , ( list , tuple )): coral . um = np . array ( coral . um ) # # calculations self . dmt = 1e20 * np . ones ( coral . um . shape ) self . dmt [ coral . um > 0 ] = self . dmt_formula ( self . constants , coral . um [ coral . um > 0 ] ) @staticmethod def dmt_formula ( constants , flow_velocity ): \"\"\"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray \"\"\" return constants . sigma_t / ( constants . rho_w * constants . Cd * flow_velocity ** 2 ) def colony_shape_factor ( self , coral : Coral ): \"\"\" Colony Shape Factor. Args: coral (Coral): Coral animal. \"\"\" self . csf = CoralOnly () . in_space ( coral = coral , function = self . csf_formula , args = ( coral . dc , coral . hc , coral . bc , coral . tc ), ) @staticmethod def csf_formula ( dc , hc , bc , tc ): \"\"\"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray \"\"\" # arms of moment arm_top = hc - 0.5 * tc arm_bottom = 0.5 * ( hc - tc ) # area of moment area_top = dc * tc area_bottom = bc * ( hc - tc ) # integral integral = arm_top * area_top + arm_bottom * area_bottom # colony shape factor return 16.0 / ( np . pi * bc ** 3 ) * integral","title":"Dislodgement"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.colony_shape_factor","text":"Colony Shape Factor. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/biota_models/coral/bio_process/dislodgment.py 98 99 100 101 102 103 104 105 106 107 108 109 def colony_shape_factor ( self , coral : Coral ): \"\"\" Colony Shape Factor. Args: coral (Coral): Coral animal. \"\"\" self . csf = CoralOnly () . in_space ( coral = coral , function = self . csf_formula , args = ( coral . dc , coral . hc , coral . bc , coral . tc ), )","title":"colony_shape_factor()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.csf_formula","text":"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/dislodgment.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @staticmethod def csf_formula ( dc , hc , bc , tc ): \"\"\"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray \"\"\" # arms of moment arm_top = hc - 0.5 * tc arm_bottom = 0.5 * ( hc - tc ) # area of moment area_top = dc * tc area_bottom = bc * ( hc - tc ) # integral integral = arm_top * area_top + arm_bottom * area_bottom # colony shape factor return 16.0 / ( np . pi * bc ** 3 ) * integral","title":"csf_formula()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.dislodgement_criterion","text":"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/dislodgment.py 60 61 62 63 64 65 66 67 68 def dislodgement_criterion ( self , coral : Coral ): \"\"\"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral \"\"\" self . dislodgement_mechanical_threshold ( coral ) self . colony_shape_factor ( coral ) return self . dmt <= self . csf","title":"dislodgement_criterion()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.dislodgement_mechanical_threshold","text":"Dislodgement Mechanical Threshold. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/biota_models/coral/bio_process/dislodgment.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def dislodgement_mechanical_threshold ( self , coral : Coral ): \"\"\" Dislodgement Mechanical Threshold. Args: coral (Coral): Coral animal. \"\"\" # # check input if not hasattr ( coral . um , \"__iter__\" ): coral . um = np . array ([ coral . um ]) if isinstance ( coral . um , ( list , tuple )): coral . um = np . array ( coral . um ) # # calculations self . dmt = 1e20 * np . ones ( coral . um . shape ) self . dmt [ coral . um > 0 ] = self . dmt_formula ( self . constants , coral . um [ coral . um > 0 ] )","title":"dislodgement_mechanical_threshold()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.dmt_formula","text":"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/dislodgment.py 89 90 91 92 93 94 95 96 @staticmethod def dmt_formula ( constants , flow_velocity ): \"\"\"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray \"\"\" return constants . sigma_t / ( constants . rho_w * constants . Cd * flow_velocity ** 2 )","title":"dmt_formula()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.partial_dislodgement","text":"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/biota_models/coral/bio_process/dislodgment.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def partial_dislodgement ( self , coral , survival_coefficient = 1.0 ): \"\"\"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # TODO: Rewrite such that the distinction between an array or a float is well build in. try : self . survival = np . ones ( coral . dc . shape ) except TypeError : if Dislodgement . dislodgement_criterion ( self , coral ): self . survival = survival_coefficient * self . dmt / self . csf else : self . survival = 1.0 else : dislodged = Dislodgement . dislodgement_criterion ( self , coral ) self . survival [ dislodged ] = survival_coefficient * ( self . dmt [ dislodged ] / self . csf [ dislodged ] )","title":"partial_dislodgement()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.dislodgment.Dislodgement.update","text":"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/biota_models/coral/bio_process/dislodgment.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def update ( self , coral : Coral , survival_coefficient = 1 ): \"\"\"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # # partial dislodgement Dislodgement . partial_dislodgement ( self , coral , survival_coefficient ) # # update # population states for s in range ( 4 ): coral . p0 [:, s ] *= self . survival # morphology coral . update_coral_volume ( coral . volume * self . survival )","title":"update()"},{"location":"reference/biota_models/coral/coral_processes/#flow","text":"","title":"Flow"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow","text":"Flow micro-environment. Source code in src/biota_models/coral/bio_process/flow.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 class Flow : \"\"\"Flow micro-environment.\"\"\" def __init__ ( self , u_current , u_wave , h , peak_period , constants : CoralConstants = CoralConstants (), ): \"\"\" :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray \"\"\" _reshape = RESHAPE () self . uc = _reshape . variable2array ( u_current ) self . uw = _reshape . variable2array ( u_wave ) self . h = _reshape . variable2matrix ( h , \"space\" ) self . Tp = _reshape . variable2array ( peak_period ) self . active = False if u_current is None and u_wave is None else True self . constants = constants @property def uc_matrix ( self ): \"\"\"Reshaped current flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uc , \"space\" ) @property def uw_matrix ( self ): \"\"\"Reshaped wave flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uw , \"space\" ) def velocities ( self , coral , in_canopy = True ): \"\"\"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional \"\"\" if self . active : alpha_w = np . ones ( self . uw . shape ) alpha_c = np . ones ( self . uc . shape ) if in_canopy : idx = coral . volume > 0 for i in idx : alpha_w [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uw [ i ], self . Tp [ i ], self . h [ i ], wac_type = \"wave\" , ) alpha_c [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uc [ i ], 1e3 , self . h [ i ], wac_type = \"current\" , ) coral . ucm = self . wave_current ( alpha_w , alpha_c ) coral . um = self . wave_current () else : coral . ucm = 9999 * np . ones ( RESHAPE () . space ) def wave_current ( self , alpha_w = 1 , alpha_c = 1 ): \"\"\"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray \"\"\" return np . sqrt ( ( alpha_w * self . uw ) ** 2 + ( alpha_c * self . uc ) ** 2 + 2 * alpha_w * self . uw * alpha_c * self . uc * np . cos ( self . constants . wcAngle ) ) @staticmethod def wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ): \"\"\"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str \"\"\" # TODO: Split this method in one solely focusing on the wave attenuation coefficient; # and one implementing this method to dynamically determine the drag coefficient. # Thus, reformat this method as in coral_model_v0. # # function and derivative definitions def function ( beta ): \"\"\"Complex-valued function to be solved, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * shear_length ) * ( abs ( 1.0 - beta ) * ( 1.0 - beta )) ) drag = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * drag_length ) * ( abs ( beta ) * beta ) ) inertia = ( 1 j * beta * (( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar )) ) # combined f = 1 j * ( beta - 1.0 ) - shear + drag + inertia # output return f def derivative ( beta ): \"\"\"Complex-valued derivative to be used to solve the complex-valued function, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 1.0 - beta ) ** 2 / abs ( 1.0 - beta ) - abs ( 1.0 - beta ) ) / shear_length drag = ( beta ** 2 / abs ( beta ) + beta ) / drag_length inertia = 1 j * ( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar ) # combined df = 1 j + ( 8.0 * above_motion ) / ( 3.0 * np . pi ) * ( - shear + drag ) + inertia # output return df # # Input check def wave_wac (): return abs ( newton ( function , x0 = complex ( 0.1 , 0.1 ), fprime = derivative , maxiter = constants . maxiter_aw , ) ) def current_wac (): x = drag_length / shear_length * ( height / ( depth - height ) + 1 ) return ( x - np . sqrt ( x )) / ( x - 1 ) wac_type_funcs = dict ( current = current_wac , wave = wave_wac ) wac_function = wac_type_funcs . get ( wac_type , None ) if wac_function is None : raise ValueError ( f \"WAC-type ( { wac_type } ) not in { wac_type_funcs . keys () } .\" ) # # parameter definitions # geometric parameters planar_area = 0.25 * np . pi * diameter ** 2 frontal_area = diameter * height total_area = 0.5 * distance ** 2 lambda_planar = planar_area / total_area lambda_frontal = frontal_area / total_area shear_length = height / ( constants . Cs ** 2 ) # # calculations wac = 1.0 if depth <= height : return wac # If depth > height # initial iteration values above_flow = velocity drag_coefficient = 1.0 # iteration for k in range ( int ( constants . maxiter_k )): drag_length = ( 2 * height * ( 1 - lambda_planar )) / ( drag_coefficient * lambda_frontal ) above_motion = ( above_flow * period ) / ( 2 * np . pi ) wac = wac_function () porous_flow = wac * above_flow constricted_flow = ( ( 1 - lambda_planar ) / ( 1 - np . sqrt (( 4 * lambda_planar ) / ( constants . psi * np . pi ))) * porous_flow ) reynolds = ( constricted_flow * diameter ) / constants . nu new_drag = 1 + 10 * reynolds ** ( - 2.0 / 3 ) if abs (( new_drag - drag_coefficient ) / new_drag ) <= constants . err : break else : drag_coefficient = float ( new_drag ) above_flow = abs ( ( 1 - constants . numericTheta ) * above_flow + constants . numericTheta * ( depth * velocity - height * porous_flow ) / ( depth - height ) ) if k == constants . maxiter_k : print ( f \"WARNING: maximum number of iterations reached \" f \"( { constants . maxiter_k } )\" ) return wac def thermal_boundary_layer ( self , coral ): \"\"\"Thermal boundary layer. :param coral: coral animal :type coral: Coral \"\"\" if self . active and self . constants . tme : delta = self . velocity_boundary_layer ( self . constants , coral ) coral . delta_t = delta * ( ( self . constants . alpha / self . constants . nu ) ** ( 1 / 3 ) ) @staticmethod def velocity_boundary_layer ( constants , coral ): \"\"\"Velocity boundary layer. :param coral: coral animal :type coral: Coral \"\"\" def boundary_layer ( rd , nu , cf , ucm ): \"\"\"Thickness velocity boundary layer.\"\"\" return ( rd * nu ) / ( np . sqrt ( cf ) * ucm ) return CoralOnly () . in_space ( coral = coral , function = boundary_layer , args = ( constants . rd , constants . nu , constants . Cf , coral . ucm ), )","title":"Flow"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.__init__","text":":param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray Source code in src/biota_models/coral/bio_process/flow.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , u_current , u_wave , h , peak_period , constants : CoralConstants = CoralConstants (), ): \"\"\" :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray \"\"\" _reshape = RESHAPE () self . uc = _reshape . variable2array ( u_current ) self . uw = _reshape . variable2array ( u_wave ) self . h = _reshape . variable2matrix ( h , \"space\" ) self . Tp = _reshape . variable2array ( peak_period ) self . active = False if u_current is None and u_wave is None else True self . constants = constants","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.thermal_boundary_layer","text":"Thermal boundary layer. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/flow.py 241 242 243 244 245 246 247 248 249 250 251 def thermal_boundary_layer ( self , coral ): \"\"\"Thermal boundary layer. :param coral: coral animal :type coral: Coral \"\"\" if self . active and self . constants . tme : delta = self . velocity_boundary_layer ( self . constants , coral ) coral . delta_t = delta * ( ( self . constants . alpha / self . constants . nu ) ** ( 1 / 3 ) )","title":"thermal_boundary_layer()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.uc_matrix","text":"Reshaped current flow velocity. Source code in src/biota_models/coral/bio_process/flow.py 39 40 41 42 @property def uc_matrix ( self ): \"\"\"Reshaped current flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uc , \"space\" )","title":"uc_matrix()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.uw_matrix","text":"Reshaped wave flow velocity. Source code in src/biota_models/coral/bio_process/flow.py 44 45 46 47 @property def uw_matrix ( self ): \"\"\"Reshaped wave flow velocity.\"\"\" return RESHAPE () . variable2matrix ( self . uw , \"space\" )","title":"uw_matrix()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.velocities","text":"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional Source code in src/biota_models/coral/bio_process/flow.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def velocities ( self , coral , in_canopy = True ): \"\"\"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional \"\"\" if self . active : alpha_w = np . ones ( self . uw . shape ) alpha_c = np . ones ( self . uc . shape ) if in_canopy : idx = coral . volume > 0 for i in idx : alpha_w [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uw [ i ], self . Tp [ i ], self . h [ i ], wac_type = \"wave\" , ) alpha_c [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uc [ i ], 1e3 , self . h [ i ], wac_type = \"current\" , ) coral . ucm = self . wave_current ( alpha_w , alpha_c ) coral . um = self . wave_current () else : coral . ucm = 9999 * np . ones ( RESHAPE () . space )","title":"velocities()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.velocity_boundary_layer","text":"Velocity boundary layer. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/flow.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def velocity_boundary_layer ( constants , coral ): \"\"\"Velocity boundary layer. :param coral: coral animal :type coral: Coral \"\"\" def boundary_layer ( rd , nu , cf , ucm ): \"\"\"Thickness velocity boundary layer.\"\"\" return ( rd * nu ) / ( np . sqrt ( cf ) * ucm ) return CoralOnly () . in_space ( coral = coral , function = boundary_layer , args = ( constants . rd , constants . nu , constants . Cf , coral . ucm ), )","title":"velocity_boundary_layer()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.wave_attenuation","text":"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str Source code in src/biota_models/coral/bio_process/flow.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @staticmethod def wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ): \"\"\"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str \"\"\" # TODO: Split this method in one solely focusing on the wave attenuation coefficient; # and one implementing this method to dynamically determine the drag coefficient. # Thus, reformat this method as in coral_model_v0. # # function and derivative definitions def function ( beta ): \"\"\"Complex-valued function to be solved, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * shear_length ) * ( abs ( 1.0 - beta ) * ( 1.0 - beta )) ) drag = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * drag_length ) * ( abs ( beta ) * beta ) ) inertia = ( 1 j * beta * (( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar )) ) # combined f = 1 j * ( beta - 1.0 ) - shear + drag + inertia # output return f def derivative ( beta ): \"\"\"Complex-valued derivative to be used to solve the complex-valued function, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 1.0 - beta ) ** 2 / abs ( 1.0 - beta ) - abs ( 1.0 - beta ) ) / shear_length drag = ( beta ** 2 / abs ( beta ) + beta ) / drag_length inertia = 1 j * ( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar ) # combined df = 1 j + ( 8.0 * above_motion ) / ( 3.0 * np . pi ) * ( - shear + drag ) + inertia # output return df # # Input check def wave_wac (): return abs ( newton ( function , x0 = complex ( 0.1 , 0.1 ), fprime = derivative , maxiter = constants . maxiter_aw , ) ) def current_wac (): x = drag_length / shear_length * ( height / ( depth - height ) + 1 ) return ( x - np . sqrt ( x )) / ( x - 1 ) wac_type_funcs = dict ( current = current_wac , wave = wave_wac ) wac_function = wac_type_funcs . get ( wac_type , None ) if wac_function is None : raise ValueError ( f \"WAC-type ( { wac_type } ) not in { wac_type_funcs . keys () } .\" ) # # parameter definitions # geometric parameters planar_area = 0.25 * np . pi * diameter ** 2 frontal_area = diameter * height total_area = 0.5 * distance ** 2 lambda_planar = planar_area / total_area lambda_frontal = frontal_area / total_area shear_length = height / ( constants . Cs ** 2 ) # # calculations wac = 1.0 if depth <= height : return wac # If depth > height # initial iteration values above_flow = velocity drag_coefficient = 1.0 # iteration for k in range ( int ( constants . maxiter_k )): drag_length = ( 2 * height * ( 1 - lambda_planar )) / ( drag_coefficient * lambda_frontal ) above_motion = ( above_flow * period ) / ( 2 * np . pi ) wac = wac_function () porous_flow = wac * above_flow constricted_flow = ( ( 1 - lambda_planar ) / ( 1 - np . sqrt (( 4 * lambda_planar ) / ( constants . psi * np . pi ))) * porous_flow ) reynolds = ( constricted_flow * diameter ) / constants . nu new_drag = 1 + 10 * reynolds ** ( - 2.0 / 3 ) if abs (( new_drag - drag_coefficient ) / new_drag ) <= constants . err : break else : drag_coefficient = float ( new_drag ) above_flow = abs ( ( 1 - constants . numericTheta ) * above_flow + constants . numericTheta * ( depth * velocity - height * porous_flow ) / ( depth - height ) ) if k == constants . maxiter_k : print ( f \"WARNING: maximum number of iterations reached \" f \"( { constants . maxiter_k } )\" ) return wac","title":"wave_attenuation()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.flow.Flow.wave_current","text":"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/flow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def wave_current ( self , alpha_w = 1 , alpha_c = 1 ): \"\"\"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray \"\"\" return np . sqrt ( ( alpha_w * self . uw ) ** 2 + ( alpha_c * self . uc ) ** 2 + 2 * alpha_w * self . uw * alpha_c * self . uc * np . cos ( self . constants . wcAngle ) )","title":"wave_current()"},{"location":"reference/biota_models/coral/coral_processes/#light","text":"","title":"Light"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light","text":"Light micro-environment. Source code in src/biota_models/coral/bio_process/light.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class Light : \"\"\"Light micro-environment.\"\"\" def __init__ ( self , light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : CoralConstants = CoralConstants (), ): \"\"\" Light micro-environment. Args: light_in (LightVariable): Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] lac (LightVariable): light-attenuation coefficient [m-1] depth (LightVariable): water depth [m] constants (Constants): List of constants to be used for this object. \"\"\" _reshape = RESHAPE () self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . Kd = _reshape . variable2matrix ( lac , \"time\" ) self . h = _reshape . variable2matrix ( depth , \"space\" ) self . constants = constants def rep_light ( self , coral ): \"\"\"Representative light-intensity. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) # # light catchment per coral section # top of plate top = ( 0.25 * np . pi * coral . dc_matrix ** 2 * self . I0 * np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) ) # side of plate side = ( ( np . pi * coral . dc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) - np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix )) ) * self . side_correction ( coral ) ) # side of base base = ( ( np . pi * coral . bc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - base_section )) - np . exp ( - self . Kd * self . h )) * self . side_correction ( coral ) ) # total total = top + side + base # # biomass-averaged self . biomass ( coral ) def averaged_light ( total_light , biomass ): \"\"\"Averaged light-intensity.\"\"\" return total_light / biomass coral . light = CoralOnly () . in_spacetime ( coral = coral , function = averaged_light , args = ( total , coral . light_bc ), no_cover_value = self . I0 * np . exp ( - self . Kd * self . h ), ) def biomass ( self , coral ): \"\"\"Coral biomass; as surface. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) coral . light_bc = np . pi * ( 0.25 * coral . dc_matrix ** 2 + coral . dc_matrix * coral . tc_matrix + coral . bc_matrix * base_section ) def base_light ( self , coral ): \"\"\"Section of coral base receiving light. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # coral base section base_section = ( coral . hc_matrix - coral . tc_matrix - (( coral . dc_matrix - coral . bc_matrix ) / ( 2.0 * np . tan ( 0.5 * theta ))) ) # no negative lengths base_section [ base_section < 0 ] = 0 return base_section def light_spreading ( self , coral ): \"\"\"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral \"\"\" return self . constants . theta_max * np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix ) ) def side_correction ( self , coral ): \"\"\"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # correction factor return np . sin ( 0.5 * theta )","title":"Light"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light.__init__","text":"Light micro-environment. Parameters: Name Type Description Default light_in LightVariable Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] required lac LightVariable light-attenuation coefficient [m-1] required depth LightVariable water depth [m] required constants Constants List of constants to be used for this object. CoralConstants() Source code in src/biota_models/coral/bio_process/light.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : CoralConstants = CoralConstants (), ): \"\"\" Light micro-environment. Args: light_in (LightVariable): Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] lac (LightVariable): light-attenuation coefficient [m-1] depth (LightVariable): water depth [m] constants (Constants): List of constants to be used for this object. \"\"\" _reshape = RESHAPE () self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . Kd = _reshape . variable2matrix ( lac , \"time\" ) self . h = _reshape . variable2matrix ( depth , \"space\" ) self . constants = constants","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light.base_light","text":"Section of coral base receiving light. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def base_light ( self , coral ): \"\"\"Section of coral base receiving light. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # coral base section base_section = ( coral . hc_matrix - coral . tc_matrix - (( coral . dc_matrix - coral . bc_matrix ) / ( 2.0 * np . tan ( 0.5 * theta ))) ) # no negative lengths base_section [ base_section < 0 ] = 0 return base_section","title":"base_light()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light.biomass","text":"Coral biomass; as surface. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 88 89 90 91 92 93 94 95 96 97 98 99 def biomass ( self , coral ): \"\"\"Coral biomass; as surface. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) coral . light_bc = np . pi * ( 0.25 * coral . dc_matrix ** 2 + coral . dc_matrix * coral . tc_matrix + coral . bc_matrix * base_section )","title":"biomass()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light.light_spreading","text":"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 121 122 123 124 125 126 127 128 129 def light_spreading ( self , coral ): \"\"\"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral \"\"\" return self . constants . theta_max * np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix ) )","title":"light_spreading()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light.rep_light","text":"Representative light-intensity. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def rep_light ( self , coral ): \"\"\"Representative light-intensity. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) # # light catchment per coral section # top of plate top = ( 0.25 * np . pi * coral . dc_matrix ** 2 * self . I0 * np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) ) # side of plate side = ( ( np . pi * coral . dc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) - np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix )) ) * self . side_correction ( coral ) ) # side of base base = ( ( np . pi * coral . bc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - base_section )) - np . exp ( - self . Kd * self . h )) * self . side_correction ( coral ) ) # total total = top + side + base # # biomass-averaged self . biomass ( coral ) def averaged_light ( total_light , biomass ): \"\"\"Averaged light-intensity.\"\"\" return total_light / biomass coral . light = CoralOnly () . in_spacetime ( coral = coral , function = averaged_light , args = ( total , coral . light_bc ), no_cover_value = self . I0 * np . exp ( - self . Kd * self . h ), )","title":"rep_light()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.light.Light.side_correction","text":"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/light.py 131 132 133 134 135 136 137 138 139 140 141 def side_correction ( self , coral ): \"\"\"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # correction factor return np . sin ( 0.5 * theta )","title":"side_correction()"},{"location":"reference/biota_models/coral/coral_processes/#morphology","text":"","title":"Morphology"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology","text":"Morphological development. Source code in src/biota_models/coral/bio_process/morphology.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class Morphology : \"\"\"Morphological development.\"\"\" __rf_optimal = None __rp_optimal = None __rs_optimal = None def __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : CoralConstants = CoralConstants (), ): \"\"\" Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int \"\"\" _reshape = RESHAPE () try : _ = len ( calc_sum [ 0 ]) except TypeError : self . calc_sum = calc_sum else : self . calc_sum = _reshape . matrix2array ( calc_sum , \"space\" , \"sum\" ) self . dt_year = dt_year self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . vol_increase = 0 self . constants = constants @staticmethod def __coral_object_checker ( coral ): \"\"\"Check the suitability of the coral-object for the morphological development. :param coral: coral animal :type coral: Coral \"\"\" # coral must be of type Coral if not isinstance ( coral , Coral ): msg = f \"The optimal ratios are set using the Coral-object, { type ( coral ) } is given.\" raise TypeError ( msg ) # coral must have light and flow condition attributes if not hasattr ( coral , \"light\" ) and not hasattr ( coral , \"ucm\" ): msg = ( f \"The optimal ratios are determined based on the coral's light and flow conditions; \" f \"none are provided.\" ) raise AttributeError ( msg ) @property def rf_optimal ( self ): \"\"\"Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rf_optimal @rf_optimal . setter def rf_optimal ( self , coral ): \"\"\" :param coral: coral animal :type coral: Coral \"\"\" self . __coral_object_checker ( coral ) rf = self . constants . rf # rf = ( # self.constants.prop_form # * (coral.light.mean(axis=1) / self.I0.mean(axis=1)) # * (self.constants.u0 / 1e-6) # ) # rf[coral.ucm > 0] = ( # self.constants.prop_form # * ( # coral.light.mean(axis=1)[coral.ucm > 0] # / self.I0.mean(axis=1)[coral.ucm > 0] # ) # * (self.constants.u0 / coral.ucm[coral.ucm > 0]) # ) self . __rf_optimal = rf @property def rp_optimal ( self ): \"\"\"Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rp_optimal @rp_optimal . setter def rp_optimal ( self , coral ): \"\"\" :param coral: coral animal :type coral: Coral \"\"\" self . __coral_object_checker ( coral ) self . __rp_optimal = self . constants . rp # self.__rp_optimal = self.constants.prop_plate * ( # 1.0 # + np.tanh( # self.constants.prop_plate_flow # * (coral.ucm - self.constants.u0) # / self.constants.u0 # ) # ) @property def rs_optimal ( self ): \"\"\"Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray \"\"\" return self . __rs_optimal @rs_optimal . setter def rs_optimal ( self , coral ): \"\"\" :param coral: coral animal :type coral: Coral \"\"\" self . __coral_object_checker ( coral ) # self.__rs_optimal = 0.5 / np.sqrt(2.0) * 0.25 self . __rs_optimal = ( self . constants . prop_space * ( 1.0 - np . tanh ( self . constants . prop_space_light * coral . light . mean ( axis = 1 ) / self . I0 . mean ( axis = 1 ) ) ) * ( 1.0 + np . tanh ( self . constants . prop_space_flow * ( coral . ucm - self . constants . u0 ) / self . constants . u0 ) ) ) def delta_volume ( self , coral ): \"\"\" :param coral: coral object :type coral: Coral \"\"\" self . vol_increase = ( 0.5 * coral . ac ** 2 * self . calc_sum * self . dt_year / self . constants . rho_c * coral . light_bc . mean ( axis = 1 ) ) return self . vol_increase def ratio_update ( self , coral , ratio ): \"\"\" :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str \"\"\" # partial differential equation - mass balance def mass_balance ( r_old , r_opt ): \"\"\"Mass balance.\"\"\" return ( coral . volume * r_old + self . vol_increase * r_opt ) / ( coral . volume + self . vol_increase ) # input check ratios = ( \"rf\" , \"rp\" , \"rs\" ) if ratio not in ratios : msg = f \" { ratio } not in { ratios } .\" raise ValueError ( msg ) # calculations self . delta_volume ( coral ) # optimal ratio setattr ( self , f \" { ratio } _optimal\" , coral ) # update morphological ratio if hasattr ( self , f \" { ratio } _optimal\" ) and hasattr ( coral , ratio ): return mass_balance ( getattr ( coral , ratio ), getattr ( self , f \" { ratio } _optimal\" ) ) def update ( self , coral : Coral ): \"\"\"Update morphology. :param coral: coral animal :type coral: Coral \"\"\" # # calculations # updated ratios ratios = { ratio : self . ratio_update ( coral , ratio ) for ratio in ( \"rf\" , \"rp\" , \"rs\" ) } # updated volume volume = coral . volume + self . vol_increase # update coral morphology coral . update_coral_morphology ( volume , ratios )","title":"Morphology"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.__coral_object_checker","text":"Check the suitability of the coral-object for the morphological development. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/morphology.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @staticmethod def __coral_object_checker ( coral ): \"\"\"Check the suitability of the coral-object for the morphological development. :param coral: coral animal :type coral: Coral \"\"\" # coral must be of type Coral if not isinstance ( coral , Coral ): msg = f \"The optimal ratios are set using the Coral-object, { type ( coral ) } is given.\" raise TypeError ( msg ) # coral must have light and flow condition attributes if not hasattr ( coral , \"light\" ) and not hasattr ( coral , \"ucm\" ): msg = ( f \"The optimal ratios are determined based on the coral's light and flow conditions; \" f \"none are provided.\" ) raise AttributeError ( msg )","title":"__coral_object_checker()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.__init__","text":"Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int Source code in src/biota_models/coral/bio_process/morphology.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : CoralConstants = CoralConstants (), ): \"\"\" Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int \"\"\" _reshape = RESHAPE () try : _ = len ( calc_sum [ 0 ]) except TypeError : self . calc_sum = calc_sum else : self . calc_sum = _reshape . matrix2array ( calc_sum , \"space\" , \"sum\" ) self . dt_year = dt_year self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . vol_increase = 0 self . constants = constants","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.delta_volume","text":":param coral: coral object :type coral: Coral Source code in src/biota_models/coral/bio_process/morphology.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def delta_volume ( self , coral ): \"\"\" :param coral: coral object :type coral: Coral \"\"\" self . vol_increase = ( 0.5 * coral . ac ** 2 * self . calc_sum * self . dt_year / self . constants . rho_c * coral . light_bc . mean ( axis = 1 ) ) return self . vol_increase","title":"delta_volume()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.ratio_update","text":":param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str Source code in src/biota_models/coral/bio_process/morphology.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def ratio_update ( self , coral , ratio ): \"\"\" :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str \"\"\" # partial differential equation - mass balance def mass_balance ( r_old , r_opt ): \"\"\"Mass balance.\"\"\" return ( coral . volume * r_old + self . vol_increase * r_opt ) / ( coral . volume + self . vol_increase ) # input check ratios = ( \"rf\" , \"rp\" , \"rs\" ) if ratio not in ratios : msg = f \" { ratio } not in { ratios } .\" raise ValueError ( msg ) # calculations self . delta_volume ( coral ) # optimal ratio setattr ( self , f \" { ratio } _optimal\" , coral ) # update morphological ratio if hasattr ( self , f \" { ratio } _optimal\" ) and hasattr ( coral , ratio ): return mass_balance ( getattr ( coral , ratio ), getattr ( self , f \" { ratio } _optimal\" ) )","title":"ratio_update()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.rf_optimal","text":"Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/morphology.py 67 68 69 70 71 72 73 @property def rf_optimal ( self ): \"\"\"Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rf_optimal","title":"rf_optimal()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.rp_optimal","text":"Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/morphology.py 100 101 102 103 104 105 106 @property def rp_optimal ( self ): \"\"\"Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray \"\"\" return self . __rp_optimal","title":"rp_optimal()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.rs_optimal","text":"Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray Source code in src/biota_models/coral/bio_process/morphology.py 126 127 128 129 130 131 132 @property def rs_optimal ( self ): \"\"\"Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray \"\"\" return self . __rs_optimal","title":"rs_optimal()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.morphology.Morphology.update","text":"Update morphology. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/morphology.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def update ( self , coral : Coral ): \"\"\"Update morphology. :param coral: coral animal :type coral: Coral \"\"\" # # calculations # updated ratios ratios = { ratio : self . ratio_update ( coral , ratio ) for ratio in ( \"rf\" , \"rp\" , \"rs\" ) } # updated volume volume = coral . volume + self . vol_increase # update coral morphology coral . update_coral_morphology ( volume , ratios )","title":"update()"},{"location":"reference/biota_models/coral/coral_processes/#photosynthesis","text":"","title":"Photosynthesis"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.photosynthesis.Photosynthesis","text":"Photosynthesis. Source code in src/biota_models/coral/bio_process/photosynthesis.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class Photosynthesis : \"\"\"Photosynthesis.\"\"\" def __init__ ( self , light_in , first_year , constants : CoralConstants = CoralConstants () ): \"\"\" Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool \"\"\" self . I0 = RESHAPE () . variable2matrix ( light_in , \"time\" ) self . first_year = first_year self . pld = 1 self . ptd = 1 self . pfd = 1 self . constants = constants def photo_rate ( self , coral , environment , year ): \"\"\"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int \"\"\" # components self . light_dependency ( coral , \"qss\" ) self . thermal_dependency ( coral , environment , year ) self . flow_dependency ( coral ) # combined coral . photo_rate = self . pld * self . ptd * self . pfd def light_dependency ( self , coral , output ): \"\"\"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str \"\"\" def photo_acclimation ( x_old , param ): \"\"\"Photo-acclimation.\"\"\" # input check params = ( \"Ik\" , \"Pmax\" ) if param not in params : message = f \" { param } not in { params } .\" raise ValueError ( message ) # parameter definitions x_max = self . constants . ik_max if param == \"Ik\" else self . constants . pm_max beta_x = self . constants . betaI if param == \"Ik\" else self . constants . betaP # calculations xs = x_max * ( coral . light / self . I0 ) ** beta_x if output == \"qss\" : return xs elif output == \"new\" : return xs + ( x_old - xs ) * np . exp ( - self . constants . iota ) # # parameter definitions if output == \"qss\" : ik = photo_acclimation ( None , \"Ik\" ) p_max = photo_acclimation ( None , \"Pmax\" ) else : msg = f \"Only the quasi-steady state solution is currently implemented; use key-word 'qss'.\" raise NotImplementedError ( msg ) # # calculations self . pld = p_max * ( np . tanh ( coral . light / ik ) - np . tanh ( self . constants . Icomp * self . I0 / ik ) ) def thermal_dependency ( self , coral : Coral , env , year ): \"\"\"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int \"\"\" _reshape = RESHAPE () def thermal_acc (): \"\"\"Thermal-acclimation.\"\"\" if self . constants . tme : if self . first_year : env . tmeMMMmin = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"min\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) env . tmeMMMmax = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"max\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) else : env . tmeMMMmin [ env . tmeMMM . index == year ] += coral . dTc env . tmeMMMmax [ env . tmeMMm . index == year ] += coral . dTc mmm_min = env . tmeMMMmin [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min = mmm_min . mean ( axis = 0 ) s_min = mmm_min . std ( axis = 0 ) mmm_max = env . tmeMMMmax [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_max = mmm_max . mean ( axis = 0 ) s_max = mmm_max . std ( axis = 0 ) else : mmm = env . temp_mmm [ np . logical_and ( env . temp_mmm . index < year , env . temp_mmm . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min , m_max = mmm . mean ( axis = 0 ) s_min , s_max = mmm . std ( axis = 0 ) coral . Tlo = m_min - self . constants . k_var * s_min coral . Thi = m_max + self . constants . k_var * s_max def adapted_temp (): \"\"\"Adapted temperature response.\"\"\" def spec (): \"\"\"Specialisation term.\"\"\" return 4e-4 * np . exp ( - 0.33 * ( delta_temp - 10 )) response = - ( coral . temp - coral . Tlo ) * ( ( coral . temp - coral . Tlo ) ** 2 - delta_temp ** 2 ) temp_cr = coral . Tlo - ( 1 / np . sqrt ( 3 )) * delta_temp try : if self . constants . tme : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp [ coral . temp <= temp_cr ] ** 3 ) else : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 ) except TypeError : if coral . temp <= temp_cr : response = ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 return response * spec () def thermal_env (): \"\"\"Thermal envelope.\"\"\" return np . exp ( ( self . constants . Ea / self . constants . R ) * ( 1 / 300 - 1 / temp_opt ) ) # # parameter definitions thermal_acc () delta_temp = coral . Thi - coral . Tlo temp_opt = coral . Tlo + ( 1 / np . sqrt ( 3 )) * delta_temp # # calculations f1 = adapted_temp () f2 = thermal_env () self . ptd = f1 * f2 def flow_dependency ( self , coral : Coral ): \"\"\"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . pfd : pfd = self . constants . pfd_min + ( 1 - self . constants . pfd_min ) * np . tanh ( 2 * coral . ucm / self . constants . ucr ) self . pfd = RESHAPE () . variable2matrix ( pfd , \"space\" ) else : self . pfd = 1","title":"Photosynthesis"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.photosynthesis.Photosynthesis.__init__","text":"Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool Source code in src/biota_models/coral/bio_process/photosynthesis.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def __init__ ( self , light_in , first_year , constants : CoralConstants = CoralConstants () ): \"\"\" Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool \"\"\" self . I0 = RESHAPE () . variable2matrix ( light_in , \"time\" ) self . first_year = first_year self . pld = 1 self . ptd = 1 self . pfd = 1 self . constants = constants","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.photosynthesis.Photosynthesis.flow_dependency","text":"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/photosynthesis.py 206 207 208 209 210 211 212 213 214 215 216 217 218 def flow_dependency ( self , coral : Coral ): \"\"\"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . pfd : pfd = self . constants . pfd_min + ( 1 - self . constants . pfd_min ) * np . tanh ( 2 * coral . ucm / self . constants . ucr ) self . pfd = RESHAPE () . variable2matrix ( pfd , \"space\" ) else : self . pfd = 1","title":"flow_dependency()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.photosynthesis.Photosynthesis.light_dependency","text":"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str Source code in src/biota_models/coral/bio_process/photosynthesis.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def light_dependency ( self , coral , output ): \"\"\"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str \"\"\" def photo_acclimation ( x_old , param ): \"\"\"Photo-acclimation.\"\"\" # input check params = ( \"Ik\" , \"Pmax\" ) if param not in params : message = f \" { param } not in { params } .\" raise ValueError ( message ) # parameter definitions x_max = self . constants . ik_max if param == \"Ik\" else self . constants . pm_max beta_x = self . constants . betaI if param == \"Ik\" else self . constants . betaP # calculations xs = x_max * ( coral . light / self . I0 ) ** beta_x if output == \"qss\" : return xs elif output == \"new\" : return xs + ( x_old - xs ) * np . exp ( - self . constants . iota ) # # parameter definitions if output == \"qss\" : ik = photo_acclimation ( None , \"Ik\" ) p_max = photo_acclimation ( None , \"Pmax\" ) else : msg = f \"Only the quasi-steady state solution is currently implemented; use key-word 'qss'.\" raise NotImplementedError ( msg ) # # calculations self . pld = p_max * ( np . tanh ( coral . light / ik ) - np . tanh ( self . constants . Icomp * self . I0 / ik ) )","title":"light_dependency()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.photosynthesis.Photosynthesis.photo_rate","text":"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int Source code in src/biota_models/coral/bio_process/photosynthesis.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def photo_rate ( self , coral , environment , year ): \"\"\"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int \"\"\" # components self . light_dependency ( coral , \"qss\" ) self . thermal_dependency ( coral , environment , year ) self . flow_dependency ( coral ) # combined coral . photo_rate = self . pld * self . ptd * self . pfd","title":"photo_rate()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.photosynthesis.Photosynthesis.thermal_dependency","text":"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int Source code in src/biota_models/coral/bio_process/photosynthesis.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def thermal_dependency ( self , coral : Coral , env , year ): \"\"\"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int \"\"\" _reshape = RESHAPE () def thermal_acc (): \"\"\"Thermal-acclimation.\"\"\" if self . constants . tme : if self . first_year : env . tmeMMMmin = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"min\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) env . tmeMMMmax = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"max\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) else : env . tmeMMMmin [ env . tmeMMM . index == year ] += coral . dTc env . tmeMMMmax [ env . tmeMMm . index == year ] += coral . dTc mmm_min = env . tmeMMMmin [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min = mmm_min . mean ( axis = 0 ) s_min = mmm_min . std ( axis = 0 ) mmm_max = env . tmeMMMmax [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_max = mmm_max . mean ( axis = 0 ) s_max = mmm_max . std ( axis = 0 ) else : mmm = env . temp_mmm [ np . logical_and ( env . temp_mmm . index < year , env . temp_mmm . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min , m_max = mmm . mean ( axis = 0 ) s_min , s_max = mmm . std ( axis = 0 ) coral . Tlo = m_min - self . constants . k_var * s_min coral . Thi = m_max + self . constants . k_var * s_max def adapted_temp (): \"\"\"Adapted temperature response.\"\"\" def spec (): \"\"\"Specialisation term.\"\"\" return 4e-4 * np . exp ( - 0.33 * ( delta_temp - 10 )) response = - ( coral . temp - coral . Tlo ) * ( ( coral . temp - coral . Tlo ) ** 2 - delta_temp ** 2 ) temp_cr = coral . Tlo - ( 1 / np . sqrt ( 3 )) * delta_temp try : if self . constants . tme : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp [ coral . temp <= temp_cr ] ** 3 ) else : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 ) except TypeError : if coral . temp <= temp_cr : response = ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 return response * spec () def thermal_env (): \"\"\"Thermal envelope.\"\"\" return np . exp ( ( self . constants . Ea / self . constants . R ) * ( 1 / 300 - 1 / temp_opt ) ) # # parameter definitions thermal_acc () delta_temp = coral . Thi - coral . Tlo temp_opt = coral . Tlo + ( 1 / np . sqrt ( 3 )) * delta_temp # # calculations f1 = adapted_temp () f2 = thermal_env () self . ptd = f1 * f2","title":"thermal_dependency()"},{"location":"reference/biota_models/coral/coral_processes/#population-states","text":"","title":"Population states"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.population_states.PopulationStates","text":"Bleaching response following the population dynamics. Source code in src/biota_models/coral/bio_process/population_states.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 class PopulationStates : \"\"\"Bleaching response following the population dynamics.\"\"\" # TODO: Check this class; incl. writing tests def __init__ ( self , constants : CoralConstants = CoralConstants (), dt : Optional [ float ] = 1 ): \"\"\"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional \"\"\" self . dt = dt self . constants = constants def pop_states_t ( self , coral : Coral ): \"\"\"Population dynamics over time. :param coral: coral animal :type coral: Coral \"\"\" _reshape = RESHAPE () coral . pop_states = np . zeros (( * _reshape . spacetime , 4 )) for n in range ( _reshape . time ): photosynthesis = np . zeros ( _reshape . space ) photosynthesis [ coral . cover > 0.0 ] = coral . photo_rate [ coral . cover > 0.0 , n ] # 21_09 have changed coral.cover>0 to .0. coral . pop_states [:, n , :] = self . pop_states_xy ( coral , photosynthesis ) coral . p0 [ coral . cover > 0.0 , :] = coral . pop_states [ coral . cover > 0.0 , n , :] def pop_states_xy ( self , coral : Coral , ps ): \"\"\"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray \"\"\" p = np . zeros (( RESHAPE () . space , 4 )) # # calculations # growing conditions # > bleached pop. # ps>0. here represents ps>tsh that is the value of the bleaching treshold light and 1. where 1.0 is a number, not column reference p [ ps > 0.0 , 3 ] = coral . p0 [ ps > 0.0 , 3 ] / ( 1 + self . dt * ( 8.0 * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp + self . constants . r_mortality * coral . Csp ) ) # > pale pop. p [ ps > 0.0 , 2 ] = ( coral . p0 [ ps > 0.0 , 2 ] + ( 8.0 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp ) * p [ ps > 0.0 , 3 ] ) / ( 1.0 + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > recovering pop. p [ ps > 0.0 , 1 ] = ( coral . p0 [ ps > 0.0 , 1 ] + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 2 ] ) / ( 1.0 + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > healthy pop. a = ( self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp / coral . cover [ ps > 0.0 ] ) b = 1.0 - self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp * ( 1.0 - p [ ps > 0.0 , 1 :] . sum ( axis = 1 ) / coral . cover [ ps > 0.0 ] ) c = - ( coral . p0 [ ps > 0.0 , 0 ] + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 1 ] ) p [ ps > 0.0 , 0 ] = ( - b + np . sqrt ( b ** 2 - 4.0 * a * c )) / ( 2.0 * a ) # bleaching conditions # > healthy pop. p [ ps <= 0.0 , 0 ] = coral . p0 [ ps <= 0.0 , 0 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > recovering pop. p [ ps <= 0.0 , 1 ] = coral . p0 [ ps <= 0.0 , 1 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > pale pop. p [ ps <= 0.0 , 2 ] = ( coral . p0 [ ps <= 0.0 , 2 ] - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp * ( p [ ps <= 0.0 , 0 ] + p [ ps <= 0.0 , 1 ]) ) / ( 1.0 - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > bleached pop. p [ ps <= 0.0 , 3 ] = ( coral . p0 [ ps <= 0.0 , 3 ] - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0 ] * coral . Csp * p [ ps <= 0.0 , 2 ] ) / ( 1.0 - 0.25 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # # check on carrying capacity if any ( p . sum ( axis = 1 ) > 1.0001 * coral . cover ): slot_1 = np . arange ( len ( coral . cover ))[ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_2 = p [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_3 = coral . cover [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] print ( f \"WARNING: Total population than carrying capacity at { slot_1 } . \" f \" \\n\\t PT = { slot_2 } ; K = { slot_3 } \" ) # # output return p","title":"PopulationStates"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.population_states.PopulationStates.__init__","text":"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional Source code in src/biota_models/coral/bio_process/population_states.py 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , constants : CoralConstants = CoralConstants (), dt : Optional [ float ] = 1 ): \"\"\"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional \"\"\" self . dt = dt self . constants = constants","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.population_states.PopulationStates.pop_states_t","text":"Population dynamics over time. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/population_states.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def pop_states_t ( self , coral : Coral ): \"\"\"Population dynamics over time. :param coral: coral animal :type coral: Coral \"\"\" _reshape = RESHAPE () coral . pop_states = np . zeros (( * _reshape . spacetime , 4 )) for n in range ( _reshape . time ): photosynthesis = np . zeros ( _reshape . space ) photosynthesis [ coral . cover > 0.0 ] = coral . photo_rate [ coral . cover > 0.0 , n ] # 21_09 have changed coral.cover>0 to .0. coral . pop_states [:, n , :] = self . pop_states_xy ( coral , photosynthesis ) coral . p0 [ coral . cover > 0.0 , :] = coral . pop_states [ coral . cover > 0.0 , n , :]","title":"pop_states_t()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.population_states.PopulationStates.pop_states_xy","text":"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray Source code in src/biota_models/coral/bio_process/population_states.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def pop_states_xy ( self , coral : Coral , ps ): \"\"\"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray \"\"\" p = np . zeros (( RESHAPE () . space , 4 )) # # calculations # growing conditions # > bleached pop. # ps>0. here represents ps>tsh that is the value of the bleaching treshold light and 1. where 1.0 is a number, not column reference p [ ps > 0.0 , 3 ] = coral . p0 [ ps > 0.0 , 3 ] / ( 1 + self . dt * ( 8.0 * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp + self . constants . r_mortality * coral . Csp ) ) # > pale pop. p [ ps > 0.0 , 2 ] = ( coral . p0 [ ps > 0.0 , 2 ] + ( 8.0 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp ) * p [ ps > 0.0 , 3 ] ) / ( 1.0 + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > recovering pop. p [ ps > 0.0 , 1 ] = ( coral . p0 [ ps > 0.0 , 1 ] + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 2 ] ) / ( 1.0 + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > healthy pop. a = ( self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp / coral . cover [ ps > 0.0 ] ) b = 1.0 - self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp * ( 1.0 - p [ ps > 0.0 , 1 :] . sum ( axis = 1 ) / coral . cover [ ps > 0.0 ] ) c = - ( coral . p0 [ ps > 0.0 , 0 ] + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 1 ] ) p [ ps > 0.0 , 0 ] = ( - b + np . sqrt ( b ** 2 - 4.0 * a * c )) / ( 2.0 * a ) # bleaching conditions # > healthy pop. p [ ps <= 0.0 , 0 ] = coral . p0 [ ps <= 0.0 , 0 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > recovering pop. p [ ps <= 0.0 , 1 ] = coral . p0 [ ps <= 0.0 , 1 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > pale pop. p [ ps <= 0.0 , 2 ] = ( coral . p0 [ ps <= 0.0 , 2 ] - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp * ( p [ ps <= 0.0 , 0 ] + p [ ps <= 0.0 , 1 ]) ) / ( 1.0 - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > bleached pop. p [ ps <= 0.0 , 3 ] = ( coral . p0 [ ps <= 0.0 , 3 ] - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0 ] * coral . Csp * p [ ps <= 0.0 , 2 ] ) / ( 1.0 - 0.25 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # # check on carrying capacity if any ( p . sum ( axis = 1 ) > 1.0001 * coral . cover ): slot_1 = np . arange ( len ( coral . cover ))[ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_2 = p [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_3 = coral . cover [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] print ( f \"WARNING: Total population than carrying capacity at { slot_1 } . \" f \" \\n\\t PT = { slot_2 } ; K = { slot_3 } \" ) # # output return p","title":"pop_states_xy()"},{"location":"reference/biota_models/coral/coral_processes/#recruitment","text":"","title":"Recruitment"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.recruitment.Recruitment","text":"Bases: ExtraModel Recruitment dynamics. Source code in src/biota_models/coral/bio_process/recruitment.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Recruitment ( ExtraModel ): \"\"\"Recruitment dynamics.\"\"\" constants : CoralConstants = CoralConstants () def update ( self , coral : Coral ): \"\"\"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral \"\"\" coral . p0 [:, 0 ] += Recruitment . spawning ( self , coral , \"P\" ) coral . update_coral_volume ( coral . volume + Recruitment . spawning ( self , coral , \"V\" )) def spawning ( self , coral : Coral , param ): \"\"\"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str \"\"\" # # input check params = ( \"P\" , \"V\" ) if param not in params : msg = f \" { param } not in { params } .\" raise ValueError ( msg ) # # calculations # potential power = 2 if param == \"P\" else 3 potential = ( self . constants . prob_settle * self . constants . no_larvae * self . constants . d_larvae ** power ) # recruitment averaged_healthy_pop = coral . pop_states [:, - 1 , 0 ] . mean () # living cover living_cover = RESHAPE () . matrix2array ( coral . living_cover , \"space\" ) recruited = CoralOnly () . in_space ( coral = coral , function = self . recruited , args = ( potential , averaged_healthy_pop , living_cover , coral . cover ), ) # # output return recruited @staticmethod def recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ): \"\"\"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float \"\"\" return potential * averaged_healthy_pop * ( 1 - cover_real / cover_potential )","title":"Recruitment"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.recruitment.Recruitment.recruited","text":"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float Source code in src/biota_models/coral/bio_process/recruitment.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ): \"\"\"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float \"\"\" return potential * averaged_healthy_pop * ( 1 - cover_real / cover_potential )","title":"recruited()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.recruitment.Recruitment.spawning","text":"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str Source code in src/biota_models/coral/bio_process/recruitment.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def spawning ( self , coral : Coral , param ): \"\"\"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str \"\"\" # # input check params = ( \"P\" , \"V\" ) if param not in params : msg = f \" { param } not in { params } .\" raise ValueError ( msg ) # # calculations # potential power = 2 if param == \"P\" else 3 potential = ( self . constants . prob_settle * self . constants . no_larvae * self . constants . d_larvae ** power ) # recruitment averaged_healthy_pop = coral . pop_states [:, - 1 , 0 ] . mean () # living cover living_cover = RESHAPE () . matrix2array ( coral . living_cover , \"space\" ) recruited = CoralOnly () . in_space ( coral = coral , function = self . recruited , args = ( potential , averaged_healthy_pop , living_cover , coral . cover ), ) # # output return recruited","title":"spawning()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.recruitment.Recruitment.update","text":"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/recruitment.py 13 14 15 16 17 18 19 20 def update ( self , coral : Coral ): \"\"\"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral \"\"\" coral . p0 [:, 0 ] += Recruitment . spawning ( self , coral , \"P\" ) coral . update_coral_volume ( coral . volume + Recruitment . spawning ( self , coral , \"V\" ))","title":"update()"},{"location":"reference/biota_models/coral/coral_processes/#temperature","text":"","title":"Temperature"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.temperature.Temperature","text":"Source code in src/biota_models/coral/bio_process/temperature.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Temperature : def __init__ ( self , temperature , constants : CoralConstants = CoralConstants ()): \"\"\" Thermal micro-environment. Parameters ---------- temperature : numeric Temperature of water [K]. \"\"\" self . T = RESHAPE () . variable2matrix ( temperature , \"time\" ) self . constants = constants def coral_temperature ( self , coral : Coral ): \"\"\"Coral temperature. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . tme : delta_t = RESHAPE () . variable2matrix ( coral . delta_t , \"space\" ) coral . dTc = ( ( delta_t * self . constants . ap ) / ( self . constants . k * self . constants . K0 ) * coral . light ) coral . temp = self . T + coral . dTc else : coral . temp = self . T","title":"Temperature"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.temperature.Temperature.__init__","text":"Thermal micro-environment.","title":"__init__()"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.temperature.Temperature.__init__--parameters","text":"numeric Temperature of water [K]. Source code in src/biota_models/coral/bio_process/temperature.py 7 8 9 10 11 12 13 14 15 16 17 def __init__ ( self , temperature , constants : CoralConstants = CoralConstants ()): \"\"\" Thermal micro-environment. Parameters ---------- temperature : numeric Temperature of water [K]. \"\"\" self . T = RESHAPE () . variable2matrix ( temperature , \"time\" ) self . constants = constants","title":"Parameters"},{"location":"reference/biota_models/coral/coral_processes/#src.biota_models.coral.bio_process.temperature.Temperature.coral_temperature","text":"Coral temperature. :param coral: coral animal :type coral: Coral Source code in src/biota_models/coral/bio_process/temperature.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def coral_temperature ( self , coral : Coral ): \"\"\"Coral temperature. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . tme : delta_t = RESHAPE () . variable2matrix ( coral . delta_t , \"space\" ) coral . dTc = ( ( delta_t * self . constants . ap ) / ( self . constants . k * self . constants . K0 ) * coral . light ) coral . temp = self . T + coral . dTc else : coral . temp = self . T","title":"coral_temperature()"},{"location":"reference/biota_models/coral/coral_simulation/","text":"Classes representing the available Coral simulation modes. \u00b6 Base Coral Simulation \u00b6 Coral Delft3D (FlowFM / DIMR) \u00b6 CoralDimrSimulation \u00b6 Bases: _CoralDelft3DSimulation Coral Dimr Simulation representation. Implements the specific logic needed to run a Coral Simulation with a DIMR kernel through BMIWrapper Source code in src/biota_models/coral/simulation/coral_delft3d_simulation.py 70 71 72 73 74 75 76 77 class CoralDimrSimulation ( _CoralDelft3DSimulation ): \"\"\" Coral Dimr Simulation representation. Implements the specific logic needed to run a Coral Simulation with a DIMR kernel through `BMIWrapper` \"\"\" mode = \"DimrModel\" CoralFlowFmSimulation \u00b6 Bases: _CoralDelft3DSimulation Coral FlowFM Simulation representation. Implements the specific logic needed to run a Coral Simulation with a FlowFM kernel through BMIWrapper Source code in src/biota_models/coral/simulation/coral_delft3d_simulation.py 80 81 82 83 84 85 86 87 class CoralFlowFmSimulation ( _CoralDelft3DSimulation ): \"\"\" Coral FlowFM Simulation representation. Implements the specific logic needed to run a Coral Simulation with a FlowFM kernel through `BMIWrapper` \"\"\" mode = \"FlowFMModel\" Coral Transect \u00b6 CoralTransectSimulation \u00b6 Bases: _CoralSimulation Implements the SimulationProtocol Coral Transect Simulation. Contains the specific logic and parameters required for the case. Source code in src/biota_models/coral/simulation/coral_transect_simulation.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class CoralTransectSimulation ( _CoralSimulation ): \"\"\" Implements the `SimulationProtocol` Coral Transect Simulation. Contains the specific logic and parameters required for the case. \"\"\" mode = \"Transect\" def configure_output ( self ): \"\"\" Sets the Coral `Transect` specific values to the `OutputWrapper`. Should be run after `configure_hydrodynamics`. \"\"\" # Initialize the OutputWrapper first_date = self . environment . get_dates ()[ 0 ] xy_coordinates = self . hydrodynamics . xy_coordinates outpoint = self . hydrodynamics . outpoint def get_output_wrapper_dict () -> dict : return dict ( first_date = first_date , xy_coordinates = xy_coordinates , outpoint = outpoint , output_dir = self . working_dir / \"output\" , ) def get_map_output_dict ( output_dict : dict ) -> dict : return dict ( output_dir = output_dict [ \"output_dir\" ], first_year = output_dict [ \"first_date\" ] . year , xy_coordinates = output_dict [ \"xy_coordinates\" ], ) def get_his_output_dict ( output_dict : dict ) -> dict : xy_stations , idx_stations = CoralOutputWrapper . get_xy_stations ( output_dict [ \"xy_coordinates\" ], output_dict [ \"outpoint\" ] ) return dict ( output_dir = output_dict [ \"output_dir\" ], first_date = output_dict [ \"first_date\" ], xy_stations = xy_stations , idx_stations = idx_stations , ) extended_output = get_output_wrapper_dict () map_dict = get_map_output_dict ( extended_output ) his_dict = get_his_output_dict ( extended_output ) if self . output is None : extended_output [ \"map_output\" ] = map_dict extended_output [ \"his_output\" ] = his_dict self . output = CoralOutputWrapper ( ** extended_output ) return def update_output ( out_model , new_values : dict ): if out_model is None : return None output_dict : dict = out_model . dict () for k , v in new_values . items (): if output_dict . get ( k , None ) is None : setattr ( out_model , k , v ) update_output ( self . output , extended_output ) update_output ( self . output . map_output , map_dict ) update_output ( self . output . his_output , his_dict ) configure_output () \u00b6 Sets the Coral Transect specific values to the OutputWrapper . Should be run after configure_hydrodynamics . Source code in src/biota_models/coral/simulation/coral_transect_simulation.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def configure_output ( self ): \"\"\" Sets the Coral `Transect` specific values to the `OutputWrapper`. Should be run after `configure_hydrodynamics`. \"\"\" # Initialize the OutputWrapper first_date = self . environment . get_dates ()[ 0 ] xy_coordinates = self . hydrodynamics . xy_coordinates outpoint = self . hydrodynamics . outpoint def get_output_wrapper_dict () -> dict : return dict ( first_date = first_date , xy_coordinates = xy_coordinates , outpoint = outpoint , output_dir = self . working_dir / \"output\" , ) def get_map_output_dict ( output_dict : dict ) -> dict : return dict ( output_dir = output_dict [ \"output_dir\" ], first_year = output_dict [ \"first_date\" ] . year , xy_coordinates = output_dict [ \"xy_coordinates\" ], ) def get_his_output_dict ( output_dict : dict ) -> dict : xy_stations , idx_stations = CoralOutputWrapper . get_xy_stations ( output_dict [ \"xy_coordinates\" ], output_dict [ \"outpoint\" ] ) return dict ( output_dir = output_dict [ \"output_dir\" ], first_date = output_dict [ \"first_date\" ], xy_stations = xy_stations , idx_stations = idx_stations , ) extended_output = get_output_wrapper_dict () map_dict = get_map_output_dict ( extended_output ) his_dict = get_his_output_dict ( extended_output ) if self . output is None : extended_output [ \"map_output\" ] = map_dict extended_output [ \"his_output\" ] = his_dict self . output = CoralOutputWrapper ( ** extended_output ) return def update_output ( out_model , new_values : dict ): if out_model is None : return None output_dict : dict = out_model . dict () for k , v in new_values . items (): if output_dict . get ( k , None ) is None : setattr ( out_model , k , v ) update_output ( self . output , extended_output ) update_output ( self . output . map_output , map_dict ) update_output ( self . output . his_output , his_dict )","title":"Coral simulation"},{"location":"reference/biota_models/coral/coral_simulation/#classes-representing-the-available-coral-simulation-modes","text":"","title":"Classes representing the available Coral simulation modes."},{"location":"reference/biota_models/coral/coral_simulation/#base-coral-simulation","text":"","title":"Base Coral Simulation"},{"location":"reference/biota_models/coral/coral_simulation/#coral-delft3d-flowfm-dimr","text":"","title":"Coral Delft3D (FlowFM / DIMR)"},{"location":"reference/biota_models/coral/coral_simulation/#src.biota_models.coral.simulation.coral_delft3d_simulation.CoralDimrSimulation","text":"Bases: _CoralDelft3DSimulation Coral Dimr Simulation representation. Implements the specific logic needed to run a Coral Simulation with a DIMR kernel through BMIWrapper Source code in src/biota_models/coral/simulation/coral_delft3d_simulation.py 70 71 72 73 74 75 76 77 class CoralDimrSimulation ( _CoralDelft3DSimulation ): \"\"\" Coral Dimr Simulation representation. Implements the specific logic needed to run a Coral Simulation with a DIMR kernel through `BMIWrapper` \"\"\" mode = \"DimrModel\"","title":"CoralDimrSimulation"},{"location":"reference/biota_models/coral/coral_simulation/#src.biota_models.coral.simulation.coral_delft3d_simulation.CoralFlowFmSimulation","text":"Bases: _CoralDelft3DSimulation Coral FlowFM Simulation representation. Implements the specific logic needed to run a Coral Simulation with a FlowFM kernel through BMIWrapper Source code in src/biota_models/coral/simulation/coral_delft3d_simulation.py 80 81 82 83 84 85 86 87 class CoralFlowFmSimulation ( _CoralDelft3DSimulation ): \"\"\" Coral FlowFM Simulation representation. Implements the specific logic needed to run a Coral Simulation with a FlowFM kernel through `BMIWrapper` \"\"\" mode = \"FlowFMModel\"","title":"CoralFlowFmSimulation"},{"location":"reference/biota_models/coral/coral_simulation/#coral-transect","text":"","title":"Coral Transect"},{"location":"reference/biota_models/coral/coral_simulation/#src.biota_models.coral.simulation.coral_transect_simulation.CoralTransectSimulation","text":"Bases: _CoralSimulation Implements the SimulationProtocol Coral Transect Simulation. Contains the specific logic and parameters required for the case. Source code in src/biota_models/coral/simulation/coral_transect_simulation.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class CoralTransectSimulation ( _CoralSimulation ): \"\"\" Implements the `SimulationProtocol` Coral Transect Simulation. Contains the specific logic and parameters required for the case. \"\"\" mode = \"Transect\" def configure_output ( self ): \"\"\" Sets the Coral `Transect` specific values to the `OutputWrapper`. Should be run after `configure_hydrodynamics`. \"\"\" # Initialize the OutputWrapper first_date = self . environment . get_dates ()[ 0 ] xy_coordinates = self . hydrodynamics . xy_coordinates outpoint = self . hydrodynamics . outpoint def get_output_wrapper_dict () -> dict : return dict ( first_date = first_date , xy_coordinates = xy_coordinates , outpoint = outpoint , output_dir = self . working_dir / \"output\" , ) def get_map_output_dict ( output_dict : dict ) -> dict : return dict ( output_dir = output_dict [ \"output_dir\" ], first_year = output_dict [ \"first_date\" ] . year , xy_coordinates = output_dict [ \"xy_coordinates\" ], ) def get_his_output_dict ( output_dict : dict ) -> dict : xy_stations , idx_stations = CoralOutputWrapper . get_xy_stations ( output_dict [ \"xy_coordinates\" ], output_dict [ \"outpoint\" ] ) return dict ( output_dir = output_dict [ \"output_dir\" ], first_date = output_dict [ \"first_date\" ], xy_stations = xy_stations , idx_stations = idx_stations , ) extended_output = get_output_wrapper_dict () map_dict = get_map_output_dict ( extended_output ) his_dict = get_his_output_dict ( extended_output ) if self . output is None : extended_output [ \"map_output\" ] = map_dict extended_output [ \"his_output\" ] = his_dict self . output = CoralOutputWrapper ( ** extended_output ) return def update_output ( out_model , new_values : dict ): if out_model is None : return None output_dict : dict = out_model . dict () for k , v in new_values . items (): if output_dict . get ( k , None ) is None : setattr ( out_model , k , v ) update_output ( self . output , extended_output ) update_output ( self . output . map_output , map_dict ) update_output ( self . output . his_output , his_dict )","title":"CoralTransectSimulation"},{"location":"reference/biota_models/coral/coral_simulation/#src.biota_models.coral.simulation.coral_transect_simulation.CoralTransectSimulation.configure_output","text":"Sets the Coral Transect specific values to the OutputWrapper . Should be run after configure_hydrodynamics . Source code in src/biota_models/coral/simulation/coral_transect_simulation.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def configure_output ( self ): \"\"\" Sets the Coral `Transect` specific values to the `OutputWrapper`. Should be run after `configure_hydrodynamics`. \"\"\" # Initialize the OutputWrapper first_date = self . environment . get_dates ()[ 0 ] xy_coordinates = self . hydrodynamics . xy_coordinates outpoint = self . hydrodynamics . outpoint def get_output_wrapper_dict () -> dict : return dict ( first_date = first_date , xy_coordinates = xy_coordinates , outpoint = outpoint , output_dir = self . working_dir / \"output\" , ) def get_map_output_dict ( output_dict : dict ) -> dict : return dict ( output_dir = output_dict [ \"output_dir\" ], first_year = output_dict [ \"first_date\" ] . year , xy_coordinates = output_dict [ \"xy_coordinates\" ], ) def get_his_output_dict ( output_dict : dict ) -> dict : xy_stations , idx_stations = CoralOutputWrapper . get_xy_stations ( output_dict [ \"xy_coordinates\" ], output_dict [ \"outpoint\" ] ) return dict ( output_dir = output_dict [ \"output_dir\" ], first_date = output_dict [ \"first_date\" ], xy_stations = xy_stations , idx_stations = idx_stations , ) extended_output = get_output_wrapper_dict () map_dict = get_map_output_dict ( extended_output ) his_dict = get_his_output_dict ( extended_output ) if self . output is None : extended_output [ \"map_output\" ] = map_dict extended_output [ \"his_output\" ] = his_dict self . output = CoralOutputWrapper ( ** extended_output ) return def update_output ( out_model , new_values : dict ): if out_model is None : return None output_dict : dict = out_model . dict () for k , v in new_values . items (): if output_dict . get ( k , None ) is None : setattr ( out_model , k , v ) update_output ( self . output , extended_output ) update_output ( self . output . map_output , map_dict ) update_output ( self . output . his_output , his_dict )","title":"configure_output()"},{"location":"reference/biota_models/vegetation/vegetation_model/","text":"Vegetation models for the NBSDynamics package. \u00b6 Vegetation Protocol \u00b6 VegProtocol \u00b6 Bases: Protocol Protocol for all Vegetation to be used. Source code in src/biota_models/vegetation/model/veg_protocol.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @runtime_checkable class VegProtocol ( Protocol ): \"\"\" Protocol for all Vegetation to be used. \"\"\" @property def constants ( self ) -> VegetationConstants : \"\"\" Constants associated to the Vegetation Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError def update_vegetation_characteristics_growth ( self , veg_height , stem_dia , veg_root , m_height , m_stemdia , m_root ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update_vegetation_characteristics_winter ( self , veg_height , stem_dia , veg_root ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError constants () -> VegetationConstants property \u00b6 Constants associated to the Vegetation Model to be run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants VegetationConstants Instance of constants. Source code in src/biota_models/vegetation/model/veg_protocol.py 14 15 16 17 18 19 20 21 22 23 24 25 @property def constants ( self ) -> VegetationConstants : \"\"\" Constants associated to the Vegetation Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError update_vegetation_characteristics_growth ( veg_height , stem_dia , veg_root , m_height , m_stemdia , m_root ) \u00b6 Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional [ np . ndarray ] Custom coral definition. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/vegetation/model/veg_protocol.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def update_vegetation_characteristics_growth ( self , veg_height , stem_dia , veg_root , m_height , m_stemdia , m_root ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError update_vegetation_characteristics_winter ( veg_height , stem_dia , veg_root ) \u00b6 Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union [ float , np . ndarray ] Coral volume required morphology_ratios Dict [ str , Union [ float , np . ndarray ]] Morphology ratios (rf, rp, rs, ..) required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/vegetation/model/veg_protocol.py 43 44 45 46 47 48 49 50 51 52 53 54 def update_vegetation_characteristics_winter ( self , veg_height , stem_dia , veg_root ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Vegetation Model \u00b6 Vegetation \u00b6 Bases: Biota Implements the VegProtocol . Vegetation object, representing one plant. Source code in src/biota_models/vegetation/model/veg_model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 class Vegetation ( Biota ): \"\"\" Implements the `VegProtocol`. Vegetation object, representing one plant. \"\"\" species : str constants : Optional [ VegetationConstants ] total_cover : Optional [ VegAttribute ] # sum of fraction of area coverage in each cell (for all ages) initial : Optional [ LifeStages ] juvenile : Optional [ LifeStages ] mature : Optional [ LifeStages ] @root_validator def configure_veg_fields ( cls , values : dict ) -> dict : veg_constants = values . get ( \"constants\" , None ) if not veg_constants : veg_constants = VegetationConstants ( species = values [ \"species\" ]) values [ \"constants\" ] = veg_constants # other attributes. values [ \"initial\" ] = LifeStages ( ls = 0 , constants = veg_constants ) values [ \"juvenile\" ] = LifeStages ( ls = 1 , constants = veg_constants ) values [ \"mature\" ] = LifeStages ( ls = 2 , constants = veg_constants ) if not values . get ( \"total_cover\" , None ): # Initialize as an empty list if it has not been done earlier. values [ \"total_cover\" ] = [] return values # time related values growth_duration : pd . Timedelta = None col_duration : pd . Timedelta = None winter_duration : pd . Timedelta = None # growth_days: VegAttribute = list() # growth_Day: VegAttribute = list() # col_days: VegAttribute = list() # winter_days: VegAttribute = list() # # hydromorphodynamic environment max_tau : Optional [ VegAttribute ] = None max_u : Optional [ VegAttribute ] = None max_wl : Optional [ VegAttribute ] = None min_wl : Optional [ VegAttribute ] = None bl : Optional [ VegAttribute ] = None max_tau_prev : Optional [ VegAttribute ] = None max_u_prev : Optional [ VegAttribute ] = None max_wl_prev : Optional [ VegAttribute ] = None min_wl_prev : Optional [ VegAttribute ] = None bl_prev : Optional [ VegAttribute ] = None wl_prev : Optional [ VegAttribute ] = None tau_ts : Optional [ VegAttribute ] = None u_ts : Optional [ VegAttribute ] = None wl_ts : Optional [ VegAttribute ] = None bl_ts : Optional [ VegAttribute ] = None # @validator(\"_cover\") # @classmethod # def validate_vegetation_attribute( # cls, value: Optional[VegAttribute] # ) -> Optional[np.ndarray]: # if value is None: # return value # return DataReshape.variable2array(value) @property def total_cover ( self ): # as input for DFM # take cover as sum of all the ages and life stages # self.total_cover = self.juvenile.cover + self.mature.cover return self . juvenile . cover + self . mature . cover @property def veg_den ( self ): # as input for DFM \"\"\"stem density in number of stems per m2, according to area fraction of veg age\"\"\" return ( self . juvenile . stem_num * self . juvenile . veg_frac ) . sum ( axis = 1 ) + ( self . mature . stem_num * self . mature . veg_frac ) . sum ( axis = 1 ) @property def av_stemdia ( self ): # as input for DFM \"\"\"average stem diameter of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if self.juvenile.cover.all() == 0 and self.mature.cover.all() == 0: # return np.zeros(self.cover.shape) # elif self.mature.cover.all() == 0: # return (self.juvenile.stem_dia * self.juvenile.veg_frac).sum(axis=1) / self.juvenile.cover # elif self.juvenile.cover.all() == 0: # return (self.mature.stem_dia * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . stem_dia * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . stem_dia * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m @property def av_height ( self ): # as input for DFM \"\"\"average shoot height of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if np.all(self.juvenile.cover == 0) and np.all(self.mature.cover == 0): # return np.zeros(self.cover.shape) # elif np.all(self.mature.cover == 0): # return (self.juvenile.veg_height * self.juvenile.veg_frac).sum(axis=1) / (self.juvenile.cover[self.juvenile.cover == 0]=1) # elif self.juvenile.cover.all() == 0: # return (self.mature.veg_height * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . veg_height * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . veg_height * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m # def duration_growth(self, constants): # \"\"\"duration of the growth period from start, end growth from Constants\"\"\" # return (constants.get_duration(constants.growth_start, constants.growth_end) / np.timedelta64(1, 'D')) # # def duration_col(self, constants): # \"\"\"duration of the colonization period from start, end growth from Constants\"\"\" # return (constants.get_duration(constants.ColStart, constants.ColEnd) / np.timedelta64(1, 'D')) # # def duration_winter(self, constants): # \"\"\"duration of the colonization period from start, end growth from Constants\"\"\" # return (constants.get_duration(constants.winter_start, constants.growth_start) / np.timedelta64(1, 'D')) def update_lifestages ( self ): _reshape = RESHAPE () # take last colum of previous lifestage and append it in the beginning of new lifestage, delete it from the old lifestage if np . any ( self . initial . veg_frac > 0 ): self . juvenile . veg_frac = np . column_stack ( ( self . initial . veg_frac , self . juvenile . veg_frac ) ) self . juvenile . veg_height = np . column_stack ( ( self . initial . veg_height , self . juvenile . veg_height ) ) self . juvenile . stem_dia = np . column_stack ( ( self . initial . stem_dia , self . juvenile . stem_dia ) ) self . juvenile . root_len = np . column_stack ( ( self . initial . root_len , self . juvenile . root_len ) ) self . juvenile . stem_num = np . column_stack ( ( self . initial . stem_num , self . juvenile . stem_num ) ) self . juvenile . veg_age = np . column_stack ( ( self . initial . veg_age , self . juvenile . veg_age ) ) # empty initial arrays self . initial . veg_frac = np . zeros ( self . initial . veg_height . shape ) self . initial . veg_height = np . zeros ( self . initial . veg_frac . shape ) self . initial . stem_dia = np . zeros ( self . initial . veg_height . shape ) self . initial . root_len = np . zeros ( self . initial . veg_height . shape ) self . initial . stem_num = np . zeros ( self . initial . veg_height . shape ) self . juvenile . veg_frac = np . delete ( self . juvenile . veg_frac , np . where ( np . all ( self . juvenile . veg_frac == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . veg_height = np . delete ( self . juvenile . veg_height , np . where ( np . all ( self . juvenile . veg_height == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . veg_age = np . delete ( self . juvenile . veg_age , np . where ( np . all ( self . juvenile . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . stem_dia = np . delete ( self . juvenile . stem_dia , np . where ( np . all ( self . juvenile . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . root_len = np . delete ( self . juvenile . root_len , np . where ( np . all ( self . juvenile . root_len == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . stem_num = np . delete ( self . juvenile . stem_num , np . where ( np . all ( self . juvenile . stem_num == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . cover = self . juvenile . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) if self . species == \"Salicornia\" and self . juvenile . winter == True : self . juvenile . veg_frac = np . zeros ( _reshape . space ) self . juvenile . veg_frac = self . juvenile . veg_frac . reshape ( len ( self . juvenile . veg_frac ), 1 ) self . juvenile . veg_height = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . stem_dia = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . root_len = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . stem_num = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . cover = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . veg_age = np . zeros ( self . juvenile . veg_frac . shape ) elif np . any ( self . juvenile . veg_age > ( self . constants . maxYears_LS [ 0 ] * 365 )): self . mature . veg_frac = np . column_stack ( ( self . juvenile . veg_frac [:, - 1 ], self . mature . veg_frac ) ) self . mature . veg_height = np . column_stack ( ( self . juvenile . veg_height [:, - 1 ], self . mature . veg_height ) ) self . mature . stem_dia = np . column_stack ( ( self . juvenile . stem_dia [:, - 1 ], self . mature . stem_dia ) ) self . mature . root_len = np . column_stack ( ( self . juvenile . root_len [:, - 1 ], self . mature . root_len ) ) self . mature . stem_num = np . column_stack ( ( self . juvenile . stem_num [:, - 1 ], self . mature . stem_num ) ) self . mature . veg_age = np . column_stack ( ( self . juvenile . veg_age [:, - 1 ], self . mature . veg_age ) ) self . juvenile . veg_frac = np . delete ( self . juvenile . veg_frac , - 1 , 1 ) self . juvenile . veg_height = np . delete ( self . juvenile . veg_height , - 1 , 1 ) self . juvenile . stem_dia = np . delete ( self . juvenile . stem_dia , - 1 , 1 ) self . juvenile . root_len = np . delete ( self . juvenile . root_len , - 1 , 1 ) self . juvenile . stem_num = np . delete ( self . juvenile . stem_num , - 1 , 1 ) self . juvenile . veg_age = np . delete ( self . juvenile . veg_age , - 1 , 1 ) self . juvenile . cover = self . juvenile . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) self . mature . veg_frac = np . delete ( self . mature . veg_frac , np . where ( np . all ( self . mature . veg_frac == 0 , axis = 0 ) == True ), 1 , ) self . mature . veg_height = np . delete ( self . mature . veg_height , np . where ( np . all ( self . mature . veg_height == 0 , axis = 0 ) == True ), 1 , ) self . mature . veg_age = np . delete ( self . mature . veg_age , np . where ( np . all ( self . mature . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . mature . stem_dia = np . delete ( self . mature . stem_dia , np . where ( np . all ( self . mature . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . mature . root_len = np . delete ( self . mature . root_len , np . where ( np . all ( self . mature . root_len == 0 , axis = 0 ) == True ), 1 , ) self . mature . stem_num = np . delete ( self . mature . stem_num , np . where ( np . all ( self . mature . stem_num == 0 , axis = 0 ) == True ), 1 , ) self . mature . cover = self . mature . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) elif np . any ( self . juvenile . veg_age > ( self . constants . maxAge * 365 )): self . juvenile . veg_frac = np . delete ( self . juvenile . veg_frac , - 1 , 1 ) self . juvenile . veg_height = np . delete ( self . juvenile . veg_height , - 1 , 1 ) self . juvenile . stem_dia = np . delete ( self . juvenile . stem_dia , - 1 , 1 ) self . juvenile . root_len = np . delete ( self . juvenile . root_len , - 1 , 1 ) self . juvenile . stem_num = np . delete ( self . juvenile . stem_num , - 1 , 1 ) self . juvenile . veg_age = np . delete ( self . juvenile . veg_age , - 1 , 1 ) self . juvenile . cover = self . juvenile . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) if np . any ( self . mature . veg_age > ( self . constants . maxAge * 365 )): self . mature . veg_frac = np . delete ( self . mature . veg_frac , - 1 , 1 ) self . mature . veg_height = np . delete ( self . mature . veg_height , - 1 , 1 ) self . mature . stem_dia = np . delete ( self . mature . stem_dia , - 1 , 1 ) self . mature . root_len = np . delete ( self . mature . root_len , - 1 , 1 ) self . mature . stem_num = np . delete ( self . mature . stem_num , - 1 , 1 ) self . mature . veg_age = np . delete ( self . mature . veg_age , - 1 , 1 ) self . mature . cover = self . mature . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) av_height () property \u00b6 average shoot height of the different vegetation in one grid cell Source code in src/biota_models/vegetation/model/veg_model.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @property def av_height ( self ): # as input for DFM \"\"\"average shoot height of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if np.all(self.juvenile.cover == 0) and np.all(self.mature.cover == 0): # return np.zeros(self.cover.shape) # elif np.all(self.mature.cover == 0): # return (self.juvenile.veg_height * self.juvenile.veg_frac).sum(axis=1) / (self.juvenile.cover[self.juvenile.cover == 0]=1) # elif self.juvenile.cover.all() == 0: # return (self.mature.veg_height * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . veg_height * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . veg_height * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m av_stemdia () property \u00b6 average stem diameter of the different vegetation in one grid cell Source code in src/biota_models/vegetation/model/veg_model.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @property def av_stemdia ( self ): # as input for DFM \"\"\"average stem diameter of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if self.juvenile.cover.all() == 0 and self.mature.cover.all() == 0: # return np.zeros(self.cover.shape) # elif self.mature.cover.all() == 0: # return (self.juvenile.stem_dia * self.juvenile.veg_frac).sum(axis=1) / self.juvenile.cover # elif self.juvenile.cover.all() == 0: # return (self.mature.stem_dia * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . stem_dia * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . stem_dia * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m veg_den () property \u00b6 stem density in number of stems per m2, according to area fraction of veg age Source code in src/biota_models/vegetation/model/veg_model.py 87 88 89 90 91 92 @property def veg_den ( self ): # as input for DFM \"\"\"stem density in number of stems per m2, according to area fraction of veg age\"\"\" return ( self . juvenile . stem_num * self . juvenile . veg_frac ) . sum ( axis = 1 ) + ( self . mature . stem_num * self . mature . veg_frac ) . sum ( axis = 1 ) Vegetation Constants \u00b6 VegetationConstants \u00b6 Bases: BaseConstants Object containing all constants used in marsh_model simulations. Source code in src/biota_models/vegetation/model/veg_constants.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class VegetationConstants ( BaseConstants ): \"\"\"Object containing all constants used in marsh_model simulations.\"\"\" species : str input_file : Optional [ Path ] = default_veg_constants_json # Processes warn_proc : bool = False # User - Define time - scales t_eco_year : int = 24 # number ecological time - steps per year(meaning couplings) ## TODO check with MorFac, what years is this then? sim_duration : float = 30 # number of morphological years of entire simulation start_date : str = \"2022-01-01\" # Start date of the simulation winter_days : float = list () # Colonization ColMethod : int = 1 # Colonisation method (1 = on bare substrate between max and min water levels, 2 = on bare substrate with mud content) ColStart : str = None ColEnd : str = None random : int = None mud_col : float = None fl_dr : float = None maxAge : int = None num_ls : int = None iniRoot : float = None iniShoot : float = None iniDia : float = None growth_start : str = None growth_end : str = None winter_start : str = None maxGrowth_H : float = None maxDia : float = None maxRoot : float = None maxYears_LS : int = None num_stem : int = None iniCol_frac : float = None Cd : float = None desMort_thres : float = None desMort_slope : float = None floMort_thres : float = None floMort_slope : float = None vel_thres : float = None vel_slope : float = None maxH_winter : float = None @root_validator @classmethod def post_checks ( cls , values : dict ) -> dict : \"\"\" Class method to validate and check all the fields from the VegetationConstants class. Args: values (dict): Values already formatted during initialization. Returns: dict: Dictionary of properties to be set for the VegetationConstants object. \"\"\" cls . set_constants_from_default_json ( values ) return values @staticmethod def set_constants_from_default_json ( vegetation_constants : dict ): \"\"\" Loads all the constants from a given species (inside the 'vegetation_constants' dict), from a json file which should be saved in the 'vegetation_constants' dict as 'input_file'. Args: vegetation_constants (dict): Dictionary to fill with the found values. \"\"\" species : str = vegetation_constants [ \"species\" ] with open ( vegetation_constants [ \"input_file\" ]) as f : json_data_dict : dict = json . load ( f ) vegetation_constants [ \"ColStart\" ] = json_data_dict [ species ][ \"ColStart\" ] vegetation_constants [ \"ColEnd\" ] = json_data_dict [ species ][ \"ColEnd\" ] vegetation_constants [ \"random\" ] = json_data_dict [ species ][ \"random\" ] vegetation_constants [ \"mud_col\" ] = json_data_dict [ species ][ \"mud_colonization\" ] vegetation_constants [ \"fl_dr\" ] = json_data_dict [ species ][ \"fl_dr\" ] vegetation_constants [ \"maxAge\" ] = json_data_dict [ species ][ \"Maximum age\" ] vegetation_constants [ \"num_ls\" ] = json_data_dict [ species ][ \"Number LifeStages\" ] vegetation_constants [ \"iniRoot\" ] = json_data_dict [ species ][ \"initial root length\" ] vegetation_constants [ \"iniShoot\" ] = json_data_dict [ species ][ \"initial shoot length\" ] vegetation_constants [ \"iniDia\" ] = json_data_dict [ species ][ \"initial diameter\" ] vegetation_constants [ \"growth_start\" ] = json_data_dict [ species ][ \"start growth period\" ] vegetation_constants [ \"growth_end\" ] = json_data_dict [ species ][ \"end growth period\" ] vegetation_constants [ \"winter_start\" ] = json_data_dict [ species ][ \"start winter period\" ] vegetation_constants [ \"maxGrowth_H\" ] = json_data_dict [ species ][ \"maximum plant height\" ] vegetation_constants [ \"maxDia\" ] = json_data_dict [ species ][ \"maximum diameter\" ] vegetation_constants [ \"maxRoot\" ] = json_data_dict [ species ][ \"maximum root length\" ] vegetation_constants [ \"maxYears_LS\" ] = json_data_dict [ species ][ \"maximum years in LifeStage\" ] vegetation_constants [ \"num_stem\" ] = json_data_dict [ species ][ \"numStem\" ] vegetation_constants [ \"iniCol_frac\" ] = json_data_dict [ species ][ \"iniCol_frac\" ] vegetation_constants [ \"Cd\" ] = json_data_dict [ species ][ \"Cd\" ] vegetation_constants [ \"desMort_thres\" ] = json_data_dict [ species ][ \"desMort_thres\" ] vegetation_constants [ \"desMort_slope\" ] = json_data_dict [ species ][ \"desMort_slope\" ] vegetation_constants [ \"floMort_thres\" ] = json_data_dict [ species ][ \"floMort_thres\" ] vegetation_constants [ \"floMort_slope\" ] = json_data_dict [ species ][ \"floMort_slope\" ] vegetation_constants [ \"vel_thres\" ] = json_data_dict [ species ][ \"vel_thres\" ] vegetation_constants [ \"vel_slope\" ] = json_data_dict [ species ][ \"vel_slope\" ] vegetation_constants [ \"maxH_winter\" ] = json_data_dict [ species ][ \"maxH_winter\" ] @staticmethod def get_duration ( start_date , end_date ): start = pd . to_datetime ( start_date ) end = pd . to_datetime ( end_date ) return end - start @property def ets_duration ( self ): return round ( 365 / self . t_eco_year ) post_checks ( values : dict ) -> dict classmethod \u00b6 Class method to validate and check all the fields from the VegetationConstants class. Parameters: Name Type Description Default values dict Values already formatted during initialization. required Returns: Name Type Description dict dict Dictionary of properties to be set for the VegetationConstants object. Source code in src/biota_models/vegetation/model/veg_constants.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @root_validator @classmethod def post_checks ( cls , values : dict ) -> dict : \"\"\" Class method to validate and check all the fields from the VegetationConstants class. Args: values (dict): Values already formatted during initialization. Returns: dict: Dictionary of properties to be set for the VegetationConstants object. \"\"\" cls . set_constants_from_default_json ( values ) return values set_constants_from_default_json ( vegetation_constants : dict ) staticmethod \u00b6 Loads all the constants from a given species (inside the 'vegetation_constants' dict), from a json file which should be saved in the 'vegetation_constants' dict as 'input_file'. Parameters: Name Type Description Default vegetation_constants dict Dictionary to fill with the found values. required Source code in src/biota_models/vegetation/model/veg_constants.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @staticmethod def set_constants_from_default_json ( vegetation_constants : dict ): \"\"\" Loads all the constants from a given species (inside the 'vegetation_constants' dict), from a json file which should be saved in the 'vegetation_constants' dict as 'input_file'. Args: vegetation_constants (dict): Dictionary to fill with the found values. \"\"\" species : str = vegetation_constants [ \"species\" ] with open ( vegetation_constants [ \"input_file\" ]) as f : json_data_dict : dict = json . load ( f ) vegetation_constants [ \"ColStart\" ] = json_data_dict [ species ][ \"ColStart\" ] vegetation_constants [ \"ColEnd\" ] = json_data_dict [ species ][ \"ColEnd\" ] vegetation_constants [ \"random\" ] = json_data_dict [ species ][ \"random\" ] vegetation_constants [ \"mud_col\" ] = json_data_dict [ species ][ \"mud_colonization\" ] vegetation_constants [ \"fl_dr\" ] = json_data_dict [ species ][ \"fl_dr\" ] vegetation_constants [ \"maxAge\" ] = json_data_dict [ species ][ \"Maximum age\" ] vegetation_constants [ \"num_ls\" ] = json_data_dict [ species ][ \"Number LifeStages\" ] vegetation_constants [ \"iniRoot\" ] = json_data_dict [ species ][ \"initial root length\" ] vegetation_constants [ \"iniShoot\" ] = json_data_dict [ species ][ \"initial shoot length\" ] vegetation_constants [ \"iniDia\" ] = json_data_dict [ species ][ \"initial diameter\" ] vegetation_constants [ \"growth_start\" ] = json_data_dict [ species ][ \"start growth period\" ] vegetation_constants [ \"growth_end\" ] = json_data_dict [ species ][ \"end growth period\" ] vegetation_constants [ \"winter_start\" ] = json_data_dict [ species ][ \"start winter period\" ] vegetation_constants [ \"maxGrowth_H\" ] = json_data_dict [ species ][ \"maximum plant height\" ] vegetation_constants [ \"maxDia\" ] = json_data_dict [ species ][ \"maximum diameter\" ] vegetation_constants [ \"maxRoot\" ] = json_data_dict [ species ][ \"maximum root length\" ] vegetation_constants [ \"maxYears_LS\" ] = json_data_dict [ species ][ \"maximum years in LifeStage\" ] vegetation_constants [ \"num_stem\" ] = json_data_dict [ species ][ \"numStem\" ] vegetation_constants [ \"iniCol_frac\" ] = json_data_dict [ species ][ \"iniCol_frac\" ] vegetation_constants [ \"Cd\" ] = json_data_dict [ species ][ \"Cd\" ] vegetation_constants [ \"desMort_thres\" ] = json_data_dict [ species ][ \"desMort_thres\" ] vegetation_constants [ \"desMort_slope\" ] = json_data_dict [ species ][ \"desMort_slope\" ] vegetation_constants [ \"floMort_thres\" ] = json_data_dict [ species ][ \"floMort_thres\" ] vegetation_constants [ \"floMort_slope\" ] = json_data_dict [ species ][ \"floMort_slope\" ] vegetation_constants [ \"vel_thres\" ] = json_data_dict [ species ][ \"vel_thres\" ] vegetation_constants [ \"vel_slope\" ] = json_data_dict [ species ][ \"vel_slope\" ] vegetation_constants [ \"maxH_winter\" ] = json_data_dict [ species ][ \"maxH_winter\" ] Utils \u00b6 LifeStages \u00b6 Bases: ExtraModel Source code in src/biota_models/vegetation/model/veg_lifestages.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class LifeStages ( ExtraModel ): def __init__ ( self , ls , constants ): super () . __init__ () self . ls = ls self . constants = constants veg_height : VegAttribute = None # vegetation height [m] stem_dia : VegAttribute = None # stem diameter [m] root_len : VegAttribute = None # root length [m] veg_age : VegAttribute = None # vegetation life stage (0 or 1 or more), number defined in Constants.num_ls veg_frac : VegAttribute = None # vegetation age [yrs] stem_num : VegAttribute = None # number of stems cover : VegAttribute = None # vegetation fraction of all ages dt_height : VegAttribute = list () dt_root : VegAttribute = list () dt_stemdia : VegAttribute = list () winter : VegAttribute = False def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Characteristics( { self . veg_height } , { self . stem_dia } , { self . root_len } , { self . veg_age } , { self . stem_num } , { self . cover } )\" def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Vegetation characteristics with: veg_height = { self . veg_height } m; stem_dia = { self . stem_dia } m; veg_root = { self . root_len } m; veg_age = { self . veg_age } days; stem_num = { self . stem_num } ; \" f \"cover = { self . cover } \" ) # # @validator(\"veg_height\", \"stem_dia\", \"root_len\", \"stem_num\", \"cover\") # @classmethod # def validate_vegetation_attribute( # cls, value: Optional[VegAttribute] # ) -> Optional[np.ndarray]: # if value is None: # return value # return DataReshape.variable2array(value) # @property # def height_matrix(self): # \"\"\"self.RESHAPEd vegetation height.\"\"\" # return RESHAPE().variable2matrix(self.veg_height, \"space\") # # @property # def dia_matrix(self): # \"\"\"self.RESHAPEd stem diameter.\"\"\" # return RESHAPE().variable2matrix(self.stem_dia, \"space\") # # @property # def root_matrix(self): # \"\"\"self.RESHAPEd root length.\"\"\" # return RESHAPE().variable2matrix(self.root_len, \"space\") # # @property # def stemNum_matrix(self): # \"\"\"self.RESHAPEd vegetation age.\"\"\" # return RESHAPE().variable2matrix(self.stem_num, \"space\") def initiate_vegetation_characteristics ( self ): _reshape = RESHAPE () # intialization of the vegetation with initial values ## TODO change this for other input cases with initial cover! self . veg_frac = np . zeros ( _reshape . space ) self . veg_frac = self . veg_frac . reshape ( len ( self . veg_frac ), 1 ) self . veg_height = np . zeros ( self . veg_frac . shape ) self . stem_dia = np . zeros ( self . veg_frac . shape ) self . root_len = np . zeros ( self . veg_frac . shape ) self . stem_num = np . zeros ( self . veg_frac . shape ) self . cover = np . zeros ( self . veg_frac . shape ) self . veg_age = np . zeros ( self . veg_frac . shape ) i = self . ls - 1 self . dt_height = np . zeros (( 2 , 1 )) growth_duration = int ( ( self . constants . get_duration ( self . constants . growth_start , self . constants . growth_end ) ) . days ) if self . ls == 0 : pass elif self . constants . num_ls < self . ls : pass elif self . ls == 1 : self . dt_height [ 0 ] = ( self . constants . maxGrowth_H [ i ] - self . constants . iniShoot ) / growth_duration self . dt_height [ 1 ] = ( self . constants . maxGrowth_H [ i ] - self . constants . maxH_winter [ i ] ) / growth_duration self . dt_stemdia = ( self . constants . maxDia [ i ] - self . constants . iniDia ) / ( growth_duration * self . constants . maxYears_LS [ i ] ) self . dt_root = ( self . constants . maxRoot [ i ] - self . constants . iniRoot ) / ( growth_duration * self . constants . maxYears_LS [ i ] ) elif self . ls > 1 : self . dt_height [ 0 ] = ( self . constants . maxGrowth_H [ i ] - self . constants . maxH_winter [ i ] ) / growth_duration # growth per day of growing season self . dt_stemdia = ( self . constants . maxDia [ i ] - self . constants . maxDia [ i - 1 ] ) / ( growth_duration * self . constants . maxYears_LS [ i ]) self . dt_root = ( self . constants . maxRoot [ i ] - self . constants . maxRoot [ i - 1 ] ) / ( growth_duration * self . constants . maxYears_LS [ i ]) def update_growth ( self , veg_frac , period , begin_date , end_date ): \"\"\" update vegetation characteristics based on the vegetation age and fraction of veg in each cell (veg_frac_age) \"\"\" if self . constants . num_ls < self . ls : pass else : winter_start = pd . to_datetime ( self . constants . winter_start ) . replace ( year = begin_date . year ) start_growth = pd . to_datetime ( self . constants . growth_start ) . replace ( year = begin_date . year ) end_growth = pd . to_datetime ( self . constants . growth_end ) . replace ( year = begin_date . year ) a = start_growth <= pd . to_datetime ( period ) b = pd . to_datetime ( period ) <= end_growth c = np . nonzero (( a == True ) & ( b == True )) growth_days = len ( c [ 0 ]) if begin_date <= winter_start <= end_date : self . winter = True self . veg_height [ veg_frac == 0 ] = 0 # delete vegetation which died self . veg_height [ self . constants . maxH_winter [ self . ls - 1 ] < self . veg_height ] = self . constants . maxH_winter [ self . ls - 1 ] # change the height for all the vegetation which i biger than max_height_winter to max_height_winter else : self . winter = False self . veg_height [ veg_frac > 0 ] = self . veg_height [ veg_frac > 0 ] + ( self . dt_height [ 0 ] * growth_days ) self . veg_height [ veg_frac == 0 ] = 0 self . stem_dia [ veg_frac > 0 ] = self . stem_dia [ veg_frac > 0 ] + ( self . dt_stemdia * growth_days ) self . stem_dia [ veg_frac == 0 ] = 0 self . root_len [ veg_frac > 0 ] = self . root_len [ veg_frac > 0 ] + ( self . dt_root * growth_days ) self . root_len [ veg_frac == 0 ] = 0 self . stem_num [ veg_frac > 0 ] = self . constants . num_stem [ self . ls - 1 ] self . stem_num [ veg_frac == 0 ] = 0 self . veg_age [ veg_frac > 0 ] = ( self . veg_age [ veg_frac > 0 ] + self . constants . ets_duration ) self . veg_age [ veg_frac == 0 ] = 0 self . cover = veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) __repr__ () \u00b6 Development representation. Source code in src/biota_models/vegetation/model/veg_lifestages.py 32 33 34 def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Characteristics( { self . veg_height } , { self . stem_dia } , { self . root_len } , { self . veg_age } , { self . stem_num } , { self . cover } )\" __str__ () \u00b6 Print representation. Source code in src/biota_models/vegetation/model/veg_lifestages.py 36 37 38 39 40 41 def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Vegetation characteristics with: veg_height = { self . veg_height } m; stem_dia = { self . stem_dia } m; veg_root = { self . root_len } m; veg_age = { self . veg_age } days; stem_num = { self . stem_num } ; \" f \"cover = { self . cover } \" ) update_growth ( veg_frac , period , begin_date , end_date ) \u00b6 update vegetation characteristics based on the vegetation age and fraction of veg in each cell (veg_frac_age) Source code in src/biota_models/vegetation/model/veg_lifestages.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def update_growth ( self , veg_frac , period , begin_date , end_date ): \"\"\" update vegetation characteristics based on the vegetation age and fraction of veg in each cell (veg_frac_age) \"\"\" if self . constants . num_ls < self . ls : pass else : winter_start = pd . to_datetime ( self . constants . winter_start ) . replace ( year = begin_date . year ) start_growth = pd . to_datetime ( self . constants . growth_start ) . replace ( year = begin_date . year ) end_growth = pd . to_datetime ( self . constants . growth_end ) . replace ( year = begin_date . year ) a = start_growth <= pd . to_datetime ( period ) b = pd . to_datetime ( period ) <= end_growth c = np . nonzero (( a == True ) & ( b == True )) growth_days = len ( c [ 0 ]) if begin_date <= winter_start <= end_date : self . winter = True self . veg_height [ veg_frac == 0 ] = 0 # delete vegetation which died self . veg_height [ self . constants . maxH_winter [ self . ls - 1 ] < self . veg_height ] = self . constants . maxH_winter [ self . ls - 1 ] # change the height for all the vegetation which i biger than max_height_winter to max_height_winter else : self . winter = False self . veg_height [ veg_frac > 0 ] = self . veg_height [ veg_frac > 0 ] + ( self . dt_height [ 0 ] * growth_days ) self . veg_height [ veg_frac == 0 ] = 0 self . stem_dia [ veg_frac > 0 ] = self . stem_dia [ veg_frac > 0 ] + ( self . dt_stemdia * growth_days ) self . stem_dia [ veg_frac == 0 ] = 0 self . root_len [ veg_frac > 0 ] = self . root_len [ veg_frac > 0 ] + ( self . dt_root * growth_days ) self . root_len [ veg_frac == 0 ] = 0 self . stem_num [ veg_frac > 0 ] = self . constants . num_stem [ self . ls - 1 ] self . stem_num [ veg_frac == 0 ] = 0 self . veg_age [ veg_frac > 0 ] = ( self . veg_age [ veg_frac > 0 ] + self . constants . ets_duration ) self . veg_age [ veg_frac == 0 ] = 0 self . cover = veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) VegOnly \u00b6 Execute functions only in the presence of vegetation. Source code in src/biota_models/vegetation/model/veg_only.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class VegOnly : \"\"\"Execute functions only in the presence of vegetation.\"\"\" spacetime = None @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ] @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ] def in_space ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is vegetation cover. Args: veg (Vegetation): Vegetation object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of vegetation cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the vegetation function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output def in_spacetime ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is vegetation cover. :param veg: vegetation object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of vegetation cover :type veg: Vegetation :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == veg . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output in_space ( veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 ) -> np . ndarray \u00b6 Only execute the function when there is vegetation cover. Parameters: Name Type Description Default veg Vegetation Vegetation object. required function Callable Function to be executed. required args Tuple input arguments of the function. required no_cover_value Optional [ float ] Default value in absence of vegetation cover. Defaults to 0. 0 Raises: Type Description ValueError When sizes do not match. Returns: Type Description np . ndarray np.ndarray: Result of the vegetation function. Source code in src/biota_models/vegetation/model/veg_only.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def in_space ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is vegetation cover. Args: veg (Vegetation): Vegetation object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of vegetation cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the vegetation function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output in_spacetime ( veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 ) \u00b6 Only execute the function when there is vegetation cover. :param veg: vegetation object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of vegetation cover :type veg: Vegetation :type args: tuple :type no_cover_value: float, optional Source code in src/biota_models/vegetation/model/veg_only.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def in_spacetime ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is vegetation cover. :param veg: vegetation object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of vegetation cover :type veg: Vegetation :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == veg . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output space () property \u00b6 Space dimension. Source code in src/biota_models/vegetation/model/veg_only.py 11 12 13 14 @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ] time () property \u00b6 Time dimension. Source code in src/biota_models/vegetation/model/veg_only.py 16 17 18 19 @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ]","title":"Vegetation model"},{"location":"reference/biota_models/vegetation/vegetation_model/#vegetation-models-for-the-nbsdynamics-package","text":"","title":"Vegetation models for the NBSDynamics package."},{"location":"reference/biota_models/vegetation/vegetation_model/#vegetation-protocol","text":"","title":"Vegetation Protocol"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_protocol.VegProtocol","text":"Bases: Protocol Protocol for all Vegetation to be used. Source code in src/biota_models/vegetation/model/veg_protocol.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @runtime_checkable class VegProtocol ( Protocol ): \"\"\" Protocol for all Vegetation to be used. \"\"\" @property def constants ( self ) -> VegetationConstants : \"\"\" Constants associated to the Vegetation Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError def update_vegetation_characteristics_growth ( self , veg_height , stem_dia , veg_root , m_height , m_stemdia , m_root ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update_vegetation_characteristics_winter ( self , veg_height , stem_dia , veg_root ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"VegProtocol"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_protocol.VegProtocol.constants","text":"Constants associated to the Vegetation Model to be run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants VegetationConstants Instance of constants. Source code in src/biota_models/vegetation/model/veg_protocol.py 14 15 16 17 18 19 20 21 22 23 24 25 @property def constants ( self ) -> VegetationConstants : \"\"\" Constants associated to the Vegetation Model to be run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of constants. \"\"\" raise NotImplementedError","title":"constants()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_protocol.VegProtocol.update_vegetation_characteristics_growth","text":"Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional [ np . ndarray ] Custom coral definition. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/vegetation/model/veg_protocol.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def update_vegetation_characteristics_growth ( self , veg_height , stem_dia , veg_root , m_height , m_stemdia , m_root ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update_vegetation_characteristics_growth()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_protocol.VegProtocol.update_vegetation_characteristics_winter","text":"Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union [ float , np . ndarray ] Coral volume required morphology_ratios Dict [ str , Union [ float , np . ndarray ]] Morphology ratios (rf, rp, rs, ..) required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/biota_models/vegetation/model/veg_protocol.py 43 44 45 46 47 48 49 50 51 52 53 54 def update_vegetation_characteristics_winter ( self , veg_height , stem_dia , veg_root ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update_vegetation_characteristics_winter()"},{"location":"reference/biota_models/vegetation/vegetation_model/#vegetation-model","text":"","title":"Vegetation Model"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_model.Vegetation","text":"Bases: Biota Implements the VegProtocol . Vegetation object, representing one plant. Source code in src/biota_models/vegetation/model/veg_model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 class Vegetation ( Biota ): \"\"\" Implements the `VegProtocol`. Vegetation object, representing one plant. \"\"\" species : str constants : Optional [ VegetationConstants ] total_cover : Optional [ VegAttribute ] # sum of fraction of area coverage in each cell (for all ages) initial : Optional [ LifeStages ] juvenile : Optional [ LifeStages ] mature : Optional [ LifeStages ] @root_validator def configure_veg_fields ( cls , values : dict ) -> dict : veg_constants = values . get ( \"constants\" , None ) if not veg_constants : veg_constants = VegetationConstants ( species = values [ \"species\" ]) values [ \"constants\" ] = veg_constants # other attributes. values [ \"initial\" ] = LifeStages ( ls = 0 , constants = veg_constants ) values [ \"juvenile\" ] = LifeStages ( ls = 1 , constants = veg_constants ) values [ \"mature\" ] = LifeStages ( ls = 2 , constants = veg_constants ) if not values . get ( \"total_cover\" , None ): # Initialize as an empty list if it has not been done earlier. values [ \"total_cover\" ] = [] return values # time related values growth_duration : pd . Timedelta = None col_duration : pd . Timedelta = None winter_duration : pd . Timedelta = None # growth_days: VegAttribute = list() # growth_Day: VegAttribute = list() # col_days: VegAttribute = list() # winter_days: VegAttribute = list() # # hydromorphodynamic environment max_tau : Optional [ VegAttribute ] = None max_u : Optional [ VegAttribute ] = None max_wl : Optional [ VegAttribute ] = None min_wl : Optional [ VegAttribute ] = None bl : Optional [ VegAttribute ] = None max_tau_prev : Optional [ VegAttribute ] = None max_u_prev : Optional [ VegAttribute ] = None max_wl_prev : Optional [ VegAttribute ] = None min_wl_prev : Optional [ VegAttribute ] = None bl_prev : Optional [ VegAttribute ] = None wl_prev : Optional [ VegAttribute ] = None tau_ts : Optional [ VegAttribute ] = None u_ts : Optional [ VegAttribute ] = None wl_ts : Optional [ VegAttribute ] = None bl_ts : Optional [ VegAttribute ] = None # @validator(\"_cover\") # @classmethod # def validate_vegetation_attribute( # cls, value: Optional[VegAttribute] # ) -> Optional[np.ndarray]: # if value is None: # return value # return DataReshape.variable2array(value) @property def total_cover ( self ): # as input for DFM # take cover as sum of all the ages and life stages # self.total_cover = self.juvenile.cover + self.mature.cover return self . juvenile . cover + self . mature . cover @property def veg_den ( self ): # as input for DFM \"\"\"stem density in number of stems per m2, according to area fraction of veg age\"\"\" return ( self . juvenile . stem_num * self . juvenile . veg_frac ) . sum ( axis = 1 ) + ( self . mature . stem_num * self . mature . veg_frac ) . sum ( axis = 1 ) @property def av_stemdia ( self ): # as input for DFM \"\"\"average stem diameter of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if self.juvenile.cover.all() == 0 and self.mature.cover.all() == 0: # return np.zeros(self.cover.shape) # elif self.mature.cover.all() == 0: # return (self.juvenile.stem_dia * self.juvenile.veg_frac).sum(axis=1) / self.juvenile.cover # elif self.juvenile.cover.all() == 0: # return (self.mature.stem_dia * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . stem_dia * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . stem_dia * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m @property def av_height ( self ): # as input for DFM \"\"\"average shoot height of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if np.all(self.juvenile.cover == 0) and np.all(self.mature.cover == 0): # return np.zeros(self.cover.shape) # elif np.all(self.mature.cover == 0): # return (self.juvenile.veg_height * self.juvenile.veg_frac).sum(axis=1) / (self.juvenile.cover[self.juvenile.cover == 0]=1) # elif self.juvenile.cover.all() == 0: # return (self.mature.veg_height * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . veg_height * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . veg_height * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m # def duration_growth(self, constants): # \"\"\"duration of the growth period from start, end growth from Constants\"\"\" # return (constants.get_duration(constants.growth_start, constants.growth_end) / np.timedelta64(1, 'D')) # # def duration_col(self, constants): # \"\"\"duration of the colonization period from start, end growth from Constants\"\"\" # return (constants.get_duration(constants.ColStart, constants.ColEnd) / np.timedelta64(1, 'D')) # # def duration_winter(self, constants): # \"\"\"duration of the colonization period from start, end growth from Constants\"\"\" # return (constants.get_duration(constants.winter_start, constants.growth_start) / np.timedelta64(1, 'D')) def update_lifestages ( self ): _reshape = RESHAPE () # take last colum of previous lifestage and append it in the beginning of new lifestage, delete it from the old lifestage if np . any ( self . initial . veg_frac > 0 ): self . juvenile . veg_frac = np . column_stack ( ( self . initial . veg_frac , self . juvenile . veg_frac ) ) self . juvenile . veg_height = np . column_stack ( ( self . initial . veg_height , self . juvenile . veg_height ) ) self . juvenile . stem_dia = np . column_stack ( ( self . initial . stem_dia , self . juvenile . stem_dia ) ) self . juvenile . root_len = np . column_stack ( ( self . initial . root_len , self . juvenile . root_len ) ) self . juvenile . stem_num = np . column_stack ( ( self . initial . stem_num , self . juvenile . stem_num ) ) self . juvenile . veg_age = np . column_stack ( ( self . initial . veg_age , self . juvenile . veg_age ) ) # empty initial arrays self . initial . veg_frac = np . zeros ( self . initial . veg_height . shape ) self . initial . veg_height = np . zeros ( self . initial . veg_frac . shape ) self . initial . stem_dia = np . zeros ( self . initial . veg_height . shape ) self . initial . root_len = np . zeros ( self . initial . veg_height . shape ) self . initial . stem_num = np . zeros ( self . initial . veg_height . shape ) self . juvenile . veg_frac = np . delete ( self . juvenile . veg_frac , np . where ( np . all ( self . juvenile . veg_frac == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . veg_height = np . delete ( self . juvenile . veg_height , np . where ( np . all ( self . juvenile . veg_height == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . veg_age = np . delete ( self . juvenile . veg_age , np . where ( np . all ( self . juvenile . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . stem_dia = np . delete ( self . juvenile . stem_dia , np . where ( np . all ( self . juvenile . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . root_len = np . delete ( self . juvenile . root_len , np . where ( np . all ( self . juvenile . root_len == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . stem_num = np . delete ( self . juvenile . stem_num , np . where ( np . all ( self . juvenile . stem_num == 0 , axis = 0 ) == True ), 1 , ) self . juvenile . cover = self . juvenile . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) if self . species == \"Salicornia\" and self . juvenile . winter == True : self . juvenile . veg_frac = np . zeros ( _reshape . space ) self . juvenile . veg_frac = self . juvenile . veg_frac . reshape ( len ( self . juvenile . veg_frac ), 1 ) self . juvenile . veg_height = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . stem_dia = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . root_len = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . stem_num = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . cover = np . zeros ( self . juvenile . veg_frac . shape ) self . juvenile . veg_age = np . zeros ( self . juvenile . veg_frac . shape ) elif np . any ( self . juvenile . veg_age > ( self . constants . maxYears_LS [ 0 ] * 365 )): self . mature . veg_frac = np . column_stack ( ( self . juvenile . veg_frac [:, - 1 ], self . mature . veg_frac ) ) self . mature . veg_height = np . column_stack ( ( self . juvenile . veg_height [:, - 1 ], self . mature . veg_height ) ) self . mature . stem_dia = np . column_stack ( ( self . juvenile . stem_dia [:, - 1 ], self . mature . stem_dia ) ) self . mature . root_len = np . column_stack ( ( self . juvenile . root_len [:, - 1 ], self . mature . root_len ) ) self . mature . stem_num = np . column_stack ( ( self . juvenile . stem_num [:, - 1 ], self . mature . stem_num ) ) self . mature . veg_age = np . column_stack ( ( self . juvenile . veg_age [:, - 1 ], self . mature . veg_age ) ) self . juvenile . veg_frac = np . delete ( self . juvenile . veg_frac , - 1 , 1 ) self . juvenile . veg_height = np . delete ( self . juvenile . veg_height , - 1 , 1 ) self . juvenile . stem_dia = np . delete ( self . juvenile . stem_dia , - 1 , 1 ) self . juvenile . root_len = np . delete ( self . juvenile . root_len , - 1 , 1 ) self . juvenile . stem_num = np . delete ( self . juvenile . stem_num , - 1 , 1 ) self . juvenile . veg_age = np . delete ( self . juvenile . veg_age , - 1 , 1 ) self . juvenile . cover = self . juvenile . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) self . mature . veg_frac = np . delete ( self . mature . veg_frac , np . where ( np . all ( self . mature . veg_frac == 0 , axis = 0 ) == True ), 1 , ) self . mature . veg_height = np . delete ( self . mature . veg_height , np . where ( np . all ( self . mature . veg_height == 0 , axis = 0 ) == True ), 1 , ) self . mature . veg_age = np . delete ( self . mature . veg_age , np . where ( np . all ( self . mature . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . mature . stem_dia = np . delete ( self . mature . stem_dia , np . where ( np . all ( self . mature . stem_dia == 0 , axis = 0 ) == True ), 1 , ) self . mature . root_len = np . delete ( self . mature . root_len , np . where ( np . all ( self . mature . root_len == 0 , axis = 0 ) == True ), 1 , ) self . mature . stem_num = np . delete ( self . mature . stem_num , np . where ( np . all ( self . mature . stem_num == 0 , axis = 0 ) == True ), 1 , ) self . mature . cover = self . mature . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) elif np . any ( self . juvenile . veg_age > ( self . constants . maxAge * 365 )): self . juvenile . veg_frac = np . delete ( self . juvenile . veg_frac , - 1 , 1 ) self . juvenile . veg_height = np . delete ( self . juvenile . veg_height , - 1 , 1 ) self . juvenile . stem_dia = np . delete ( self . juvenile . stem_dia , - 1 , 1 ) self . juvenile . root_len = np . delete ( self . juvenile . root_len , - 1 , 1 ) self . juvenile . stem_num = np . delete ( self . juvenile . stem_num , - 1 , 1 ) self . juvenile . veg_age = np . delete ( self . juvenile . veg_age , - 1 , 1 ) self . juvenile . cover = self . juvenile . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 ) if np . any ( self . mature . veg_age > ( self . constants . maxAge * 365 )): self . mature . veg_frac = np . delete ( self . mature . veg_frac , - 1 , 1 ) self . mature . veg_height = np . delete ( self . mature . veg_height , - 1 , 1 ) self . mature . stem_dia = np . delete ( self . mature . stem_dia , - 1 , 1 ) self . mature . root_len = np . delete ( self . mature . root_len , - 1 , 1 ) self . mature . stem_num = np . delete ( self . mature . stem_num , - 1 , 1 ) self . mature . veg_age = np . delete ( self . mature . veg_age , - 1 , 1 ) self . mature . cover = self . mature . veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 )","title":"Vegetation"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_model.Vegetation.av_height","text":"average shoot height of the different vegetation in one grid cell Source code in src/biota_models/vegetation/model/veg_model.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @property def av_height ( self ): # as input for DFM \"\"\"average shoot height of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if np.all(self.juvenile.cover == 0) and np.all(self.mature.cover == 0): # return np.zeros(self.cover.shape) # elif np.all(self.mature.cover == 0): # return (self.juvenile.veg_height * self.juvenile.veg_frac).sum(axis=1) / (self.juvenile.cover[self.juvenile.cover == 0]=1) # elif self.juvenile.cover.all() == 0: # return (self.mature.veg_height * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . veg_height * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . veg_height * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m","title":"av_height()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_model.Vegetation.av_stemdia","text":"average stem diameter of the different vegetation in one grid cell Source code in src/biota_models/vegetation/model/veg_model.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @property def av_stemdia ( self ): # as input for DFM \"\"\"average stem diameter of the different vegetation in one grid cell\"\"\" cover_j = self . juvenile . cover . copy () cover_m = self . mature . cover . copy () cover_j [ cover_j == 0 ] = 1 cover_m [ cover_m == 0 ] = 1 # if self.juvenile.cover.all() == 0 and self.mature.cover.all() == 0: # return np.zeros(self.cover.shape) # elif self.mature.cover.all() == 0: # return (self.juvenile.stem_dia * self.juvenile.veg_frac).sum(axis=1) / self.juvenile.cover # elif self.juvenile.cover.all() == 0: # return (self.mature.stem_dia * self.mature.veg_frac).sum(axis=1) / self.mature.cover # else: return ( self . juvenile . stem_dia * self . juvenile . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_j + ( self . mature . stem_dia * self . mature . veg_frac ) . sum ( axis = 1 ) . reshape ( - 1 , 1 ) / cover_m","title":"av_stemdia()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_model.Vegetation.veg_den","text":"stem density in number of stems per m2, according to area fraction of veg age Source code in src/biota_models/vegetation/model/veg_model.py 87 88 89 90 91 92 @property def veg_den ( self ): # as input for DFM \"\"\"stem density in number of stems per m2, according to area fraction of veg age\"\"\" return ( self . juvenile . stem_num * self . juvenile . veg_frac ) . sum ( axis = 1 ) + ( self . mature . stem_num * self . mature . veg_frac ) . sum ( axis = 1 )","title":"veg_den()"},{"location":"reference/biota_models/vegetation/vegetation_model/#vegetation-constants","text":"","title":"Vegetation Constants"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_constants.VegetationConstants","text":"Bases: BaseConstants Object containing all constants used in marsh_model simulations. Source code in src/biota_models/vegetation/model/veg_constants.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class VegetationConstants ( BaseConstants ): \"\"\"Object containing all constants used in marsh_model simulations.\"\"\" species : str input_file : Optional [ Path ] = default_veg_constants_json # Processes warn_proc : bool = False # User - Define time - scales t_eco_year : int = 24 # number ecological time - steps per year(meaning couplings) ## TODO check with MorFac, what years is this then? sim_duration : float = 30 # number of morphological years of entire simulation start_date : str = \"2022-01-01\" # Start date of the simulation winter_days : float = list () # Colonization ColMethod : int = 1 # Colonisation method (1 = on bare substrate between max and min water levels, 2 = on bare substrate with mud content) ColStart : str = None ColEnd : str = None random : int = None mud_col : float = None fl_dr : float = None maxAge : int = None num_ls : int = None iniRoot : float = None iniShoot : float = None iniDia : float = None growth_start : str = None growth_end : str = None winter_start : str = None maxGrowth_H : float = None maxDia : float = None maxRoot : float = None maxYears_LS : int = None num_stem : int = None iniCol_frac : float = None Cd : float = None desMort_thres : float = None desMort_slope : float = None floMort_thres : float = None floMort_slope : float = None vel_thres : float = None vel_slope : float = None maxH_winter : float = None @root_validator @classmethod def post_checks ( cls , values : dict ) -> dict : \"\"\" Class method to validate and check all the fields from the VegetationConstants class. Args: values (dict): Values already formatted during initialization. Returns: dict: Dictionary of properties to be set for the VegetationConstants object. \"\"\" cls . set_constants_from_default_json ( values ) return values @staticmethod def set_constants_from_default_json ( vegetation_constants : dict ): \"\"\" Loads all the constants from a given species (inside the 'vegetation_constants' dict), from a json file which should be saved in the 'vegetation_constants' dict as 'input_file'. Args: vegetation_constants (dict): Dictionary to fill with the found values. \"\"\" species : str = vegetation_constants [ \"species\" ] with open ( vegetation_constants [ \"input_file\" ]) as f : json_data_dict : dict = json . load ( f ) vegetation_constants [ \"ColStart\" ] = json_data_dict [ species ][ \"ColStart\" ] vegetation_constants [ \"ColEnd\" ] = json_data_dict [ species ][ \"ColEnd\" ] vegetation_constants [ \"random\" ] = json_data_dict [ species ][ \"random\" ] vegetation_constants [ \"mud_col\" ] = json_data_dict [ species ][ \"mud_colonization\" ] vegetation_constants [ \"fl_dr\" ] = json_data_dict [ species ][ \"fl_dr\" ] vegetation_constants [ \"maxAge\" ] = json_data_dict [ species ][ \"Maximum age\" ] vegetation_constants [ \"num_ls\" ] = json_data_dict [ species ][ \"Number LifeStages\" ] vegetation_constants [ \"iniRoot\" ] = json_data_dict [ species ][ \"initial root length\" ] vegetation_constants [ \"iniShoot\" ] = json_data_dict [ species ][ \"initial shoot length\" ] vegetation_constants [ \"iniDia\" ] = json_data_dict [ species ][ \"initial diameter\" ] vegetation_constants [ \"growth_start\" ] = json_data_dict [ species ][ \"start growth period\" ] vegetation_constants [ \"growth_end\" ] = json_data_dict [ species ][ \"end growth period\" ] vegetation_constants [ \"winter_start\" ] = json_data_dict [ species ][ \"start winter period\" ] vegetation_constants [ \"maxGrowth_H\" ] = json_data_dict [ species ][ \"maximum plant height\" ] vegetation_constants [ \"maxDia\" ] = json_data_dict [ species ][ \"maximum diameter\" ] vegetation_constants [ \"maxRoot\" ] = json_data_dict [ species ][ \"maximum root length\" ] vegetation_constants [ \"maxYears_LS\" ] = json_data_dict [ species ][ \"maximum years in LifeStage\" ] vegetation_constants [ \"num_stem\" ] = json_data_dict [ species ][ \"numStem\" ] vegetation_constants [ \"iniCol_frac\" ] = json_data_dict [ species ][ \"iniCol_frac\" ] vegetation_constants [ \"Cd\" ] = json_data_dict [ species ][ \"Cd\" ] vegetation_constants [ \"desMort_thres\" ] = json_data_dict [ species ][ \"desMort_thres\" ] vegetation_constants [ \"desMort_slope\" ] = json_data_dict [ species ][ \"desMort_slope\" ] vegetation_constants [ \"floMort_thres\" ] = json_data_dict [ species ][ \"floMort_thres\" ] vegetation_constants [ \"floMort_slope\" ] = json_data_dict [ species ][ \"floMort_slope\" ] vegetation_constants [ \"vel_thres\" ] = json_data_dict [ species ][ \"vel_thres\" ] vegetation_constants [ \"vel_slope\" ] = json_data_dict [ species ][ \"vel_slope\" ] vegetation_constants [ \"maxH_winter\" ] = json_data_dict [ species ][ \"maxH_winter\" ] @staticmethod def get_duration ( start_date , end_date ): start = pd . to_datetime ( start_date ) end = pd . to_datetime ( end_date ) return end - start @property def ets_duration ( self ): return round ( 365 / self . t_eco_year )","title":"VegetationConstants"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_constants.VegetationConstants.post_checks","text":"Class method to validate and check all the fields from the VegetationConstants class. Parameters: Name Type Description Default values dict Values already formatted during initialization. required Returns: Name Type Description dict dict Dictionary of properties to be set for the VegetationConstants object. Source code in src/biota_models/vegetation/model/veg_constants.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @root_validator @classmethod def post_checks ( cls , values : dict ) -> dict : \"\"\" Class method to validate and check all the fields from the VegetationConstants class. Args: values (dict): Values already formatted during initialization. Returns: dict: Dictionary of properties to be set for the VegetationConstants object. \"\"\" cls . set_constants_from_default_json ( values ) return values","title":"post_checks()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_constants.VegetationConstants.set_constants_from_default_json","text":"Loads all the constants from a given species (inside the 'vegetation_constants' dict), from a json file which should be saved in the 'vegetation_constants' dict as 'input_file'. Parameters: Name Type Description Default vegetation_constants dict Dictionary to fill with the found values. required Source code in src/biota_models/vegetation/model/veg_constants.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @staticmethod def set_constants_from_default_json ( vegetation_constants : dict ): \"\"\" Loads all the constants from a given species (inside the 'vegetation_constants' dict), from a json file which should be saved in the 'vegetation_constants' dict as 'input_file'. Args: vegetation_constants (dict): Dictionary to fill with the found values. \"\"\" species : str = vegetation_constants [ \"species\" ] with open ( vegetation_constants [ \"input_file\" ]) as f : json_data_dict : dict = json . load ( f ) vegetation_constants [ \"ColStart\" ] = json_data_dict [ species ][ \"ColStart\" ] vegetation_constants [ \"ColEnd\" ] = json_data_dict [ species ][ \"ColEnd\" ] vegetation_constants [ \"random\" ] = json_data_dict [ species ][ \"random\" ] vegetation_constants [ \"mud_col\" ] = json_data_dict [ species ][ \"mud_colonization\" ] vegetation_constants [ \"fl_dr\" ] = json_data_dict [ species ][ \"fl_dr\" ] vegetation_constants [ \"maxAge\" ] = json_data_dict [ species ][ \"Maximum age\" ] vegetation_constants [ \"num_ls\" ] = json_data_dict [ species ][ \"Number LifeStages\" ] vegetation_constants [ \"iniRoot\" ] = json_data_dict [ species ][ \"initial root length\" ] vegetation_constants [ \"iniShoot\" ] = json_data_dict [ species ][ \"initial shoot length\" ] vegetation_constants [ \"iniDia\" ] = json_data_dict [ species ][ \"initial diameter\" ] vegetation_constants [ \"growth_start\" ] = json_data_dict [ species ][ \"start growth period\" ] vegetation_constants [ \"growth_end\" ] = json_data_dict [ species ][ \"end growth period\" ] vegetation_constants [ \"winter_start\" ] = json_data_dict [ species ][ \"start winter period\" ] vegetation_constants [ \"maxGrowth_H\" ] = json_data_dict [ species ][ \"maximum plant height\" ] vegetation_constants [ \"maxDia\" ] = json_data_dict [ species ][ \"maximum diameter\" ] vegetation_constants [ \"maxRoot\" ] = json_data_dict [ species ][ \"maximum root length\" ] vegetation_constants [ \"maxYears_LS\" ] = json_data_dict [ species ][ \"maximum years in LifeStage\" ] vegetation_constants [ \"num_stem\" ] = json_data_dict [ species ][ \"numStem\" ] vegetation_constants [ \"iniCol_frac\" ] = json_data_dict [ species ][ \"iniCol_frac\" ] vegetation_constants [ \"Cd\" ] = json_data_dict [ species ][ \"Cd\" ] vegetation_constants [ \"desMort_thres\" ] = json_data_dict [ species ][ \"desMort_thres\" ] vegetation_constants [ \"desMort_slope\" ] = json_data_dict [ species ][ \"desMort_slope\" ] vegetation_constants [ \"floMort_thres\" ] = json_data_dict [ species ][ \"floMort_thres\" ] vegetation_constants [ \"floMort_slope\" ] = json_data_dict [ species ][ \"floMort_slope\" ] vegetation_constants [ \"vel_thres\" ] = json_data_dict [ species ][ \"vel_thres\" ] vegetation_constants [ \"vel_slope\" ] = json_data_dict [ species ][ \"vel_slope\" ] vegetation_constants [ \"maxH_winter\" ] = json_data_dict [ species ][ \"maxH_winter\" ]","title":"set_constants_from_default_json()"},{"location":"reference/biota_models/vegetation/vegetation_model/#utils","text":"","title":"Utils"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_lifestages.LifeStages","text":"Bases: ExtraModel Source code in src/biota_models/vegetation/model/veg_lifestages.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class LifeStages ( ExtraModel ): def __init__ ( self , ls , constants ): super () . __init__ () self . ls = ls self . constants = constants veg_height : VegAttribute = None # vegetation height [m] stem_dia : VegAttribute = None # stem diameter [m] root_len : VegAttribute = None # root length [m] veg_age : VegAttribute = None # vegetation life stage (0 or 1 or more), number defined in Constants.num_ls veg_frac : VegAttribute = None # vegetation age [yrs] stem_num : VegAttribute = None # number of stems cover : VegAttribute = None # vegetation fraction of all ages dt_height : VegAttribute = list () dt_root : VegAttribute = list () dt_stemdia : VegAttribute = list () winter : VegAttribute = False def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Characteristics( { self . veg_height } , { self . stem_dia } , { self . root_len } , { self . veg_age } , { self . stem_num } , { self . cover } )\" def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Vegetation characteristics with: veg_height = { self . veg_height } m; stem_dia = { self . stem_dia } m; veg_root = { self . root_len } m; veg_age = { self . veg_age } days; stem_num = { self . stem_num } ; \" f \"cover = { self . cover } \" ) # # @validator(\"veg_height\", \"stem_dia\", \"root_len\", \"stem_num\", \"cover\") # @classmethod # def validate_vegetation_attribute( # cls, value: Optional[VegAttribute] # ) -> Optional[np.ndarray]: # if value is None: # return value # return DataReshape.variable2array(value) # @property # def height_matrix(self): # \"\"\"self.RESHAPEd vegetation height.\"\"\" # return RESHAPE().variable2matrix(self.veg_height, \"space\") # # @property # def dia_matrix(self): # \"\"\"self.RESHAPEd stem diameter.\"\"\" # return RESHAPE().variable2matrix(self.stem_dia, \"space\") # # @property # def root_matrix(self): # \"\"\"self.RESHAPEd root length.\"\"\" # return RESHAPE().variable2matrix(self.root_len, \"space\") # # @property # def stemNum_matrix(self): # \"\"\"self.RESHAPEd vegetation age.\"\"\" # return RESHAPE().variable2matrix(self.stem_num, \"space\") def initiate_vegetation_characteristics ( self ): _reshape = RESHAPE () # intialization of the vegetation with initial values ## TODO change this for other input cases with initial cover! self . veg_frac = np . zeros ( _reshape . space ) self . veg_frac = self . veg_frac . reshape ( len ( self . veg_frac ), 1 ) self . veg_height = np . zeros ( self . veg_frac . shape ) self . stem_dia = np . zeros ( self . veg_frac . shape ) self . root_len = np . zeros ( self . veg_frac . shape ) self . stem_num = np . zeros ( self . veg_frac . shape ) self . cover = np . zeros ( self . veg_frac . shape ) self . veg_age = np . zeros ( self . veg_frac . shape ) i = self . ls - 1 self . dt_height = np . zeros (( 2 , 1 )) growth_duration = int ( ( self . constants . get_duration ( self . constants . growth_start , self . constants . growth_end ) ) . days ) if self . ls == 0 : pass elif self . constants . num_ls < self . ls : pass elif self . ls == 1 : self . dt_height [ 0 ] = ( self . constants . maxGrowth_H [ i ] - self . constants . iniShoot ) / growth_duration self . dt_height [ 1 ] = ( self . constants . maxGrowth_H [ i ] - self . constants . maxH_winter [ i ] ) / growth_duration self . dt_stemdia = ( self . constants . maxDia [ i ] - self . constants . iniDia ) / ( growth_duration * self . constants . maxYears_LS [ i ] ) self . dt_root = ( self . constants . maxRoot [ i ] - self . constants . iniRoot ) / ( growth_duration * self . constants . maxYears_LS [ i ] ) elif self . ls > 1 : self . dt_height [ 0 ] = ( self . constants . maxGrowth_H [ i ] - self . constants . maxH_winter [ i ] ) / growth_duration # growth per day of growing season self . dt_stemdia = ( self . constants . maxDia [ i ] - self . constants . maxDia [ i - 1 ] ) / ( growth_duration * self . constants . maxYears_LS [ i ]) self . dt_root = ( self . constants . maxRoot [ i ] - self . constants . maxRoot [ i - 1 ] ) / ( growth_duration * self . constants . maxYears_LS [ i ]) def update_growth ( self , veg_frac , period , begin_date , end_date ): \"\"\" update vegetation characteristics based on the vegetation age and fraction of veg in each cell (veg_frac_age) \"\"\" if self . constants . num_ls < self . ls : pass else : winter_start = pd . to_datetime ( self . constants . winter_start ) . replace ( year = begin_date . year ) start_growth = pd . to_datetime ( self . constants . growth_start ) . replace ( year = begin_date . year ) end_growth = pd . to_datetime ( self . constants . growth_end ) . replace ( year = begin_date . year ) a = start_growth <= pd . to_datetime ( period ) b = pd . to_datetime ( period ) <= end_growth c = np . nonzero (( a == True ) & ( b == True )) growth_days = len ( c [ 0 ]) if begin_date <= winter_start <= end_date : self . winter = True self . veg_height [ veg_frac == 0 ] = 0 # delete vegetation which died self . veg_height [ self . constants . maxH_winter [ self . ls - 1 ] < self . veg_height ] = self . constants . maxH_winter [ self . ls - 1 ] # change the height for all the vegetation which i biger than max_height_winter to max_height_winter else : self . winter = False self . veg_height [ veg_frac > 0 ] = self . veg_height [ veg_frac > 0 ] + ( self . dt_height [ 0 ] * growth_days ) self . veg_height [ veg_frac == 0 ] = 0 self . stem_dia [ veg_frac > 0 ] = self . stem_dia [ veg_frac > 0 ] + ( self . dt_stemdia * growth_days ) self . stem_dia [ veg_frac == 0 ] = 0 self . root_len [ veg_frac > 0 ] = self . root_len [ veg_frac > 0 ] + ( self . dt_root * growth_days ) self . root_len [ veg_frac == 0 ] = 0 self . stem_num [ veg_frac > 0 ] = self . constants . num_stem [ self . ls - 1 ] self . stem_num [ veg_frac == 0 ] = 0 self . veg_age [ veg_frac > 0 ] = ( self . veg_age [ veg_frac > 0 ] + self . constants . ets_duration ) self . veg_age [ veg_frac == 0 ] = 0 self . cover = veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 )","title":"LifeStages"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_lifestages.LifeStages.__repr__","text":"Development representation. Source code in src/biota_models/vegetation/model/veg_lifestages.py 32 33 34 def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Characteristics( { self . veg_height } , { self . stem_dia } , { self . root_len } , { self . veg_age } , { self . stem_num } , { self . cover } )\"","title":"__repr__()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_lifestages.LifeStages.__str__","text":"Print representation. Source code in src/biota_models/vegetation/model/veg_lifestages.py 36 37 38 39 40 41 def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Vegetation characteristics with: veg_height = { self . veg_height } m; stem_dia = { self . stem_dia } m; veg_root = { self . root_len } m; veg_age = { self . veg_age } days; stem_num = { self . stem_num } ; \" f \"cover = { self . cover } \" )","title":"__str__()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_lifestages.LifeStages.update_growth","text":"update vegetation characteristics based on the vegetation age and fraction of veg in each cell (veg_frac_age) Source code in src/biota_models/vegetation/model/veg_lifestages.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def update_growth ( self , veg_frac , period , begin_date , end_date ): \"\"\" update vegetation characteristics based on the vegetation age and fraction of veg in each cell (veg_frac_age) \"\"\" if self . constants . num_ls < self . ls : pass else : winter_start = pd . to_datetime ( self . constants . winter_start ) . replace ( year = begin_date . year ) start_growth = pd . to_datetime ( self . constants . growth_start ) . replace ( year = begin_date . year ) end_growth = pd . to_datetime ( self . constants . growth_end ) . replace ( year = begin_date . year ) a = start_growth <= pd . to_datetime ( period ) b = pd . to_datetime ( period ) <= end_growth c = np . nonzero (( a == True ) & ( b == True )) growth_days = len ( c [ 0 ]) if begin_date <= winter_start <= end_date : self . winter = True self . veg_height [ veg_frac == 0 ] = 0 # delete vegetation which died self . veg_height [ self . constants . maxH_winter [ self . ls - 1 ] < self . veg_height ] = self . constants . maxH_winter [ self . ls - 1 ] # change the height for all the vegetation which i biger than max_height_winter to max_height_winter else : self . winter = False self . veg_height [ veg_frac > 0 ] = self . veg_height [ veg_frac > 0 ] + ( self . dt_height [ 0 ] * growth_days ) self . veg_height [ veg_frac == 0 ] = 0 self . stem_dia [ veg_frac > 0 ] = self . stem_dia [ veg_frac > 0 ] + ( self . dt_stemdia * growth_days ) self . stem_dia [ veg_frac == 0 ] = 0 self . root_len [ veg_frac > 0 ] = self . root_len [ veg_frac > 0 ] + ( self . dt_root * growth_days ) self . root_len [ veg_frac == 0 ] = 0 self . stem_num [ veg_frac > 0 ] = self . constants . num_stem [ self . ls - 1 ] self . stem_num [ veg_frac == 0 ] = 0 self . veg_age [ veg_frac > 0 ] = ( self . veg_age [ veg_frac > 0 ] + self . constants . ets_duration ) self . veg_age [ veg_frac == 0 ] = 0 self . cover = veg_frac . sum ( axis = 1 ) . reshape ( - 1 , 1 )","title":"update_growth()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_only.VegOnly","text":"Execute functions only in the presence of vegetation. Source code in src/biota_models/vegetation/model/veg_only.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class VegOnly : \"\"\"Execute functions only in the presence of vegetation.\"\"\" spacetime = None @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ] @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ] def in_space ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is vegetation cover. Args: veg (Vegetation): Vegetation object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of vegetation cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the vegetation function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output def in_spacetime ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is vegetation cover. :param veg: vegetation object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of vegetation cover :type veg: Vegetation :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == veg . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output","title":"VegOnly"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_only.VegOnly.in_space","text":"Only execute the function when there is vegetation cover. Parameters: Name Type Description Default veg Vegetation Vegetation object. required function Callable Function to be executed. required args Tuple input arguments of the function. required no_cover_value Optional [ float ] Default value in absence of vegetation cover. Defaults to 0. 0 Raises: Type Description ValueError When sizes do not match. Returns: Type Description np . ndarray np.ndarray: Result of the vegetation function. Source code in src/biota_models/vegetation/model/veg_only.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def in_space ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is vegetation cover. Args: veg (Vegetation): Vegetation object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of vegetation cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the vegetation function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output","title":"in_space()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_only.VegOnly.in_spacetime","text":"Only execute the function when there is vegetation cover. :param veg: vegetation object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of vegetation cover :type veg: Vegetation :type args: tuple :type no_cover_value: float, optional Source code in src/biota_models/vegetation/model/veg_only.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def in_spacetime ( self , veg , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is vegetation cover. :param veg: vegetation object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of vegetation cover :type veg: Vegetation :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == veg . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ veg . cover > 0 ] = function ( * [ arg [ veg . cover > 0 ] for arg in args ]) return output","title":"in_spacetime()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_only.VegOnly.space","text":"Space dimension. Source code in src/biota_models/vegetation/model/veg_only.py 11 12 13 14 @property def space ( self ): \"\"\"Space dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 0 ]","title":"space()"},{"location":"reference/biota_models/vegetation/vegetation_model/#src.biota_models.vegetation.model.veg_only.VegOnly.time","text":"Time dimension. Source code in src/biota_models/vegetation/model/veg_only.py 16 17 18 19 @property def time ( self ): \"\"\"Time dimension.\"\"\" return None if self . spacetime is None else self . spacetime [ 1 ]","title":"time()"},{"location":"reference/biota_models/vegetation/vegetation_output/","text":"Output classes for the NBSDynamics vegetation model. \u00b6 Wrapper \u00b6 VegOutputWrapper \u00b6 Bases: BaseOutputWrapper Output files based on predefined output content. Generate output files of VegetationModel simulation. Output files are formatted as NetCDF4-files. Source code in src/biota_models/vegetation/output/veg_output_wrapper.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class VegOutputWrapper ( BaseOutputWrapper ): \"\"\" Output files based on predefined output content. Generate output files of VegetationModel simulation. Output files are formatted as NetCDF4-files. \"\"\" # Output models. map_output : Optional [ VegetationMapOutput ] his_output : Optional [ VegetationHisOutput ] def initialize ( self , veg_model : Vegetation ): \"\"\" Initializes all available output models (His and Map). Args: veg_model (Vegetation): Vegetation model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( veg_model ) self . map_output . initialize ( veg_model ) initialize ( veg_model : Vegetation ) \u00b6 Initializes all available output models (His and Map). Parameters: Name Type Description Default veg_model Vegetation Vegetation model to be used in the output. required Source code in src/biota_models/vegetation/output/veg_output_wrapper.py 21 22 23 24 25 26 27 28 29 30 31 32 33 def initialize ( self , veg_model : Vegetation ): \"\"\" Initializes all available output models (His and Map). Args: veg_model (Vegetation): Vegetation model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( veg_model ) self . map_output . initialize ( veg_model ) Output models \u00b6 VegetationHisOutput \u00b6 Bases: _VegetationOutput Object representing a His output. Implements the 'OutputProtocol'. Source code in src/biota_models/vegetation/output/veg_output_model.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 class VegetationHisOutput ( _VegetationOutput ): \"\"\" Object representing a His output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"VegModel_his.nc\" xy_stations : Optional [ np . ndarray ] idx_stations : Optional [ np . ndarray ] first_date : Optional [ Union [ np . datetime64 , datetime ]] def initialize ( self , veg : Vegetation ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" self . output_filename = \"VegModel_\" + veg . species + \"_his.nc\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the VegetaionModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_hydro_mor (): max_tau = _his_data . createVariable ( \"max_tau\" , \"f8\" , ( \"time\" , \"stations\" ) ) max_tau . long_name = \"maximum bed shear stress\" max_tau . units = \"N/m^2\" max_tau [:, :] = 0 max_u = _his_data . createVariable ( \"max_u\" , \"f8\" , ( \"time\" , \"stations\" )) max_u . long_name = \"maximum flow velocity\" max_u . units = \"m/s\" max_u [:, :] = 0 max_wl = _his_data . createVariable ( \"max_wl\" , \"f8\" , ( \"time\" , \"stations\" )) max_wl . long_name = \"maximum water level\" max_wl . units = \"m\" max_wl [:, :] = 0 min_wl = _his_data . createVariable ( \"min_wl\" , \"f8\" , ( \"time\" , \"stations\" )) min_wl . long_name = \"minimum water level\" min_wl . units = \"m\" min_wl [:, :] = 0 bl = _his_data . createVariable ( \"bl\" , \"f8\" , ( \"time\" , \"stations\" )) bl . long_name = \"bedlevel\" bl . units = \"m\" bl [:, :] = 0 def init_veg_characteristics (): cover = _his_data . createVariable ( \"cover\" , \"f8\" , ( \"time\" , \"stations\" )) cover . long_name = \"sum of fraction coverage in each cell (for all ages)\" cover . units = \"-\" cover [ :, : ] = veg . total_cover # could be =veg.cover if there is an initial one height = _his_data . createVariable ( \"height\" , \"f8\" , ( \"time\" , \"stations\" )) height . long_name = \"vegetation height\" height . units = \"m\" height [:, :] = 0 diaveg = _his_data . createVariable ( \"diaveg\" , \"f8\" , ( \"time\" , \"stations\" )) diaveg . long_name = \"stem diameter\" diaveg . units = \"m\" diaveg [:, :] = 0 rnveg = _his_data . createVariable ( \"rnveg\" , \"f8\" , ( \"time\" , \"stations\" )) rnveg . long_name = \"vegetation density\" diaveg . units = \"1/m2\" diaveg [:, :] = 0 veg_frac_j = _his_data . createVariable ( \"veg_frac_j\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_j . long_name = ( \"Vegetation fraction in each growth day for juvenile\" ) veg_frac_j . units = \"-\" veg_frac_j [:, :] = 0 veg_frac_m = _his_data . createVariable ( \"veg_frac_m\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_m . long_name = ( \"Vegetation fraction in each growth day for mature\" ) veg_frac_m . units = \"-\" veg_frac_m [:, :] = 0 conditions_funct = dict ( hydro_mor = init_hydro_mor , veg_characteristics = init_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , veg : Vegetation , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param vegetation: Vegetation :param dates: dates of simulation year :type vegetation: Vegetation :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = (( y_dates - self . first_date ) . squeeze ()) . dt . days . values _his_data [ \"time\" ][ ti [:]] = y_dates . values def update_hydro_mor (): _his_data [ \"max_tau\" ][ ti , :] = np . tile ( veg . max_tau , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_u\" ][ ti , :] = np . tile ( veg . max_u , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_wl\" ][ ti , :] = np . tile ( veg . max_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"min_wl\" ][ ti , :] = np . tile ( veg . min_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bl\" ][ ti , :] = np . tile ( veg . bl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_veg_characteristics (): _his_data [ \"cover\" ][ ti , :] = np . tile ( veg . total_cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"height\" ][ ti , :] = np . tile ( veg . av_height . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"diaveg\" ][ ti , :] = np . tile ( veg . av_stemdia . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"rnveg\" ][ ti , :] = np . tile ( veg . veg_den . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_j\" ][ ti , :] = np . tile ( veg . juvenile . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_m\" ][ ti , :] = np . tile ( veg . mature . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () initialize ( veg : Vegetation ) \u00b6 Initiate history output file in which daily output at predefined locations within the model is stored. Source code in src/biota_models/vegetation/output/veg_output_model.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def initialize ( self , veg : Vegetation ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" self . output_filename = \"VegModel_\" + veg . species + \"_his.nc\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the VegetaionModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_hydro_mor (): max_tau = _his_data . createVariable ( \"max_tau\" , \"f8\" , ( \"time\" , \"stations\" ) ) max_tau . long_name = \"maximum bed shear stress\" max_tau . units = \"N/m^2\" max_tau [:, :] = 0 max_u = _his_data . createVariable ( \"max_u\" , \"f8\" , ( \"time\" , \"stations\" )) max_u . long_name = \"maximum flow velocity\" max_u . units = \"m/s\" max_u [:, :] = 0 max_wl = _his_data . createVariable ( \"max_wl\" , \"f8\" , ( \"time\" , \"stations\" )) max_wl . long_name = \"maximum water level\" max_wl . units = \"m\" max_wl [:, :] = 0 min_wl = _his_data . createVariable ( \"min_wl\" , \"f8\" , ( \"time\" , \"stations\" )) min_wl . long_name = \"minimum water level\" min_wl . units = \"m\" min_wl [:, :] = 0 bl = _his_data . createVariable ( \"bl\" , \"f8\" , ( \"time\" , \"stations\" )) bl . long_name = \"bedlevel\" bl . units = \"m\" bl [:, :] = 0 def init_veg_characteristics (): cover = _his_data . createVariable ( \"cover\" , \"f8\" , ( \"time\" , \"stations\" )) cover . long_name = \"sum of fraction coverage in each cell (for all ages)\" cover . units = \"-\" cover [ :, : ] = veg . total_cover # could be =veg.cover if there is an initial one height = _his_data . createVariable ( \"height\" , \"f8\" , ( \"time\" , \"stations\" )) height . long_name = \"vegetation height\" height . units = \"m\" height [:, :] = 0 diaveg = _his_data . createVariable ( \"diaveg\" , \"f8\" , ( \"time\" , \"stations\" )) diaveg . long_name = \"stem diameter\" diaveg . units = \"m\" diaveg [:, :] = 0 rnveg = _his_data . createVariable ( \"rnveg\" , \"f8\" , ( \"time\" , \"stations\" )) rnveg . long_name = \"vegetation density\" diaveg . units = \"1/m2\" diaveg [:, :] = 0 veg_frac_j = _his_data . createVariable ( \"veg_frac_j\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_j . long_name = ( \"Vegetation fraction in each growth day for juvenile\" ) veg_frac_j . units = \"-\" veg_frac_j [:, :] = 0 veg_frac_m = _his_data . createVariable ( \"veg_frac_m\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_m . long_name = ( \"Vegetation fraction in each growth day for mature\" ) veg_frac_m . units = \"-\" veg_frac_m [:, :] = 0 conditions_funct = dict ( hydro_mor = init_hydro_mor , veg_characteristics = init_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () update ( veg : Vegetation , dates : DataFrame ) \u00b6 Write data as daily output at predefined locations within the model domain. :param vegetation: Vegetation :param dates: dates of simulation year :type vegetation: Vegetation :type dates: DataFrame Source code in src/biota_models/vegetation/output/veg_output_model.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def update ( self , veg : Vegetation , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param vegetation: Vegetation :param dates: dates of simulation year :type vegetation: Vegetation :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = (( y_dates - self . first_date ) . squeeze ()) . dt . days . values _his_data [ \"time\" ][ ti [:]] = y_dates . values def update_hydro_mor (): _his_data [ \"max_tau\" ][ ti , :] = np . tile ( veg . max_tau , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_u\" ][ ti , :] = np . tile ( veg . max_u , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_wl\" ][ ti , :] = np . tile ( veg . max_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"min_wl\" ][ ti , :] = np . tile ( veg . min_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bl\" ][ ti , :] = np . tile ( veg . bl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_veg_characteristics (): _his_data [ \"cover\" ][ ti , :] = np . tile ( veg . total_cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"height\" ][ ti , :] = np . tile ( veg . av_height . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"diaveg\" ][ ti , :] = np . tile ( veg . av_stemdia . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"rnveg\" ][ ti , :] = np . tile ( veg . veg_den . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_j\" ][ ti , :] = np . tile ( veg . juvenile . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_m\" ][ ti , :] = np . tile ( veg . mature . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () VegetationMapOutput \u00b6 Bases: _VegetationOutput Object representing a Map output. Implements the 'OutputProtocol'. Source code in src/biota_models/vegetation/output/veg_output_model.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 class VegetationMapOutput ( _VegetationOutput ): \"\"\" Object representing a Map output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"VegModel_map.nc\" xy_coordinates : Optional [ np . ndarray ] first_year : Optional [ int ] @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates ) def initialize ( self , vegetation : Optional [ Vegetation ]): self . output_filename = \"VegModel_\" + vegetation . species + \"_map.nc\" \"\"\"Initiate mapping output file in which output covering the whole model domain is stored every period of running.\"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the VegetationModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) _map_data . createDimension ( \"age\" , None ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"period\" t . units = \"period\" age = _map_data . createVariable ( \"age\" , int , ( \"age\" )) age . long_name = \"vegetation age\" age . units = \"days\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" # t[:] = self.first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_hydro_mor (): max_tau = _map_data . createVariable ( \"max_tau\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) max_tau . long_name = \"maximum bed shear stress\" max_tau . units = \"N/m^2\" max_tau [:, :] = 0 max_u = _map_data . createVariable ( \"max_u\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) max_u . long_name = \"maximum flow velocity\" max_u . units = \"m/s\" max_u [:, :] = 0 max_wl = _map_data . createVariable ( \"max_wl\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) max_wl . long_name = \"maximum water level\" max_wl . units = \"m\" max_wl [:, :] = 0 min_wl = _map_data . createVariable ( \"min_wl\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) min_wl . long_name = \"minimum water level\" min_wl . units = \"m\" min_wl [:, :] = 0 bl = _map_data . createVariable ( \"bl\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bl . long_name = \"bedlevel\" bl . units = \"m\" bl [:, :] = 0 def init_veg_characteristics (): cover = _map_data . createVariable ( \"cover\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) cover . long_name = \"sum of fraction coverage in each cell (for all ages)\" cover . units = \"-\" cover [:, :] = 0 # could be =veg.cover if there is an initial one height = _map_data . createVariable ( \"height\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) height . long_name = \"vegetation height\" height . units = \"m\" height [:, :] = 0 diaveg = _map_data . createVariable ( \"diaveg\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) diaveg . long_name = \"stem diameter\" diaveg . units = \"m\" diaveg [:, :] = 0 rnveg = _map_data . createVariable ( \"rnveg\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) rnveg . long_name = \"vegetation density\" diaveg . units = \"1/m2\" diaveg [:, :] = 0 veg_frac_j = _map_data . createVariable ( \"veg_frac_j\" , \"f8\" , ( \"nmesh2d_face\" , \"age\" , \"time\" ) ) veg_frac_j . long_name = ( \"Vegetation fraction in each growth day for juvenile\" ) veg_frac_j . units = \"-\" veg_frac_j [:, :, :] = 0 veg_frac_m = _map_data . createVariable ( \"veg_frac_m\" , \"f8\" , ( \"nmesh2d_face\" , \"age\" , \"time\" ) ) veg_frac_m . long_name = ( \"Vegetation fraction in each growth day for mature\" ) veg_frac_m . units = \"-\" veg_frac_m [:, :, :] = 0 conditions_funct = dict ( hydro_mor = init_hydro_mor , veg_characteristics = init_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , veg : Vegetation , end_time : int , ets , year , constants ): \"\"\"Write data every period ran covering the whole model domain. :param veg: Vegetation :param period: based on veg_base_simulation :type veg: Vegetation :type period: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = ets + constants . t_eco_year * year _map_data [ \"time\" ][ i ] = end_time def update_hydro_mor (): _map_data [ \"max_tau\" ][ - 1 , :] = veg . max_tau _map_data [ \"max_u\" ][ - 1 , :] = veg . max_u _map_data [ \"max_wl\" ][ - 1 , :] = veg . max_wl _map_data [ \"min_wl\" ][ - 1 , :] = veg . min_wl _map_data [ \"bl\" ][ - 1 , :] = veg . bl def update_veg_characteristics (): _map_data [ \"cover\" ][ - 1 , :] = veg . total_cover . transpose () _map_data [ \"height\" ][ - 1 , :] = veg . av_height . transpose () _map_data [ \"diaveg\" ][ - 1 , :] = veg . av_stemdia . transpose () _map_data [ \"rnveg\" ][ - 1 , :] = veg . veg_den . transpose () _map_data [ \"veg_frac_j\" ][:, :, - 1 ] = veg . juvenile . veg_frac [:, :] _map_data [ \"veg_frac_m\" ][:, :, - 1 ] = veg . mature . veg_frac [:, :] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () space () -> int property \u00b6 Gets the total space for the model-defined xy-coordinates. Returns: Name Type Description int int length of 'xy_coordinates'. Source code in src/biota_models/vegetation/output/veg_output_model.py 35 36 37 38 39 40 41 42 43 @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates ) update ( veg : Vegetation , end_time : int , ets , year , constants ) \u00b6 Write data every period ran covering the whole model domain. :param veg: Vegetation :param period: based on veg_base_simulation :type veg: Vegetation :type period: int Source code in src/biota_models/vegetation/output/veg_output_model.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def update ( self , veg : Vegetation , end_time : int , ets , year , constants ): \"\"\"Write data every period ran covering the whole model domain. :param veg: Vegetation :param period: based on veg_base_simulation :type veg: Vegetation :type period: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = ets + constants . t_eco_year * year _map_data [ \"time\" ][ i ] = end_time def update_hydro_mor (): _map_data [ \"max_tau\" ][ - 1 , :] = veg . max_tau _map_data [ \"max_u\" ][ - 1 , :] = veg . max_u _map_data [ \"max_wl\" ][ - 1 , :] = veg . max_wl _map_data [ \"min_wl\" ][ - 1 , :] = veg . min_wl _map_data [ \"bl\" ][ - 1 , :] = veg . bl def update_veg_characteristics (): _map_data [ \"cover\" ][ - 1 , :] = veg . total_cover . transpose () _map_data [ \"height\" ][ - 1 , :] = veg . av_height . transpose () _map_data [ \"diaveg\" ][ - 1 , :] = veg . av_stemdia . transpose () _map_data [ \"rnveg\" ][ - 1 , :] = veg . veg_den . transpose () _map_data [ \"veg_frac_j\" ][:, :, - 1 ] = veg . juvenile . veg_frac [:, :] _map_data [ \"veg_frac_m\" ][:, :, - 1 ] = veg . mature . veg_frac [:, :] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"Vegetation output"},{"location":"reference/biota_models/vegetation/vegetation_output/#output-classes-for-the-nbsdynamics-vegetation-model","text":"","title":"Output classes for the NBSDynamics vegetation model."},{"location":"reference/biota_models/vegetation/vegetation_output/#wrapper","text":"","title":"Wrapper"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_wrapper.VegOutputWrapper","text":"Bases: BaseOutputWrapper Output files based on predefined output content. Generate output files of VegetationModel simulation. Output files are formatted as NetCDF4-files. Source code in src/biota_models/vegetation/output/veg_output_wrapper.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class VegOutputWrapper ( BaseOutputWrapper ): \"\"\" Output files based on predefined output content. Generate output files of VegetationModel simulation. Output files are formatted as NetCDF4-files. \"\"\" # Output models. map_output : Optional [ VegetationMapOutput ] his_output : Optional [ VegetationHisOutput ] def initialize ( self , veg_model : Vegetation ): \"\"\" Initializes all available output models (His and Map). Args: veg_model (Vegetation): Vegetation model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( veg_model ) self . map_output . initialize ( veg_model )","title":"VegOutputWrapper"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_wrapper.VegOutputWrapper.initialize","text":"Initializes all available output models (His and Map). Parameters: Name Type Description Default veg_model Vegetation Vegetation model to be used in the output. required Source code in src/biota_models/vegetation/output/veg_output_wrapper.py 21 22 23 24 25 26 27 28 29 30 31 32 33 def initialize ( self , veg_model : Vegetation ): \"\"\" Initializes all available output models (His and Map). Args: veg_model (Vegetation): Vegetation model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( veg_model ) self . map_output . initialize ( veg_model )","title":"initialize()"},{"location":"reference/biota_models/vegetation/vegetation_output/#output-models","text":"","title":"Output models"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_model.VegetationHisOutput","text":"Bases: _VegetationOutput Object representing a His output. Implements the 'OutputProtocol'. Source code in src/biota_models/vegetation/output/veg_output_model.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 class VegetationHisOutput ( _VegetationOutput ): \"\"\" Object representing a His output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"VegModel_his.nc\" xy_stations : Optional [ np . ndarray ] idx_stations : Optional [ np . ndarray ] first_date : Optional [ Union [ np . datetime64 , datetime ]] def initialize ( self , veg : Vegetation ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" self . output_filename = \"VegModel_\" + veg . species + \"_his.nc\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the VegetaionModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_hydro_mor (): max_tau = _his_data . createVariable ( \"max_tau\" , \"f8\" , ( \"time\" , \"stations\" ) ) max_tau . long_name = \"maximum bed shear stress\" max_tau . units = \"N/m^2\" max_tau [:, :] = 0 max_u = _his_data . createVariable ( \"max_u\" , \"f8\" , ( \"time\" , \"stations\" )) max_u . long_name = \"maximum flow velocity\" max_u . units = \"m/s\" max_u [:, :] = 0 max_wl = _his_data . createVariable ( \"max_wl\" , \"f8\" , ( \"time\" , \"stations\" )) max_wl . long_name = \"maximum water level\" max_wl . units = \"m\" max_wl [:, :] = 0 min_wl = _his_data . createVariable ( \"min_wl\" , \"f8\" , ( \"time\" , \"stations\" )) min_wl . long_name = \"minimum water level\" min_wl . units = \"m\" min_wl [:, :] = 0 bl = _his_data . createVariable ( \"bl\" , \"f8\" , ( \"time\" , \"stations\" )) bl . long_name = \"bedlevel\" bl . units = \"m\" bl [:, :] = 0 def init_veg_characteristics (): cover = _his_data . createVariable ( \"cover\" , \"f8\" , ( \"time\" , \"stations\" )) cover . long_name = \"sum of fraction coverage in each cell (for all ages)\" cover . units = \"-\" cover [ :, : ] = veg . total_cover # could be =veg.cover if there is an initial one height = _his_data . createVariable ( \"height\" , \"f8\" , ( \"time\" , \"stations\" )) height . long_name = \"vegetation height\" height . units = \"m\" height [:, :] = 0 diaveg = _his_data . createVariable ( \"diaveg\" , \"f8\" , ( \"time\" , \"stations\" )) diaveg . long_name = \"stem diameter\" diaveg . units = \"m\" diaveg [:, :] = 0 rnveg = _his_data . createVariable ( \"rnveg\" , \"f8\" , ( \"time\" , \"stations\" )) rnveg . long_name = \"vegetation density\" diaveg . units = \"1/m2\" diaveg [:, :] = 0 veg_frac_j = _his_data . createVariable ( \"veg_frac_j\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_j . long_name = ( \"Vegetation fraction in each growth day for juvenile\" ) veg_frac_j . units = \"-\" veg_frac_j [:, :] = 0 veg_frac_m = _his_data . createVariable ( \"veg_frac_m\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_m . long_name = ( \"Vegetation fraction in each growth day for mature\" ) veg_frac_m . units = \"-\" veg_frac_m [:, :] = 0 conditions_funct = dict ( hydro_mor = init_hydro_mor , veg_characteristics = init_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , veg : Vegetation , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param vegetation: Vegetation :param dates: dates of simulation year :type vegetation: Vegetation :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = (( y_dates - self . first_date ) . squeeze ()) . dt . days . values _his_data [ \"time\" ][ ti [:]] = y_dates . values def update_hydro_mor (): _his_data [ \"max_tau\" ][ ti , :] = np . tile ( veg . max_tau , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_u\" ][ ti , :] = np . tile ( veg . max_u , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_wl\" ][ ti , :] = np . tile ( veg . max_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"min_wl\" ][ ti , :] = np . tile ( veg . min_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bl\" ][ ti , :] = np . tile ( veg . bl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_veg_characteristics (): _his_data [ \"cover\" ][ ti , :] = np . tile ( veg . total_cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"height\" ][ ti , :] = np . tile ( veg . av_height . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"diaveg\" ][ ti , :] = np . tile ( veg . av_stemdia . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"rnveg\" ][ ti , :] = np . tile ( veg . veg_den . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_j\" ][ ti , :] = np . tile ( veg . juvenile . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_m\" ][ ti , :] = np . tile ( veg . mature . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"VegetationHisOutput"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_model.VegetationHisOutput.initialize","text":"Initiate history output file in which daily output at predefined locations within the model is stored. Source code in src/biota_models/vegetation/output/veg_output_model.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def initialize ( self , veg : Vegetation ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" self . output_filename = \"VegModel_\" + veg . species + \"_his.nc\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the VegetaionModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_hydro_mor (): max_tau = _his_data . createVariable ( \"max_tau\" , \"f8\" , ( \"time\" , \"stations\" ) ) max_tau . long_name = \"maximum bed shear stress\" max_tau . units = \"N/m^2\" max_tau [:, :] = 0 max_u = _his_data . createVariable ( \"max_u\" , \"f8\" , ( \"time\" , \"stations\" )) max_u . long_name = \"maximum flow velocity\" max_u . units = \"m/s\" max_u [:, :] = 0 max_wl = _his_data . createVariable ( \"max_wl\" , \"f8\" , ( \"time\" , \"stations\" )) max_wl . long_name = \"maximum water level\" max_wl . units = \"m\" max_wl [:, :] = 0 min_wl = _his_data . createVariable ( \"min_wl\" , \"f8\" , ( \"time\" , \"stations\" )) min_wl . long_name = \"minimum water level\" min_wl . units = \"m\" min_wl [:, :] = 0 bl = _his_data . createVariable ( \"bl\" , \"f8\" , ( \"time\" , \"stations\" )) bl . long_name = \"bedlevel\" bl . units = \"m\" bl [:, :] = 0 def init_veg_characteristics (): cover = _his_data . createVariable ( \"cover\" , \"f8\" , ( \"time\" , \"stations\" )) cover . long_name = \"sum of fraction coverage in each cell (for all ages)\" cover . units = \"-\" cover [ :, : ] = veg . total_cover # could be =veg.cover if there is an initial one height = _his_data . createVariable ( \"height\" , \"f8\" , ( \"time\" , \"stations\" )) height . long_name = \"vegetation height\" height . units = \"m\" height [:, :] = 0 diaveg = _his_data . createVariable ( \"diaveg\" , \"f8\" , ( \"time\" , \"stations\" )) diaveg . long_name = \"stem diameter\" diaveg . units = \"m\" diaveg [:, :] = 0 rnveg = _his_data . createVariable ( \"rnveg\" , \"f8\" , ( \"time\" , \"stations\" )) rnveg . long_name = \"vegetation density\" diaveg . units = \"1/m2\" diaveg [:, :] = 0 veg_frac_j = _his_data . createVariable ( \"veg_frac_j\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_j . long_name = ( \"Vegetation fraction in each growth day for juvenile\" ) veg_frac_j . units = \"-\" veg_frac_j [:, :] = 0 veg_frac_m = _his_data . createVariable ( \"veg_frac_m\" , \"f8\" , ( \"time\" , \"stations\" ) ) veg_frac_m . long_name = ( \"Vegetation fraction in each growth day for mature\" ) veg_frac_m . units = \"-\" veg_frac_m [:, :] = 0 conditions_funct = dict ( hydro_mor = init_hydro_mor , veg_characteristics = init_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"initialize()"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_model.VegetationHisOutput.update","text":"Write data as daily output at predefined locations within the model domain. :param vegetation: Vegetation :param dates: dates of simulation year :type vegetation: Vegetation :type dates: DataFrame Source code in src/biota_models/vegetation/output/veg_output_model.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def update ( self , veg : Vegetation , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param vegetation: Vegetation :param dates: dates of simulation year :type vegetation: Vegetation :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = (( y_dates - self . first_date ) . squeeze ()) . dt . days . values _his_data [ \"time\" ][ ti [:]] = y_dates . values def update_hydro_mor (): _his_data [ \"max_tau\" ][ ti , :] = np . tile ( veg . max_tau , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_u\" ][ ti , :] = np . tile ( veg . max_u , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"max_wl\" ][ ti , :] = np . tile ( veg . max_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"min_wl\" ][ ti , :] = np . tile ( veg . min_wl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bl\" ][ ti , :] = np . tile ( veg . bl , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_veg_characteristics (): _his_data [ \"cover\" ][ ti , :] = np . tile ( veg . total_cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"height\" ][ ti , :] = np . tile ( veg . av_height . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"diaveg\" ][ ti , :] = np . tile ( veg . av_stemdia . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"rnveg\" ][ ti , :] = np . tile ( veg . veg_den . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_j\" ][ ti , :] = np . tile ( veg . juvenile . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] _his_data [ \"veg_frac_m\" ][ ti , :] = np . tile ( veg . mature . cover . transpose (), ( len ( y_dates ), 1 ) )[:, self . idx_stations ] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"update()"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_model.VegetationMapOutput","text":"Bases: _VegetationOutput Object representing a Map output. Implements the 'OutputProtocol'. Source code in src/biota_models/vegetation/output/veg_output_model.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 class VegetationMapOutput ( _VegetationOutput ): \"\"\" Object representing a Map output. Implements the 'OutputProtocol'. \"\"\" output_filename = \"VegModel_map.nc\" xy_coordinates : Optional [ np . ndarray ] first_year : Optional [ int ] @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates ) def initialize ( self , vegetation : Optional [ Vegetation ]): self . output_filename = \"VegModel_\" + vegetation . species + \"_map.nc\" \"\"\"Initiate mapping output file in which output covering the whole model domain is stored every period of running.\"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the VegetationModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) _map_data . createDimension ( \"age\" , None ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"period\" t . units = \"period\" age = _map_data . createVariable ( \"age\" , int , ( \"age\" )) age . long_name = \"vegetation age\" age . units = \"days\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" # t[:] = self.first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_hydro_mor (): max_tau = _map_data . createVariable ( \"max_tau\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) max_tau . long_name = \"maximum bed shear stress\" max_tau . units = \"N/m^2\" max_tau [:, :] = 0 max_u = _map_data . createVariable ( \"max_u\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) max_u . long_name = \"maximum flow velocity\" max_u . units = \"m/s\" max_u [:, :] = 0 max_wl = _map_data . createVariable ( \"max_wl\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) max_wl . long_name = \"maximum water level\" max_wl . units = \"m\" max_wl [:, :] = 0 min_wl = _map_data . createVariable ( \"min_wl\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) min_wl . long_name = \"minimum water level\" min_wl . units = \"m\" min_wl [:, :] = 0 bl = _map_data . createVariable ( \"bl\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bl . long_name = \"bedlevel\" bl . units = \"m\" bl [:, :] = 0 def init_veg_characteristics (): cover = _map_data . createVariable ( \"cover\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) cover . long_name = \"sum of fraction coverage in each cell (for all ages)\" cover . units = \"-\" cover [:, :] = 0 # could be =veg.cover if there is an initial one height = _map_data . createVariable ( \"height\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) height . long_name = \"vegetation height\" height . units = \"m\" height [:, :] = 0 diaveg = _map_data . createVariable ( \"diaveg\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) diaveg . long_name = \"stem diameter\" diaveg . units = \"m\" diaveg [:, :] = 0 rnveg = _map_data . createVariable ( \"rnveg\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) rnveg . long_name = \"vegetation density\" diaveg . units = \"1/m2\" diaveg [:, :] = 0 veg_frac_j = _map_data . createVariable ( \"veg_frac_j\" , \"f8\" , ( \"nmesh2d_face\" , \"age\" , \"time\" ) ) veg_frac_j . long_name = ( \"Vegetation fraction in each growth day for juvenile\" ) veg_frac_j . units = \"-\" veg_frac_j [:, :, :] = 0 veg_frac_m = _map_data . createVariable ( \"veg_frac_m\" , \"f8\" , ( \"nmesh2d_face\" , \"age\" , \"time\" ) ) veg_frac_m . long_name = ( \"Vegetation fraction in each growth day for mature\" ) veg_frac_m . units = \"-\" veg_frac_m [:, :, :] = 0 conditions_funct = dict ( hydro_mor = init_hydro_mor , veg_characteristics = init_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () def update ( self , veg : Vegetation , end_time : int , ets , year , constants ): \"\"\"Write data every period ran covering the whole model domain. :param veg: Vegetation :param period: based on veg_base_simulation :type veg: Vegetation :type period: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = ets + constants . t_eco_year * year _map_data [ \"time\" ][ i ] = end_time def update_hydro_mor (): _map_data [ \"max_tau\" ][ - 1 , :] = veg . max_tau _map_data [ \"max_u\" ][ - 1 , :] = veg . max_u _map_data [ \"max_wl\" ][ - 1 , :] = veg . max_wl _map_data [ \"min_wl\" ][ - 1 , :] = veg . min_wl _map_data [ \"bl\" ][ - 1 , :] = veg . bl def update_veg_characteristics (): _map_data [ \"cover\" ][ - 1 , :] = veg . total_cover . transpose () _map_data [ \"height\" ][ - 1 , :] = veg . av_height . transpose () _map_data [ \"diaveg\" ][ - 1 , :] = veg . av_stemdia . transpose () _map_data [ \"rnveg\" ][ - 1 , :] = veg . veg_den . transpose () _map_data [ \"veg_frac_j\" ][:, :, - 1 ] = veg . juvenile . veg_frac [:, :] _map_data [ \"veg_frac_m\" ][:, :, - 1 ] = veg . mature . veg_frac [:, :] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"VegetationMapOutput"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_model.VegetationMapOutput.space","text":"Gets the total space for the model-defined xy-coordinates. Returns: Name Type Description int int length of 'xy_coordinates'. Source code in src/biota_models/vegetation/output/veg_output_model.py 35 36 37 38 39 40 41 42 43 @property def space ( self ) -> int : \"\"\" Gets the total space for the model-defined xy-coordinates. Returns: int: length of 'xy_coordinates'. \"\"\" return len ( self . xy_coordinates )","title":"space()"},{"location":"reference/biota_models/vegetation/vegetation_output/#src.biota_models.vegetation.output.veg_output_model.VegetationMapOutput.update","text":"Write data every period ran covering the whole model domain. :param veg: Vegetation :param period: based on veg_base_simulation :type veg: Vegetation :type period: int Source code in src/biota_models/vegetation/output/veg_output_model.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def update ( self , veg : Vegetation , end_time : int , ets , year , constants ): \"\"\"Write data every period ran covering the whole model domain. :param veg: Vegetation :param period: based on veg_base_simulation :type veg: Vegetation :type period: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = ets + constants . t_eco_year * year _map_data [ \"time\" ][ i ] = end_time def update_hydro_mor (): _map_data [ \"max_tau\" ][ - 1 , :] = veg . max_tau _map_data [ \"max_u\" ][ - 1 , :] = veg . max_u _map_data [ \"max_wl\" ][ - 1 , :] = veg . max_wl _map_data [ \"min_wl\" ][ - 1 , :] = veg . min_wl _map_data [ \"bl\" ][ - 1 , :] = veg . bl def update_veg_characteristics (): _map_data [ \"cover\" ][ - 1 , :] = veg . total_cover . transpose () _map_data [ \"height\" ][ - 1 , :] = veg . av_height . transpose () _map_data [ \"diaveg\" ][ - 1 , :] = veg . av_stemdia . transpose () _map_data [ \"rnveg\" ][ - 1 , :] = veg . veg_den . transpose () _map_data [ \"veg_frac_j\" ][:, :, - 1 ] = veg . juvenile . veg_frac [:, :] _map_data [ \"veg_frac_m\" ][:, :, - 1 ] = veg . mature . veg_frac [:, :] conditions_funct = dict ( hydro_mor = update_hydro_mor , veg_characteristics = update_veg_characteristics , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"update()"},{"location":"reference/biota_models/vegetation/vegetation_processes/","text":"Biophysical processes \u00b6 Colonisation \u00b6 Colonization \u00b6 Bases: ExtraModel Colonization Colonization depends on ColMethod (Colonisation method (1 = on bare substrate between max and min water levels, 2 = on bare substrate with mud content) 1. inundation (max, min water level, flooded only in max waterlevel: intertidal area) 2. mud fraction in top layer: mud_frac>mud_colonization (NOT YET FULLY IMPLEMENTED!) Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class Colonization ( ExtraModel ): \"\"\" Colonization Colonization depends on ColMethod (Colonisation method (1 = on bare substrate between max and min water levels, 2 = on bare substrate with mud content) 1. inundation (max, min water level, flooded only in max waterlevel: intertidal area) 2. mud fraction in top layer: mud_frac>mud_colonization (NOT YET FULLY IMPLEMENTED!) \"\"\" cir : Optional [ np . ndarray ] ma : Optional [ np . ndarray ] seed_loc : Optional [ np . ndarray ] seed_loc1 : Optional [ np . ndarray ] seed_loc2 : Optional [ np . ndarray ] def update ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ]): \"\"\"Update marsh cover after colonization (settlement) if two vegetation objects are given (different species), they will compete for space when they colonize :param veg: vegetation :type vegetation: Vegetation \"\"\" if not veg_species2 : # # available locations for settlement Colonization . col_location ( self , veg_species1 ) loc = veg_species1 . initial . veg_frac [ self . seed_loc ] loc [ veg_species1 . total_cover [ self . seed_loc ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_frac [ self . seed_loc ] = ( loc * veg_species1 . constants . iniCol_frac ) veg_species1 . initial . veg_height [ self . seed_loc ] = ( loc * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc ] = ( loc * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc ] = ( loc * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc ] = ( loc * veg_species1 . constants . num_stem [ 0 ] ) # TODO test this! else : total_cover = veg_species1 . total_cover + veg_species2 . total_cover Colonization . col_location ( self , veg_species1 ) self . seed_loc1 = self . seed_loc Colonization . col_location ( self , veg_species2 ) self . seed_loc2 = self . seed_loc loc1 = veg_species1 . initial . veg_frac [ self . seed_loc1 ] loc1 [ total_cover [ self . seed_loc1 ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 loc2 = veg_species2 . initial . veg_frac [ self . seed_loc2 ] loc2 [ total_cover [ self . seed_loc2 ] <= ( 1 - veg_species2 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_height [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . num_stem [ 0 ] ) veg_species2 . initial . veg_height [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniShoot ) veg_species2 . initial . stem_dia [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniDia ) veg_species2 . initial . root_len [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniRoot ) veg_species2 . initial . stem_num [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . num_stem [ 0 ] ) # comp = np.where(loc1 == 1 and loc2 == 1) if ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac > 1 ): loc1 [ np . in1d ( self . seed_loc1 , self . seed_loc2 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) loc2 [ np . in1d ( self . seed_loc2 , self . seed_loc1 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) veg_species1 . initial . veg_frac [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniCol_frac ) veg_species2 . initial . veg_frac [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniCol_frac ) def col_location ( self , veg : Vegetation ): \"\"\" new vegetation settlement :param veg: vegetation :type vegetation: Vegetation \"\"\" # find seedling location in cells that have water depth only at max. water level # for random establishment extract random selection of seedling locations self . seed_loc = np . where ( Colonization . colonization_criterion ( self , veg ) == True ) # all possible locations for seedlings if veg . constants . random == 0 : self . seed_loc = self . seed_loc [ 0 ] else : self . seed_loc = np . random . choice ( self . seed_loc [ 0 ], round ( len ( self . seed_loc [ 0 ]) / veg . constants . random ) ) # locations where random settlement can occur def colonization_criterion ( self , veg : Vegetation ): \"\"\"determine areas which are available for colonization :param veg: vegetation :type veg: Vegetation \"\"\" # if veg.constants.ColMethod == 1: Colonization . colonization_inundation_range ( self , veg ) return self . cir # elif self.constants.ColMethod == 2: # Colonization.colonization_inundation_range(self, veg) # Colonization.mud_availability(veg) # return np.logical_and(self.cir, self.ma) #matrix with true everywhere where vegetation is possible according to mud content and inundation def colonization_inundation_range ( self , veg : Vegetation ): \"\"\"Colonization Inundation range Args: veg (Vegetation): Vegetation \"\"\" # # Calculations self . cir = np . zeros ( veg . max_wl . shape ) self . cir = ( Colonization . cir_formula ( veg . max_wl , veg . min_wl ) == 1 ) # true, false matrix look for cells that are flooded during high anf low water levels @staticmethod def cir_formula ( max_water_level , min_water_level ): max_water_level [ max_water_level > 0 ] = 1 min_water_level [ min_water_level > 0 ] = 1 return max_water_level - min_water_level col_location ( veg : Vegetation ) \u00b6 new vegetation settlement :param veg: vegetation :type vegetation: Vegetation Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def col_location ( self , veg : Vegetation ): \"\"\" new vegetation settlement :param veg: vegetation :type vegetation: Vegetation \"\"\" # find seedling location in cells that have water depth only at max. water level # for random establishment extract random selection of seedling locations self . seed_loc = np . where ( Colonization . colonization_criterion ( self , veg ) == True ) # all possible locations for seedlings if veg . constants . random == 0 : self . seed_loc = self . seed_loc [ 0 ] else : self . seed_loc = np . random . choice ( self . seed_loc [ 0 ], round ( len ( self . seed_loc [ 0 ]) / veg . constants . random ) ) # locations where random settlement can occur colonization_criterion ( veg : Vegetation ) \u00b6 determine areas which are available for colonization :param veg: vegetation :type veg: Vegetation Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 141 142 143 144 145 146 147 148 149 150 def colonization_criterion ( self , veg : Vegetation ): \"\"\"determine areas which are available for colonization :param veg: vegetation :type veg: Vegetation \"\"\" # if veg.constants.ColMethod == 1: Colonization . colonization_inundation_range ( self , veg ) return self . cir colonization_inundation_range ( veg : Vegetation ) \u00b6 Colonization Inundation range Parameters: Name Type Description Default veg Vegetation Vegetation required Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 156 157 158 159 160 161 162 163 164 165 166 def colonization_inundation_range ( self , veg : Vegetation ): \"\"\"Colonization Inundation range Args: veg (Vegetation): Vegetation \"\"\" # # Calculations self . cir = np . zeros ( veg . max_wl . shape ) self . cir = ( Colonization . cir_formula ( veg . max_wl , veg . min_wl ) == 1 ) # true, false matrix look for cells that are flooded during high anf low water levels update ( veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ]) \u00b6 Update marsh cover after colonization (settlement) if two vegetation objects are given (different species), they will compete for space when they colonize :param veg: vegetation :type vegetation: Vegetation Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def update ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ]): \"\"\"Update marsh cover after colonization (settlement) if two vegetation objects are given (different species), they will compete for space when they colonize :param veg: vegetation :type vegetation: Vegetation \"\"\" if not veg_species2 : # # available locations for settlement Colonization . col_location ( self , veg_species1 ) loc = veg_species1 . initial . veg_frac [ self . seed_loc ] loc [ veg_species1 . total_cover [ self . seed_loc ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_frac [ self . seed_loc ] = ( loc * veg_species1 . constants . iniCol_frac ) veg_species1 . initial . veg_height [ self . seed_loc ] = ( loc * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc ] = ( loc * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc ] = ( loc * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc ] = ( loc * veg_species1 . constants . num_stem [ 0 ] ) # TODO test this! else : total_cover = veg_species1 . total_cover + veg_species2 . total_cover Colonization . col_location ( self , veg_species1 ) self . seed_loc1 = self . seed_loc Colonization . col_location ( self , veg_species2 ) self . seed_loc2 = self . seed_loc loc1 = veg_species1 . initial . veg_frac [ self . seed_loc1 ] loc1 [ total_cover [ self . seed_loc1 ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 loc2 = veg_species2 . initial . veg_frac [ self . seed_loc2 ] loc2 [ total_cover [ self . seed_loc2 ] <= ( 1 - veg_species2 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_height [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . num_stem [ 0 ] ) veg_species2 . initial . veg_height [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniShoot ) veg_species2 . initial . stem_dia [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniDia ) veg_species2 . initial . root_len [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniRoot ) veg_species2 . initial . stem_num [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . num_stem [ 0 ] ) # comp = np.where(loc1 == 1 and loc2 == 1) if ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac > 1 ): loc1 [ np . in1d ( self . seed_loc1 , self . seed_loc2 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) loc2 [ np . in1d ( self . seed_loc2 , self . seed_loc1 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) veg_species1 . initial . veg_frac [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniCol_frac ) veg_species2 . initial . veg_frac [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniCol_frac ) Hydro morphodynamics \u00b6 Hydro_Morphodynamics \u00b6 Get the values for the hydromorphodynamic environment Source code in src/biota_models/vegetation/bio_process/veg_hydro_morphodynamics.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Hydro_Morphodynamics : \"\"\"Get the values for the hydromorphodynamic environment\"\"\" def __init__ ( self , tau_cur , u_cur , wl_cur , bl_cur , ts , veg : Vegetation ): self . tau = tau_cur self . u = u_cur self . wl = wl_cur self . bl = bl_cur self . ts = ts if ts == 0 : veg . tau_ts = self . tau veg . u_ts = self . u veg . wl_ts = self . wl veg . bl_ts = self . bl else : veg . tau_ts = np . column_stack (( veg . tau_ts , self . tau )) veg . u_ts = np . column_stack (( veg . u_ts , self . u )) veg . wl_ts = np . column_stack (( veg . wl_ts , self . wl )) veg . bl_ts = np . column_stack (( veg . bl_ts , self . bl )) def get_hydromorph_values ( self , veg ): veg . max_tau = np . zeros ( len ( veg . tau_ts )) veg . max_u = np . zeros ( len ( veg . u_ts )) veg . max_wl = np . zeros ( len ( veg . wl_ts )) veg . min_wl = np . zeros ( len ( veg . wl_ts )) veg . bl = np . zeros ( len ( veg . bl_ts )) for i in range ( 0 , len ( veg . tau_ts )): veg . max_tau [ i ] = max ( veg . tau_ts [ i , :]) veg . max_u [ i ] = max ( veg . u_ts [ i , :]) veg . max_wl [ i ] = max ( veg . wl_ts [ i , :]) veg . min_wl [ i ] = min ( veg . wl_ts [ i , :]) veg . bl [:] = veg . bl_ts [:, - 1 ] # last values in bed level to get 'current' value def store_hydromorph_values ( self , veg ): veg . max_tau_prev = veg . max_tau veg . max_u_prev = veg . max_u veg . max_wl_prev = veg . max_wl veg . min_wl_prev = veg . min_wl veg . bl_prev = veg . bl veg . wl_prev = veg . wl_ts Mortality and growth \u00b6 Veg_Mortality \u00b6 Bases: ExtraModel Mortality Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 class Veg_Mortality ( ExtraModel ): \"\"\"Mortality\"\"\" def __init__ ( self ): super () . __init__ () self . burial_scour_j = None self . burial_scour_m = None self . scour_j = None self . burial_j = None self . scour_m = None self . burial_m = None self . Bl_diff = None self . fraction_dead_flood_j = None self . fraction_dead_des_j = None self . fraction_dead_upr_j = None self . fraction_dead_flood_m = None self . fraction_dead_des_m = None self . fraction_dead_upr_m = None # burial_scour: Optional[np.array] = None # scour: Optional[np.array] = None # burial: Optional[np.array] = None # BL_diff: Optional[np.array] = None # fraction_dead_flood: Optional[np.array] = None # fraction_dead_des: Optional[np.array] = None # fraction_dead_upr: Optional[np.array] = None def update ( self , veg : Vegetation , constants : VegetationConstants , ets , begin_date , end_date , period , ): \"\"\"Update vegetation characteristics after mortality\"\"\" Veg_Mortality . drowning_hydroperiod ( self , veg , constants , ets ) Veg_Mortality . uprooting ( self , veg , constants ) Veg_Mortality . erosion_sedimentation ( self , veg , ets ) veg . juvenile . veg_frac = ( veg . juvenile . veg_frac - self . fraction_dead_flood_j - self . fraction_dead_des_j - self . fraction_dead_upr_j - self . burial_scour_j ) # update fractions due to mortality veg . juvenile . veg_frac [ veg . juvenile . veg_frac < 0 ] = 0 # replace negative values with 0 veg . mature . veg_frac = ( veg . mature . veg_frac - self . fraction_dead_flood_m - self . fraction_dead_des_m - self . fraction_dead_upr_m - self . burial_scour_m ) # update fractions due to mortality veg . mature . veg_frac [ veg . mature . veg_frac < 0 ] = 0 # replace negative values with 0 veg . juvenile . update_growth ( veg . juvenile . veg_frac , period , begin_date , end_date ) veg . mature . update_growth ( veg . mature . veg_frac , period , begin_date , end_date ) def drowning_hydroperiod ( self , veg : Vegetation , constants : VegetationConstants , ets ): flooding_current , drying_current = self . compute_hydroperiod ( veg . wl_ts , constants ) wet = np . zeros ( flooding_current . shape ) dry = np . zeros ( drying_current . shape ) wet [ flooding_current > 0 ] = 1 dry [ drying_current > 0 ] = 1 if ets == 0 : veg . wl_prev = np . zeros ( veg . wl_ts . shape ) flooding_prev , drying_prev = self . compute_hydroperiod ( veg . wl_prev , constants ) dry = ( drying_prev * dry ) # deleting all cells that have fallen wet during this ETS wet = ( flooding_prev * wet ) # deleting all cells that have fallen dry during this ETS new_wet = np . where ( ( flooding_prev == 0 ) & ( flooding_current > 0 ) ) # find cells that are newly wet during this ETS new_dry = np . where ( ( drying_prev == 0 ) & ( drying_current > 0 ) ) # find cells that are newly dry during this ETS wet_j = np . ones ( veg . juvenile . veg_frac . shape ) * wet . reshape ( len ( wet ), 1 ) # np.repeat(wet.reshape(len(wet), 1), len(veg.juvenile.veg_frac[0]), axis=1) dry_j = np . ones ( veg . juvenile . veg_frac . shape ) * dry . reshape ( len ( dry ), 1 ) wet_j [ new_wet ] = veg . juvenile . veg_frac [ new_wet ] # add initial fractions in cells that are newly wet in matrix dry_j [ new_dry ] = veg . juvenile . veg_frac [ new_dry ] # add initial fractions in cells that are newly dry in matrix # determine flooding/drying mortalities based on linear relationship mort_flood_j = self . mortality_flood_frequency ( flooding_current , constants . floMort_thres [ 0 ], constants . floMort_slope [ 0 ] ) mort_des_j = self . mortality_flood_frequency ( drying_current , constants . desMort_thres [ 0 ], constants . desMort_slope [ 0 ] ) self . fraction_dead_flood_j = wet_j * mort_flood_j self . fraction_dead_des_j = dry_j * mort_des_j wet_m = np . ones ( veg . mature . veg_frac . shape ) * wet . reshape ( len ( wet ), 1 ) dry_m = np . ones ( veg . mature . veg_frac . shape ) * dry . reshape ( len ( dry ), 1 ) wet_m [ new_wet ] = veg . mature . veg_frac [ new_wet ] # add initial fractions in cells that are newly wet in matrix dry_m [ new_dry ] = veg . mature . veg_frac [ new_dry ] # add initial fractions in cells that are newly dry in matrix # determine flooding/drying mortalities based on linear relationship mort_flood_m = self . mortality_flood_frequency ( flooding_current , constants . floMort_thres [ 1 ], constants . floMort_slope [ 1 ] ) mort_des_m = self . mortality_flood_frequency ( drying_current , constants . desMort_thres [ 1 ], constants . desMort_slope [ 1 ] ) self . fraction_dead_flood_m = wet_m * mort_flood_m self . fraction_dead_des_m = dry_m * mort_des_m @staticmethod def compute_hydroperiod ( wl_time , constants : VegetationConstants ): # determiine cells with water depth > flooding/drying threshold fl = np . where ( wl_time > constants . fl_dr ) flood = np . zeros ( wl_time . shape ) flood [ fl ] = 1 flood = flood . sum ( axis = 1 ) # sum up for all time steps in the ets # compute average flooding and drying period flooding_current = flood / constants . ets_duration drying_current = ( constants . ets_duration - flood ) / constants . ets_duration return flooding_current , drying_current @staticmethod def mortality_flood_frequency ( fl , th , sl ): \"\"\" \" calculate mortality fraction due to flooding/drying and velocity Function: f(x)=sl*x+b for y= 0: b = -sl*th th: Threshold sl: slope of function fl: matrix with flooded days \"\"\" b = - th * sl dmax = round (( 1 - b ) / sl , 2 ) # no. of days when 100% is died off fct = sl * fl + b # determines all mortality values over the grid out_fl = np . zeros ( fl . shape ) B = np . where ( fl > dmax ) # cells with 100% mortality out_fl [ B ] = 1 a = fl > th b = fl < dmax C = np . nonzero ( ( a == True ) & ( b == True ) ) # cells where fct applies to determine mortality out_fl [ C ] = fct [ C ] return out_fl . reshape ( len ( out_fl ), 1 ) def uprooting ( self , veg : Vegetation , constants : VegetationConstants ): \"\"\" Mortality through velocity is determined by lin. Function and multiplied with current fraction. \"\"\" mort_flow_j = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 0 ], constants . vel_slope [ 0 ] ) self . fraction_dead_upr_j = mort_flow_j * veg . juvenile . veg_frac mort_flow_m = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 1 ], constants . vel_slope [ 1 ] ) self . fraction_dead_upr_m = mort_flow_m * veg . mature . veg_frac def erosion_sedimentation ( self , veg : Vegetation , ets ): \"\"\" For burial/erosion the length of stem/root is compared with sedimentation/erosion. In case of mortality the fraction is set to 0. We assume that the plants adapt to the deposition and erosion rates within one ETS by resetting them each ETS. \"\"\" Veg_Mortality . BedLevel_Dif ( self , veg , ets ) fract_scour_j = np . zeros ( veg . juvenile . root_len . shape ) fract_burial_j = np . zeros ( veg . juvenile . veg_height . shape ) fract_scour_j [ self . scour_j > veg . juvenile . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_j [ self . burial_j > veg . juvenile . veg_height ] = 1 self . burial_scour_j = ( fract_scour_j + fract_burial_j ) # array with cells where vegetation dies and the fraction of death due to burial and scour fract_scour_m = np . zeros ( veg . mature . root_len . shape ) fract_burial_m = np . zeros ( veg . mature . veg_height . shape ) fract_scour_m [ self . scour_m > veg . mature . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_m [ self . burial_m > veg . mature . veg_height ] = 1 self . burial_scour_m = fract_scour_m + fract_burial_m ## TODO make this static method? def BedLevel_Dif ( self , veg : Vegetation , ets ): if ets >= 1 : # from second time step onward in each ets if ets == 1 : self . Bl_diff = veg . bl - veg . bl_prev else : depth_dts = veg . bl - veg . bl_prev self . Bl_diff = depth_dts + self . Bl_diff self . burial_j = np . zeros ( veg . juvenile . veg_height . shape ) self . scour_j = np . zeros ( veg . juvenile . root_len . shape ) self . burial_m = np . zeros ( veg . mature . veg_height . shape ) self . scour_m = np . zeros ( veg . mature . root_len . shape ) loc_b = np . where ( self . Bl_diff < 0 ) self . burial_j [ loc_b ] = ( np . ones ( self . burial_j . shape ) * self . Bl_diff [ 0 : len ( self . burial_j )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . burial_j )]), 1 ) )[ loc_b ] self . burial_m [ loc_b ] = ( np . ones ( self . burial_m . shape ) * self . Bl_diff [ 0 : len ( self . burial_m )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . burial_m )]), 1 ) )[ loc_b ] loc_s = np . where ( self . Bl_diff > 0 ) self . scour_j [ loc_s ] = ( np . ones ( self . scour_j . shape ) * self . Bl_diff [ 0 : len ( self . scour_j )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . scour_j )]), 1 ) )[ loc_s ] self . scour_m [ loc_s ] = ( np . ones ( self . scour_m . shape ) * self . Bl_diff [ 0 : len ( self . scour_m )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . scour_m )]), 1 ) )[ loc_s ] else : self . burial_j = np . zeros ( veg . juvenile . veg_height . shape ) self . scour_j = np . zeros ( veg . juvenile . root_len . shape ) self . burial_m = np . zeros ( veg . mature . veg_height . shape ) self . scour_m = np . zeros ( veg . mature . root_len . shape ) erosion_sedimentation ( veg : Vegetation , ets ) \u00b6 For burial/erosion the length of stem/root is compared with sedimentation/erosion. In case of mortality the fraction is set to 0. We assume that the plants adapt to the deposition and erosion rates within one ETS by resetting them each ETS. Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def erosion_sedimentation ( self , veg : Vegetation , ets ): \"\"\" For burial/erosion the length of stem/root is compared with sedimentation/erosion. In case of mortality the fraction is set to 0. We assume that the plants adapt to the deposition and erosion rates within one ETS by resetting them each ETS. \"\"\" Veg_Mortality . BedLevel_Dif ( self , veg , ets ) fract_scour_j = np . zeros ( veg . juvenile . root_len . shape ) fract_burial_j = np . zeros ( veg . juvenile . veg_height . shape ) fract_scour_j [ self . scour_j > veg . juvenile . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_j [ self . burial_j > veg . juvenile . veg_height ] = 1 self . burial_scour_j = ( fract_scour_j + fract_burial_j ) # array with cells where vegetation dies and the fraction of death due to burial and scour fract_scour_m = np . zeros ( veg . mature . root_len . shape ) fract_burial_m = np . zeros ( veg . mature . veg_height . shape ) fract_scour_m [ self . scour_m > veg . mature . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_m [ self . burial_m > veg . mature . veg_height ] = 1 self . burial_scour_m = fract_scour_m + fract_burial_m mortality_flood_frequency ( fl , th , sl ) staticmethod \u00b6 \" calculate mortality fraction due to flooding/drying and velocity Function: f(x)=sl x+b for y= 0: b = -sl th th: Threshold sl: slope of function fl: matrix with flooded days Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @staticmethod def mortality_flood_frequency ( fl , th , sl ): \"\"\" \" calculate mortality fraction due to flooding/drying and velocity Function: f(x)=sl*x+b for y= 0: b = -sl*th th: Threshold sl: slope of function fl: matrix with flooded days \"\"\" b = - th * sl dmax = round (( 1 - b ) / sl , 2 ) # no. of days when 100% is died off fct = sl * fl + b # determines all mortality values over the grid out_fl = np . zeros ( fl . shape ) B = np . where ( fl > dmax ) # cells with 100% mortality out_fl [ B ] = 1 a = fl > th b = fl < dmax C = np . nonzero ( ( a == True ) & ( b == True ) ) # cells where fct applies to determine mortality out_fl [ C ] = fct [ C ] return out_fl . reshape ( len ( out_fl ), 1 ) update ( veg : Vegetation , constants : VegetationConstants , ets , begin_date , end_date , period ) \u00b6 Update vegetation characteristics after mortality Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def update ( self , veg : Vegetation , constants : VegetationConstants , ets , begin_date , end_date , period , ): \"\"\"Update vegetation characteristics after mortality\"\"\" Veg_Mortality . drowning_hydroperiod ( self , veg , constants , ets ) Veg_Mortality . uprooting ( self , veg , constants ) Veg_Mortality . erosion_sedimentation ( self , veg , ets ) veg . juvenile . veg_frac = ( veg . juvenile . veg_frac - self . fraction_dead_flood_j - self . fraction_dead_des_j - self . fraction_dead_upr_j - self . burial_scour_j ) # update fractions due to mortality veg . juvenile . veg_frac [ veg . juvenile . veg_frac < 0 ] = 0 # replace negative values with 0 veg . mature . veg_frac = ( veg . mature . veg_frac - self . fraction_dead_flood_m - self . fraction_dead_des_m - self . fraction_dead_upr_m - self . burial_scour_m ) # update fractions due to mortality veg . mature . veg_frac [ veg . mature . veg_frac < 0 ] = 0 # replace negative values with 0 veg . juvenile . update_growth ( veg . juvenile . veg_frac , period , begin_date , end_date ) veg . mature . update_growth ( veg . mature . veg_frac , period , begin_date , end_date ) uprooting ( veg : Vegetation , constants : VegetationConstants ) \u00b6 Mortality through velocity is determined by lin. Function and multiplied with current fraction. Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 183 184 185 186 187 188 189 190 191 192 193 194 195 def uprooting ( self , veg : Vegetation , constants : VegetationConstants ): \"\"\" Mortality through velocity is determined by lin. Function and multiplied with current fraction. \"\"\" mort_flow_j = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 0 ], constants . vel_slope [ 0 ] ) self . fraction_dead_upr_j = mort_flow_j * veg . juvenile . veg_frac mort_flow_m = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 1 ], constants . vel_slope [ 1 ] ) self . fraction_dead_upr_m = mort_flow_m * veg . mature . veg_frac","title":"Vegetation processes"},{"location":"reference/biota_models/vegetation/vegetation_processes/#biophysical-processes","text":"","title":"Biophysical processes"},{"location":"reference/biota_models/vegetation/vegetation_processes/#colonisation","text":"","title":"Colonisation"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_colonisation.Colonization","text":"Bases: ExtraModel Colonization Colonization depends on ColMethod (Colonisation method (1 = on bare substrate between max and min water levels, 2 = on bare substrate with mud content) 1. inundation (max, min water level, flooded only in max waterlevel: intertidal area) 2. mud fraction in top layer: mud_frac>mud_colonization (NOT YET FULLY IMPLEMENTED!) Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class Colonization ( ExtraModel ): \"\"\" Colonization Colonization depends on ColMethod (Colonisation method (1 = on bare substrate between max and min water levels, 2 = on bare substrate with mud content) 1. inundation (max, min water level, flooded only in max waterlevel: intertidal area) 2. mud fraction in top layer: mud_frac>mud_colonization (NOT YET FULLY IMPLEMENTED!) \"\"\" cir : Optional [ np . ndarray ] ma : Optional [ np . ndarray ] seed_loc : Optional [ np . ndarray ] seed_loc1 : Optional [ np . ndarray ] seed_loc2 : Optional [ np . ndarray ] def update ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ]): \"\"\"Update marsh cover after colonization (settlement) if two vegetation objects are given (different species), they will compete for space when they colonize :param veg: vegetation :type vegetation: Vegetation \"\"\" if not veg_species2 : # # available locations for settlement Colonization . col_location ( self , veg_species1 ) loc = veg_species1 . initial . veg_frac [ self . seed_loc ] loc [ veg_species1 . total_cover [ self . seed_loc ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_frac [ self . seed_loc ] = ( loc * veg_species1 . constants . iniCol_frac ) veg_species1 . initial . veg_height [ self . seed_loc ] = ( loc * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc ] = ( loc * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc ] = ( loc * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc ] = ( loc * veg_species1 . constants . num_stem [ 0 ] ) # TODO test this! else : total_cover = veg_species1 . total_cover + veg_species2 . total_cover Colonization . col_location ( self , veg_species1 ) self . seed_loc1 = self . seed_loc Colonization . col_location ( self , veg_species2 ) self . seed_loc2 = self . seed_loc loc1 = veg_species1 . initial . veg_frac [ self . seed_loc1 ] loc1 [ total_cover [ self . seed_loc1 ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 loc2 = veg_species2 . initial . veg_frac [ self . seed_loc2 ] loc2 [ total_cover [ self . seed_loc2 ] <= ( 1 - veg_species2 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_height [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . num_stem [ 0 ] ) veg_species2 . initial . veg_height [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniShoot ) veg_species2 . initial . stem_dia [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniDia ) veg_species2 . initial . root_len [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniRoot ) veg_species2 . initial . stem_num [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . num_stem [ 0 ] ) # comp = np.where(loc1 == 1 and loc2 == 1) if ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac > 1 ): loc1 [ np . in1d ( self . seed_loc1 , self . seed_loc2 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) loc2 [ np . in1d ( self . seed_loc2 , self . seed_loc1 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) veg_species1 . initial . veg_frac [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniCol_frac ) veg_species2 . initial . veg_frac [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniCol_frac ) def col_location ( self , veg : Vegetation ): \"\"\" new vegetation settlement :param veg: vegetation :type vegetation: Vegetation \"\"\" # find seedling location in cells that have water depth only at max. water level # for random establishment extract random selection of seedling locations self . seed_loc = np . where ( Colonization . colonization_criterion ( self , veg ) == True ) # all possible locations for seedlings if veg . constants . random == 0 : self . seed_loc = self . seed_loc [ 0 ] else : self . seed_loc = np . random . choice ( self . seed_loc [ 0 ], round ( len ( self . seed_loc [ 0 ]) / veg . constants . random ) ) # locations where random settlement can occur def colonization_criterion ( self , veg : Vegetation ): \"\"\"determine areas which are available for colonization :param veg: vegetation :type veg: Vegetation \"\"\" # if veg.constants.ColMethod == 1: Colonization . colonization_inundation_range ( self , veg ) return self . cir # elif self.constants.ColMethod == 2: # Colonization.colonization_inundation_range(self, veg) # Colonization.mud_availability(veg) # return np.logical_and(self.cir, self.ma) #matrix with true everywhere where vegetation is possible according to mud content and inundation def colonization_inundation_range ( self , veg : Vegetation ): \"\"\"Colonization Inundation range Args: veg (Vegetation): Vegetation \"\"\" # # Calculations self . cir = np . zeros ( veg . max_wl . shape ) self . cir = ( Colonization . cir_formula ( veg . max_wl , veg . min_wl ) == 1 ) # true, false matrix look for cells that are flooded during high anf low water levels @staticmethod def cir_formula ( max_water_level , min_water_level ): max_water_level [ max_water_level > 0 ] = 1 min_water_level [ min_water_level > 0 ] = 1 return max_water_level - min_water_level","title":"Colonization"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_colonisation.Colonization.col_location","text":"new vegetation settlement :param veg: vegetation :type vegetation: Vegetation Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def col_location ( self , veg : Vegetation ): \"\"\" new vegetation settlement :param veg: vegetation :type vegetation: Vegetation \"\"\" # find seedling location in cells that have water depth only at max. water level # for random establishment extract random selection of seedling locations self . seed_loc = np . where ( Colonization . colonization_criterion ( self , veg ) == True ) # all possible locations for seedlings if veg . constants . random == 0 : self . seed_loc = self . seed_loc [ 0 ] else : self . seed_loc = np . random . choice ( self . seed_loc [ 0 ], round ( len ( self . seed_loc [ 0 ]) / veg . constants . random ) ) # locations where random settlement can occur","title":"col_location()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_colonisation.Colonization.colonization_criterion","text":"determine areas which are available for colonization :param veg: vegetation :type veg: Vegetation Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 141 142 143 144 145 146 147 148 149 150 def colonization_criterion ( self , veg : Vegetation ): \"\"\"determine areas which are available for colonization :param veg: vegetation :type veg: Vegetation \"\"\" # if veg.constants.ColMethod == 1: Colonization . colonization_inundation_range ( self , veg ) return self . cir","title":"colonization_criterion()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_colonisation.Colonization.colonization_inundation_range","text":"Colonization Inundation range Parameters: Name Type Description Default veg Vegetation Vegetation required Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 156 157 158 159 160 161 162 163 164 165 166 def colonization_inundation_range ( self , veg : Vegetation ): \"\"\"Colonization Inundation range Args: veg (Vegetation): Vegetation \"\"\" # # Calculations self . cir = np . zeros ( veg . max_wl . shape ) self . cir = ( Colonization . cir_formula ( veg . max_wl , veg . min_wl ) == 1 ) # true, false matrix look for cells that are flooded during high anf low water levels","title":"colonization_inundation_range()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_colonisation.Colonization.update","text":"Update marsh cover after colonization (settlement) if two vegetation objects are given (different species), they will compete for space when they colonize :param veg: vegetation :type vegetation: Vegetation Source code in src/biota_models/vegetation/bio_process/veg_colonisation.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def update ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ]): \"\"\"Update marsh cover after colonization (settlement) if two vegetation objects are given (different species), they will compete for space when they colonize :param veg: vegetation :type vegetation: Vegetation \"\"\" if not veg_species2 : # # available locations for settlement Colonization . col_location ( self , veg_species1 ) loc = veg_species1 . initial . veg_frac [ self . seed_loc ] loc [ veg_species1 . total_cover [ self . seed_loc ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_frac [ self . seed_loc ] = ( loc * veg_species1 . constants . iniCol_frac ) veg_species1 . initial . veg_height [ self . seed_loc ] = ( loc * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc ] = ( loc * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc ] = ( loc * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc ] = ( loc * veg_species1 . constants . num_stem [ 0 ] ) # TODO test this! else : total_cover = veg_species1 . total_cover + veg_species2 . total_cover Colonization . col_location ( self , veg_species1 ) self . seed_loc1 = self . seed_loc Colonization . col_location ( self , veg_species2 ) self . seed_loc2 = self . seed_loc loc1 = veg_species1 . initial . veg_frac [ self . seed_loc1 ] loc1 [ total_cover [ self . seed_loc1 ] <= ( 1 - veg_species1 . constants . iniCol_frac ) ] = 1 loc2 = veg_species2 . initial . veg_frac [ self . seed_loc2 ] loc2 [ total_cover [ self . seed_loc2 ] <= ( 1 - veg_species2 . constants . iniCol_frac ) ] = 1 veg_species1 . initial . veg_height [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniShoot ) veg_species1 . initial . stem_dia [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniDia ) veg_species1 . initial . root_len [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniRoot ) veg_species1 . initial . stem_num [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . num_stem [ 0 ] ) veg_species2 . initial . veg_height [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniShoot ) veg_species2 . initial . stem_dia [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniDia ) veg_species2 . initial . root_len [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniRoot ) veg_species2 . initial . stem_num [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . num_stem [ 0 ] ) # comp = np.where(loc1 == 1 and loc2 == 1) if ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac > 1 ): loc1 [ np . in1d ( self . seed_loc1 , self . seed_loc2 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) loc2 [ np . in1d ( self . seed_loc2 , self . seed_loc1 ) == True ] = 1 / ( veg_species1 . constants . iniCol_frac + veg_species2 . constants . iniCol_frac ) veg_species1 . initial . veg_frac [ self . seed_loc1 ] = ( loc1 * veg_species1 . constants . iniCol_frac ) veg_species2 . initial . veg_frac [ self . seed_loc2 ] = ( loc2 * veg_species2 . constants . iniCol_frac )","title":"update()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#hydro-morphodynamics","text":"","title":"Hydro morphodynamics"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_hydro_morphodynamics.Hydro_Morphodynamics","text":"Get the values for the hydromorphodynamic environment Source code in src/biota_models/vegetation/bio_process/veg_hydro_morphodynamics.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Hydro_Morphodynamics : \"\"\"Get the values for the hydromorphodynamic environment\"\"\" def __init__ ( self , tau_cur , u_cur , wl_cur , bl_cur , ts , veg : Vegetation ): self . tau = tau_cur self . u = u_cur self . wl = wl_cur self . bl = bl_cur self . ts = ts if ts == 0 : veg . tau_ts = self . tau veg . u_ts = self . u veg . wl_ts = self . wl veg . bl_ts = self . bl else : veg . tau_ts = np . column_stack (( veg . tau_ts , self . tau )) veg . u_ts = np . column_stack (( veg . u_ts , self . u )) veg . wl_ts = np . column_stack (( veg . wl_ts , self . wl )) veg . bl_ts = np . column_stack (( veg . bl_ts , self . bl )) def get_hydromorph_values ( self , veg ): veg . max_tau = np . zeros ( len ( veg . tau_ts )) veg . max_u = np . zeros ( len ( veg . u_ts )) veg . max_wl = np . zeros ( len ( veg . wl_ts )) veg . min_wl = np . zeros ( len ( veg . wl_ts )) veg . bl = np . zeros ( len ( veg . bl_ts )) for i in range ( 0 , len ( veg . tau_ts )): veg . max_tau [ i ] = max ( veg . tau_ts [ i , :]) veg . max_u [ i ] = max ( veg . u_ts [ i , :]) veg . max_wl [ i ] = max ( veg . wl_ts [ i , :]) veg . min_wl [ i ] = min ( veg . wl_ts [ i , :]) veg . bl [:] = veg . bl_ts [:, - 1 ] # last values in bed level to get 'current' value def store_hydromorph_values ( self , veg ): veg . max_tau_prev = veg . max_tau veg . max_u_prev = veg . max_u veg . max_wl_prev = veg . max_wl veg . min_wl_prev = veg . min_wl veg . bl_prev = veg . bl veg . wl_prev = veg . wl_ts","title":"Hydro_Morphodynamics"},{"location":"reference/biota_models/vegetation/vegetation_processes/#mortality-and-growth","text":"","title":"Mortality and growth"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_mortality.Veg_Mortality","text":"Bases: ExtraModel Mortality Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 class Veg_Mortality ( ExtraModel ): \"\"\"Mortality\"\"\" def __init__ ( self ): super () . __init__ () self . burial_scour_j = None self . burial_scour_m = None self . scour_j = None self . burial_j = None self . scour_m = None self . burial_m = None self . Bl_diff = None self . fraction_dead_flood_j = None self . fraction_dead_des_j = None self . fraction_dead_upr_j = None self . fraction_dead_flood_m = None self . fraction_dead_des_m = None self . fraction_dead_upr_m = None # burial_scour: Optional[np.array] = None # scour: Optional[np.array] = None # burial: Optional[np.array] = None # BL_diff: Optional[np.array] = None # fraction_dead_flood: Optional[np.array] = None # fraction_dead_des: Optional[np.array] = None # fraction_dead_upr: Optional[np.array] = None def update ( self , veg : Vegetation , constants : VegetationConstants , ets , begin_date , end_date , period , ): \"\"\"Update vegetation characteristics after mortality\"\"\" Veg_Mortality . drowning_hydroperiod ( self , veg , constants , ets ) Veg_Mortality . uprooting ( self , veg , constants ) Veg_Mortality . erosion_sedimentation ( self , veg , ets ) veg . juvenile . veg_frac = ( veg . juvenile . veg_frac - self . fraction_dead_flood_j - self . fraction_dead_des_j - self . fraction_dead_upr_j - self . burial_scour_j ) # update fractions due to mortality veg . juvenile . veg_frac [ veg . juvenile . veg_frac < 0 ] = 0 # replace negative values with 0 veg . mature . veg_frac = ( veg . mature . veg_frac - self . fraction_dead_flood_m - self . fraction_dead_des_m - self . fraction_dead_upr_m - self . burial_scour_m ) # update fractions due to mortality veg . mature . veg_frac [ veg . mature . veg_frac < 0 ] = 0 # replace negative values with 0 veg . juvenile . update_growth ( veg . juvenile . veg_frac , period , begin_date , end_date ) veg . mature . update_growth ( veg . mature . veg_frac , period , begin_date , end_date ) def drowning_hydroperiod ( self , veg : Vegetation , constants : VegetationConstants , ets ): flooding_current , drying_current = self . compute_hydroperiod ( veg . wl_ts , constants ) wet = np . zeros ( flooding_current . shape ) dry = np . zeros ( drying_current . shape ) wet [ flooding_current > 0 ] = 1 dry [ drying_current > 0 ] = 1 if ets == 0 : veg . wl_prev = np . zeros ( veg . wl_ts . shape ) flooding_prev , drying_prev = self . compute_hydroperiod ( veg . wl_prev , constants ) dry = ( drying_prev * dry ) # deleting all cells that have fallen wet during this ETS wet = ( flooding_prev * wet ) # deleting all cells that have fallen dry during this ETS new_wet = np . where ( ( flooding_prev == 0 ) & ( flooding_current > 0 ) ) # find cells that are newly wet during this ETS new_dry = np . where ( ( drying_prev == 0 ) & ( drying_current > 0 ) ) # find cells that are newly dry during this ETS wet_j = np . ones ( veg . juvenile . veg_frac . shape ) * wet . reshape ( len ( wet ), 1 ) # np.repeat(wet.reshape(len(wet), 1), len(veg.juvenile.veg_frac[0]), axis=1) dry_j = np . ones ( veg . juvenile . veg_frac . shape ) * dry . reshape ( len ( dry ), 1 ) wet_j [ new_wet ] = veg . juvenile . veg_frac [ new_wet ] # add initial fractions in cells that are newly wet in matrix dry_j [ new_dry ] = veg . juvenile . veg_frac [ new_dry ] # add initial fractions in cells that are newly dry in matrix # determine flooding/drying mortalities based on linear relationship mort_flood_j = self . mortality_flood_frequency ( flooding_current , constants . floMort_thres [ 0 ], constants . floMort_slope [ 0 ] ) mort_des_j = self . mortality_flood_frequency ( drying_current , constants . desMort_thres [ 0 ], constants . desMort_slope [ 0 ] ) self . fraction_dead_flood_j = wet_j * mort_flood_j self . fraction_dead_des_j = dry_j * mort_des_j wet_m = np . ones ( veg . mature . veg_frac . shape ) * wet . reshape ( len ( wet ), 1 ) dry_m = np . ones ( veg . mature . veg_frac . shape ) * dry . reshape ( len ( dry ), 1 ) wet_m [ new_wet ] = veg . mature . veg_frac [ new_wet ] # add initial fractions in cells that are newly wet in matrix dry_m [ new_dry ] = veg . mature . veg_frac [ new_dry ] # add initial fractions in cells that are newly dry in matrix # determine flooding/drying mortalities based on linear relationship mort_flood_m = self . mortality_flood_frequency ( flooding_current , constants . floMort_thres [ 1 ], constants . floMort_slope [ 1 ] ) mort_des_m = self . mortality_flood_frequency ( drying_current , constants . desMort_thres [ 1 ], constants . desMort_slope [ 1 ] ) self . fraction_dead_flood_m = wet_m * mort_flood_m self . fraction_dead_des_m = dry_m * mort_des_m @staticmethod def compute_hydroperiod ( wl_time , constants : VegetationConstants ): # determiine cells with water depth > flooding/drying threshold fl = np . where ( wl_time > constants . fl_dr ) flood = np . zeros ( wl_time . shape ) flood [ fl ] = 1 flood = flood . sum ( axis = 1 ) # sum up for all time steps in the ets # compute average flooding and drying period flooding_current = flood / constants . ets_duration drying_current = ( constants . ets_duration - flood ) / constants . ets_duration return flooding_current , drying_current @staticmethod def mortality_flood_frequency ( fl , th , sl ): \"\"\" \" calculate mortality fraction due to flooding/drying and velocity Function: f(x)=sl*x+b for y= 0: b = -sl*th th: Threshold sl: slope of function fl: matrix with flooded days \"\"\" b = - th * sl dmax = round (( 1 - b ) / sl , 2 ) # no. of days when 100% is died off fct = sl * fl + b # determines all mortality values over the grid out_fl = np . zeros ( fl . shape ) B = np . where ( fl > dmax ) # cells with 100% mortality out_fl [ B ] = 1 a = fl > th b = fl < dmax C = np . nonzero ( ( a == True ) & ( b == True ) ) # cells where fct applies to determine mortality out_fl [ C ] = fct [ C ] return out_fl . reshape ( len ( out_fl ), 1 ) def uprooting ( self , veg : Vegetation , constants : VegetationConstants ): \"\"\" Mortality through velocity is determined by lin. Function and multiplied with current fraction. \"\"\" mort_flow_j = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 0 ], constants . vel_slope [ 0 ] ) self . fraction_dead_upr_j = mort_flow_j * veg . juvenile . veg_frac mort_flow_m = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 1 ], constants . vel_slope [ 1 ] ) self . fraction_dead_upr_m = mort_flow_m * veg . mature . veg_frac def erosion_sedimentation ( self , veg : Vegetation , ets ): \"\"\" For burial/erosion the length of stem/root is compared with sedimentation/erosion. In case of mortality the fraction is set to 0. We assume that the plants adapt to the deposition and erosion rates within one ETS by resetting them each ETS. \"\"\" Veg_Mortality . BedLevel_Dif ( self , veg , ets ) fract_scour_j = np . zeros ( veg . juvenile . root_len . shape ) fract_burial_j = np . zeros ( veg . juvenile . veg_height . shape ) fract_scour_j [ self . scour_j > veg . juvenile . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_j [ self . burial_j > veg . juvenile . veg_height ] = 1 self . burial_scour_j = ( fract_scour_j + fract_burial_j ) # array with cells where vegetation dies and the fraction of death due to burial and scour fract_scour_m = np . zeros ( veg . mature . root_len . shape ) fract_burial_m = np . zeros ( veg . mature . veg_height . shape ) fract_scour_m [ self . scour_m > veg . mature . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_m [ self . burial_m > veg . mature . veg_height ] = 1 self . burial_scour_m = fract_scour_m + fract_burial_m ## TODO make this static method? def BedLevel_Dif ( self , veg : Vegetation , ets ): if ets >= 1 : # from second time step onward in each ets if ets == 1 : self . Bl_diff = veg . bl - veg . bl_prev else : depth_dts = veg . bl - veg . bl_prev self . Bl_diff = depth_dts + self . Bl_diff self . burial_j = np . zeros ( veg . juvenile . veg_height . shape ) self . scour_j = np . zeros ( veg . juvenile . root_len . shape ) self . burial_m = np . zeros ( veg . mature . veg_height . shape ) self . scour_m = np . zeros ( veg . mature . root_len . shape ) loc_b = np . where ( self . Bl_diff < 0 ) self . burial_j [ loc_b ] = ( np . ones ( self . burial_j . shape ) * self . Bl_diff [ 0 : len ( self . burial_j )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . burial_j )]), 1 ) )[ loc_b ] self . burial_m [ loc_b ] = ( np . ones ( self . burial_m . shape ) * self . Bl_diff [ 0 : len ( self . burial_m )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . burial_m )]), 1 ) )[ loc_b ] loc_s = np . where ( self . Bl_diff > 0 ) self . scour_j [ loc_s ] = ( np . ones ( self . scour_j . shape ) * self . Bl_diff [ 0 : len ( self . scour_j )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . scour_j )]), 1 ) )[ loc_s ] self . scour_m [ loc_s ] = ( np . ones ( self . scour_m . shape ) * self . Bl_diff [ 0 : len ( self . scour_m )] . reshape ( len ( self . Bl_diff [ 0 : len ( self . scour_m )]), 1 ) )[ loc_s ] else : self . burial_j = np . zeros ( veg . juvenile . veg_height . shape ) self . scour_j = np . zeros ( veg . juvenile . root_len . shape ) self . burial_m = np . zeros ( veg . mature . veg_height . shape ) self . scour_m = np . zeros ( veg . mature . root_len . shape )","title":"Veg_Mortality"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_mortality.Veg_Mortality.erosion_sedimentation","text":"For burial/erosion the length of stem/root is compared with sedimentation/erosion. In case of mortality the fraction is set to 0. We assume that the plants adapt to the deposition and erosion rates within one ETS by resetting them each ETS. Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def erosion_sedimentation ( self , veg : Vegetation , ets ): \"\"\" For burial/erosion the length of stem/root is compared with sedimentation/erosion. In case of mortality the fraction is set to 0. We assume that the plants adapt to the deposition and erosion rates within one ETS by resetting them each ETS. \"\"\" Veg_Mortality . BedLevel_Dif ( self , veg , ets ) fract_scour_j = np . zeros ( veg . juvenile . root_len . shape ) fract_burial_j = np . zeros ( veg . juvenile . veg_height . shape ) fract_scour_j [ self . scour_j > veg . juvenile . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_j [ self . burial_j > veg . juvenile . veg_height ] = 1 self . burial_scour_j = ( fract_scour_j + fract_burial_j ) # array with cells where vegetation dies and the fraction of death due to burial and scour fract_scour_m = np . zeros ( veg . mature . root_len . shape ) fract_burial_m = np . zeros ( veg . mature . veg_height . shape ) fract_scour_m [ self . scour_m > veg . mature . root_len ] = 1 # find cells with mortality (scour > rootlength) fract_burial_m [ self . burial_m > veg . mature . veg_height ] = 1 self . burial_scour_m = fract_scour_m + fract_burial_m","title":"erosion_sedimentation()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_mortality.Veg_Mortality.mortality_flood_frequency","text":"\" calculate mortality fraction due to flooding/drying and velocity Function: f(x)=sl x+b for y= 0: b = -sl th th: Threshold sl: slope of function fl: matrix with flooded days Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @staticmethod def mortality_flood_frequency ( fl , th , sl ): \"\"\" \" calculate mortality fraction due to flooding/drying and velocity Function: f(x)=sl*x+b for y= 0: b = -sl*th th: Threshold sl: slope of function fl: matrix with flooded days \"\"\" b = - th * sl dmax = round (( 1 - b ) / sl , 2 ) # no. of days when 100% is died off fct = sl * fl + b # determines all mortality values over the grid out_fl = np . zeros ( fl . shape ) B = np . where ( fl > dmax ) # cells with 100% mortality out_fl [ B ] = 1 a = fl > th b = fl < dmax C = np . nonzero ( ( a == True ) & ( b == True ) ) # cells where fct applies to determine mortality out_fl [ C ] = fct [ C ] return out_fl . reshape ( len ( out_fl ), 1 )","title":"mortality_flood_frequency()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_mortality.Veg_Mortality.update","text":"Update vegetation characteristics after mortality Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def update ( self , veg : Vegetation , constants : VegetationConstants , ets , begin_date , end_date , period , ): \"\"\"Update vegetation characteristics after mortality\"\"\" Veg_Mortality . drowning_hydroperiod ( self , veg , constants , ets ) Veg_Mortality . uprooting ( self , veg , constants ) Veg_Mortality . erosion_sedimentation ( self , veg , ets ) veg . juvenile . veg_frac = ( veg . juvenile . veg_frac - self . fraction_dead_flood_j - self . fraction_dead_des_j - self . fraction_dead_upr_j - self . burial_scour_j ) # update fractions due to mortality veg . juvenile . veg_frac [ veg . juvenile . veg_frac < 0 ] = 0 # replace negative values with 0 veg . mature . veg_frac = ( veg . mature . veg_frac - self . fraction_dead_flood_m - self . fraction_dead_des_m - self . fraction_dead_upr_m - self . burial_scour_m ) # update fractions due to mortality veg . mature . veg_frac [ veg . mature . veg_frac < 0 ] = 0 # replace negative values with 0 veg . juvenile . update_growth ( veg . juvenile . veg_frac , period , begin_date , end_date ) veg . mature . update_growth ( veg . mature . veg_frac , period , begin_date , end_date )","title":"update()"},{"location":"reference/biota_models/vegetation/vegetation_processes/#src.biota_models.vegetation.bio_process.veg_mortality.Veg_Mortality.uprooting","text":"Mortality through velocity is determined by lin. Function and multiplied with current fraction. Source code in src/biota_models/vegetation/bio_process/veg_mortality.py 183 184 185 186 187 188 189 190 191 192 193 194 195 def uprooting ( self , veg : Vegetation , constants : VegetationConstants ): \"\"\" Mortality through velocity is determined by lin. Function and multiplied with current fraction. \"\"\" mort_flow_j = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 0 ], constants . vel_slope [ 0 ] ) self . fraction_dead_upr_j = mort_flow_j * veg . juvenile . veg_frac mort_flow_m = self . mortality_flood_frequency ( veg . max_u , constants . vel_thres [ 1 ], constants . vel_slope [ 1 ] ) self . fraction_dead_upr_m = mort_flow_m * veg . mature . veg_frac","title":"uprooting()"},{"location":"reference/biota_models/vegetation/vegetation_simulation/","text":"Classes representing the available simulation modes. \u00b6 Base simulation. \u00b6 Vegetation Delft3D (FlowFM / DIMR) \u00b6 VegDimrSimulation \u00b6 Bases: _VegDelft3DSimulation Vegetation Dimr Simulation representation. Implements the specific logic needed to run a Veg Simulation with a DIMR kernel through BMIWrapper Source code in src/biota_models/vegetation/simulation/veg_delft3d_simulation.py 80 81 82 83 84 85 86 87 class VegDimrSimulation ( _VegDelft3DSimulation ): \"\"\" Vegetation Dimr Simulation representation. Implements the specific logic needed to run a Veg Simulation with a DIMR kernel through `BMIWrapper` \"\"\" mode = \"DimrModel\" VegFlowFmSimulation \u00b6 Bases: _VegDelft3DSimulation Vegetation FlowFM Simulation representation. Implements the specific logic needed to run a Veg Simulation with a FlowFM kernel through BMIWrapper Source code in src/biota_models/vegetation/simulation/veg_delft3d_simulation.py 90 91 92 93 94 95 96 97 class VegFlowFmSimulation ( _VegDelft3DSimulation ): \"\"\" Vegetation FlowFM Simulation representation. Implements the specific logic needed to run a Veg Simulation with a FlowFM kernel through `BMIWrapper` \"\"\" mode = \"FlowFMModel\"","title":"Vegetation simulation"},{"location":"reference/biota_models/vegetation/vegetation_simulation/#classes-representing-the-available-simulation-modes","text":"","title":"Classes representing the available simulation modes."},{"location":"reference/biota_models/vegetation/vegetation_simulation/#base-simulation","text":"","title":"Base simulation."},{"location":"reference/biota_models/vegetation/vegetation_simulation/#vegetation-delft3d-flowfm-dimr","text":"","title":"Vegetation Delft3D (FlowFM / DIMR)"},{"location":"reference/biota_models/vegetation/vegetation_simulation/#src.biota_models.vegetation.simulation.veg_delft3d_simulation.VegDimrSimulation","text":"Bases: _VegDelft3DSimulation Vegetation Dimr Simulation representation. Implements the specific logic needed to run a Veg Simulation with a DIMR kernel through BMIWrapper Source code in src/biota_models/vegetation/simulation/veg_delft3d_simulation.py 80 81 82 83 84 85 86 87 class VegDimrSimulation ( _VegDelft3DSimulation ): \"\"\" Vegetation Dimr Simulation representation. Implements the specific logic needed to run a Veg Simulation with a DIMR kernel through `BMIWrapper` \"\"\" mode = \"DimrModel\"","title":"VegDimrSimulation"},{"location":"reference/biota_models/vegetation/vegetation_simulation/#src.biota_models.vegetation.simulation.veg_delft3d_simulation.VegFlowFmSimulation","text":"Bases: _VegDelft3DSimulation Vegetation FlowFM Simulation representation. Implements the specific logic needed to run a Veg Simulation with a FlowFM kernel through BMIWrapper Source code in src/biota_models/vegetation/simulation/veg_delft3d_simulation.py 90 91 92 93 94 95 96 97 class VegFlowFmSimulation ( _VegDelft3DSimulation ): \"\"\" Vegetation FlowFM Simulation representation. Implements the specific logic needed to run a Veg Simulation with a FlowFM kernel through `BMIWrapper` \"\"\" mode = \"FlowFMModel\"","title":"VegFlowFmSimulation"},{"location":"reference/core/core/","text":"Core classes for the NBSDynamics package. \u00b6 Base Model (pydantic) \u00b6 BaseModel \u00b6 Bases: PydanticBaseModel Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. Source code in src/core/base_model.py 5 6 7 8 9 10 11 class BaseModel ( PydanticBaseModel ): \"\"\" Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. \"\"\" class Config : arbitrary_types_allowed = True ExtraModel \u00b6 Bases: PydanticBaseModel Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. Source code in src/core/base_model.py 14 15 16 17 18 19 20 21 22 23 24 25 class ExtraModel ( PydanticBaseModel ): \"\"\" Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. \"\"\" class Config : \"\"\" Allows this model to have extra fields defined during runtime. \"\"\" arbitrary_types_allowed = True extra = Extra . allow Config \u00b6 Allows this model to have extra fields defined during runtime. Source code in src/core/base_model.py 19 20 21 22 23 24 25 class Config : \"\"\" Allows this model to have extra fields defined during runtime. \"\"\" arbitrary_types_allowed = True extra = Extra . allow","title":"Core"},{"location":"reference/core/core/#core-classes-for-the-nbsdynamics-package","text":"","title":"Core classes for the NBSDynamics package."},{"location":"reference/core/core/#base-model-pydantic","text":"","title":"Base Model (pydantic)"},{"location":"reference/core/core/#src.core.base_model.BaseModel","text":"Bases: PydanticBaseModel Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. Source code in src/core/base_model.py 5 6 7 8 9 10 11 class BaseModel ( PydanticBaseModel ): \"\"\" Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. \"\"\" class Config : arbitrary_types_allowed = True","title":"BaseModel"},{"location":"reference/core/core/#src.core.base_model.ExtraModel","text":"Bases: PydanticBaseModel Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. Source code in src/core/base_model.py 14 15 16 17 18 19 20 21 22 23 24 25 class ExtraModel ( PydanticBaseModel ): \"\"\" Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. \"\"\" class Config : \"\"\" Allows this model to have extra fields defined during runtime. \"\"\" arbitrary_types_allowed = True extra = Extra . allow","title":"ExtraModel"},{"location":"reference/core/core/#src.core.base_model.ExtraModel.Config","text":"Allows this model to have extra fields defined during runtime. Source code in src/core/base_model.py 19 20 21 22 23 24 25 class Config : \"\"\" Allows this model to have extra fields defined during runtime. \"\"\" arbitrary_types_allowed = True extra = Extra . allow","title":"Config"},{"location":"reference/core/biota/biota/","text":"Biota base classes for the NBSDynamics package. \u00b6 Biota Model \u00b6 Biota \u00b6 Bases: ExtraModel Empty class to cluster all the BIOTA models so that we can reference to this abstraction from protocols and other classes. Source code in src/core/biota/biota_model.py 5 6 7 8 9 10 11 class Biota ( ExtraModel ): \"\"\" Empty class to cluster all the BIOTA models so that we can reference to this abstraction from protocols and other classes. \"\"\" constants : BaseConstants pass","title":"Biota"},{"location":"reference/core/biota/biota/#biota-base-classes-for-the-nbsdynamics-package","text":"","title":"Biota base classes for the NBSDynamics package."},{"location":"reference/core/biota/biota/#biota-model","text":"","title":"Biota Model"},{"location":"reference/core/biota/biota/#src.core.biota.biota_model.Biota","text":"Bases: ExtraModel Empty class to cluster all the BIOTA models so that we can reference to this abstraction from protocols and other classes. Source code in src/core/biota/biota_model.py 5 6 7 8 9 10 11 class Biota ( ExtraModel ): \"\"\" Empty class to cluster all the BIOTA models so that we can reference to this abstraction from protocols and other classes. \"\"\" constants : BaseConstants pass","title":"Biota"},{"location":"reference/core/common/common/","text":"Common classes for the NBSDynamics package. \u00b6 Constants \u00b6 BaseConstants \u00b6 Bases: BaseModel , abc . ABC Object containing all constants used in coral_model simulations. Source code in src/core/common/base_constants.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class BaseConstants ( BaseModel , abc . ABC ): \"\"\"Object containing all constants used in coral_model simulations.\"\"\" # Input file input_file : Optional [ Path ] def correct_values ( self ): \"\"\" Corrects values that require extra operations. \"\"\" pass @classmethod def from_input_file ( cls , input_file : Path ): \"\"\" Generates a 'Constants' class based on the defined parameters in the input_file. Args: input_file (Path): Path to the constants input (.txt) file. \"\"\" def split_line ( line : str ): s_line = line . split ( \"=\" ) if len ( s_line ) <= 1 : raise ValueError return s_line [ 0 ] . strip (), s_line [ 1 ] . strip () def format_line ( line : str ) -> str : return split_line ( line . split ( \"#\" )[ 0 ]) def normalize_line ( line : str ) -> str : return line . strip () input_lines = [ format_line ( n_line ) for line in input_file . read_text () . splitlines ( keepends = False ) if line and not ( n_line := normalize_line ( line )) . startswith ( \"#\" ) ] cls_constants = cls ( ** dict ( input_lines )) cls_constants . correct_values () return cls_constants correct_values () \u00b6 Corrects values that require extra operations. Source code in src/core/common/base_constants.py 14 15 16 17 18 def correct_values ( self ): \"\"\" Corrects values that require extra operations. \"\"\" pass from_input_file ( input_file : Path ) classmethod \u00b6 Generates a 'Constants' class based on the defined parameters in the input_file. Parameters: Name Type Description Default input_file Path Path to the constants input (.txt) file. required Source code in src/core/common/base_constants.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @classmethod def from_input_file ( cls , input_file : Path ): \"\"\" Generates a 'Constants' class based on the defined parameters in the input_file. Args: input_file (Path): Path to the constants input (.txt) file. \"\"\" def split_line ( line : str ): s_line = line . split ( \"=\" ) if len ( s_line ) <= 1 : raise ValueError return s_line [ 0 ] . strip (), s_line [ 1 ] . strip () def format_line ( line : str ) -> str : return split_line ( line . split ( \"#\" )[ 0 ]) def normalize_line ( line : str ) -> str : return line . strip () input_lines = [ format_line ( n_line ) for line in input_file . read_text () . splitlines ( keepends = False ) if line and not ( n_line := normalize_line ( line )) . startswith ( \"#\" ) ] cls_constants = cls ( ** dict ( input_lines )) cls_constants . correct_values () return cls_constants Environment \u00b6 coral_mostoel - environment @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman Environment \u00b6 Bases: BaseModel Source code in src/core/common/environment.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 class Environment ( BaseModel ): dates : Optional [ pd . DataFrame ] = ( \"1990, 01, 01\" , \"2021, 12, 20\" ) light : Optional [ pd . DataFrame ] light_attenuation : Optional [ pd . DataFrame ] temperature : Optional [ pd . DataFrame ] aragonite : Optional [ pd . DataFrame ] storm_category : Optional [ pd . DataFrame ] @validator ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" , pre = True ) @classmethod def validate_dataframe_or_path ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Args: value (EnvInputAttr): Value to be validated (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated attribute value. \"\"\" def read_index ( value_file : Path ) -> pd . DataFrame : \"\"\"Function applicable to time-series in Pandas.\"\"\" time_series = pd . read_csv ( value_file , sep = \" \\t \" ) if time_series . isnull () . values . any (): msg = f \"NaNs detected in time series { value_file } \" raise ValueError ( msg ) time_series [ \"date\" ] = pd . to_datetime ( time_series [ \"date\" ]) time_series . set_index ( \"date\" , inplace = True ) return time_series if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) return read_index ( value ) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) @validator ( \"storm_category\" , pre = True ) @classmethod def validate_storm_category ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Args: value (EnvInputAttr): Value assigned to the attribute (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) csv_values = pd . read_csv ( value , sep = \" \\t \" ) csv_values . set_index ( \"year\" , inplace = True ) return csv_values raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) @validator ( \"dates\" , pre = True ) @classmethod def prevalidate_dates ( cls , value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] ) -> pd . DataFrame : \"\"\" Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Args: value (Union[pd.DataFrame, Iterable[Union[str, datetime]]]): Value assigned to the attribute. Raises: NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , Iterable ): return cls . get_dates_dataframe ( value [ 0 ], value [ - 1 ]) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) @validator ( \"dates\" , always = True , pre = False ) @classmethod def check_dates ( cls , v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame : \"\"\" Validates the dates value (post-process). Args: v (Optional[pd.DataFrame]): Value pre-validated for dates (if any). values (dict): Dictionary containing the rest of values given to initialize 'Environment'. Returns: pd.DataFrame: Validated dates value. \"\"\" # Validate dates have values. if isinstance ( v , pd . DataFrame ): return v light_value : pd . DataFrame = values . get ( \"light\" , None ) if light_value is not None : # TODO: Check column name of light-file return light_value . reset_index () . drop ( \"light\" , axis = 1 ) temp_value : pd . DataFrame = values . get ( \"temperature\" , None ) if temp_value is not None : return temp_value . reset_index () . drop ( \"sst\" , axis = 1 ) return None @staticmethod def get_dates_dataframe ( start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ) -> pd . DataFrame : dates = pd . date_range ( start_date , end_date , freq = \"D\" ) return pd . DataFrame ({ \"date\" : dates }) def get_dates ( self ) -> Iterable [ datetime ]: \"\"\" Just a shortcut being used in some occasions to get the datetime series array. Raises: ValueError: When no dates could be set for the 'Environment'. Returns: pd.Series[datetime]: Collection of timeseries stored in Environment.dates \"\"\" if self . dates is None : raise ValueError ( \"No values were assigned to dates.\" ) return pd . to_datetime ( self . dates [ \"date\" ]) def set_dates ( self , start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ): \"\"\" Set dates manually, ignoring possible dates in environmental time-series. Args: start_date (Union[str, datetime]): Start of the range dates. end_date (Union[str, datetime]): End of the range dates. \"\"\" self . dates = self . get_dates_dataframe ( start_date , end_date ) @property def temp_kelvin ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Kelvin. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values < 100 ) and self . temperature is not None : return self . temperature + 273.15 return self . temperature @property def temp_celsius ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Celsius. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values > 100 ) and self . temperature is not None : return self . temperature - 273.15 return self . temperature @property def temp_mmm ( self ) -> pd . DataFrame : \"\"\" Temperature in Monthly mean. Returns: pd.DataFrame: value as a pandas DataFrame. \"\"\" monthly_mean = self . temp_kelvin . groupby ( [ self . temp_kelvin . index . year , self . temp_kelvin . index . month ] ) . agg ([ \"mean\" ]) monthly_maximum_mean = monthly_mean . groupby ( level = 0 ) . agg ([ \"min\" , \"max\" ]) monthly_maximum_mean . columns = monthly_maximum_mean . columns . droplevel ([ 0 , 1 ]) return monthly_maximum_mean EnvironmentValue = Union [ float , list , tuple , np . ndarray , pd . DataFrame ] def set_parameter_values ( self , parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ): \"\"\" Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Args: parameter (str): Parameter to be set. value (EnvironmentValue): New value for the parameter. pre_date (Optional[int], optional): Time-series start before simulation dates [yrs]. Defaults to None. \"\"\" def set_value ( val ): \"\"\"Function to set value.\"\"\" simple_dates = self . get_dates () if pre_date is None : return pd . DataFrame ({ parameter : val }, index = simple_dates ) dates = pd . date_range ( simple_dates . iloc [ 0 ] - pd . DateOffset ( years = pre_date ), simple_dates . iloc [ - 1 ], freq = \"D\" , ) return pd . DataFrame ({ parameter : val }, index = dates ) if self . dates is None : msg = ( f \"No dates are defined. \" f \"Please, first specify the dates before setting the time-series of { parameter } ; \" f 'or make use of the \"from_file\"-method.' ) raise TypeError ( msg ) if parameter == \"LAC\" : parameter = \"light_attenuation\" daily_params = ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" ) if parameter in daily_params : setattr ( self , parameter , set_value ( value )) elif parameter == \"storm\" : years = set ( self . get_dates () . dt . year ) self . storm_category = pd . DataFrame ( data = value , index = years ) else : msg = f \"Entered parameter ( { parameter } ) not included. See documentation.\" raise ValueError ( msg ) check_dates ( v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame classmethod \u00b6 Validates the dates value (post-process). Parameters: Name Type Description Default v Optional [ pd . DataFrame ] Value pre-validated for dates (if any). required values dict Dictionary containing the rest of values given to initialize 'Environment'. required Returns: Type Description pd . DataFrame pd.DataFrame: Validated dates value. Source code in src/core/common/environment.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @validator ( \"dates\" , always = True , pre = False ) @classmethod def check_dates ( cls , v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame : \"\"\" Validates the dates value (post-process). Args: v (Optional[pd.DataFrame]): Value pre-validated for dates (if any). values (dict): Dictionary containing the rest of values given to initialize 'Environment'. Returns: pd.DataFrame: Validated dates value. \"\"\" # Validate dates have values. if isinstance ( v , pd . DataFrame ): return v light_value : pd . DataFrame = values . get ( \"light\" , None ) if light_value is not None : # TODO: Check column name of light-file return light_value . reset_index () . drop ( \"light\" , axis = 1 ) temp_value : pd . DataFrame = values . get ( \"temperature\" , None ) if temp_value is not None : return temp_value . reset_index () . drop ( \"sst\" , axis = 1 ) return None get_dates () -> Iterable [ datetime ] \u00b6 Just a shortcut being used in some occasions to get the datetime series array. Raises: Type Description ValueError When no dates could be set for the 'Environment'. Returns: Type Description Iterable [ datetime ] pd.Series[datetime]: Collection of timeseries stored in Environment.dates Source code in src/core/common/environment.py 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_dates ( self ) -> Iterable [ datetime ]: \"\"\" Just a shortcut being used in some occasions to get the datetime series array. Raises: ValueError: When no dates could be set for the 'Environment'. Returns: pd.Series[datetime]: Collection of timeseries stored in Environment.dates \"\"\" if self . dates is None : raise ValueError ( \"No values were assigned to dates.\" ) return pd . to_datetime ( self . dates [ \"date\" ]) prevalidate_dates ( value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]]) -> pd . DataFrame classmethod \u00b6 Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Parameters: Name Type Description Default value Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] Value assigned to the attribute. required Raises: Type Description NotImplementedError When the provided value is not supported. Returns: Type Description pd . DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @validator ( \"dates\" , pre = True ) @classmethod def prevalidate_dates ( cls , value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] ) -> pd . DataFrame : \"\"\" Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Args: value (Union[pd.DataFrame, Iterable[Union[str, datetime]]]): Value assigned to the attribute. Raises: NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , Iterable ): return cls . get_dates_dataframe ( value [ 0 ], value [ - 1 ]) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) set_dates ( start_date : Union [ str , datetime ], end_date : Union [ str , datetime ]) \u00b6 Set dates manually, ignoring possible dates in environmental time-series. Parameters: Name Type Description Default start_date Union [ str , datetime ] Start of the range dates. required end_date Union [ str , datetime ] End of the range dates. required Source code in src/core/common/environment.py 168 169 170 171 172 173 174 175 176 177 178 179 def set_dates ( self , start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ): \"\"\" Set dates manually, ignoring possible dates in environmental time-series. Args: start_date (Union[str, datetime]): Start of the range dates. end_date (Union[str, datetime]): End of the range dates. \"\"\" self . dates = self . get_dates_dataframe ( start_date , end_date ) set_parameter_values ( parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ) \u00b6 Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Parameters: Name Type Description Default parameter str Parameter to be set. required value EnvironmentValue New value for the parameter. required pre_date Optional [ int ] Time-series start before simulation dates [yrs]. Defaults to None. None Source code in src/core/common/environment.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def set_parameter_values ( self , parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ): \"\"\" Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Args: parameter (str): Parameter to be set. value (EnvironmentValue): New value for the parameter. pre_date (Optional[int], optional): Time-series start before simulation dates [yrs]. Defaults to None. \"\"\" def set_value ( val ): \"\"\"Function to set value.\"\"\" simple_dates = self . get_dates () if pre_date is None : return pd . DataFrame ({ parameter : val }, index = simple_dates ) dates = pd . date_range ( simple_dates . iloc [ 0 ] - pd . DateOffset ( years = pre_date ), simple_dates . iloc [ - 1 ], freq = \"D\" , ) return pd . DataFrame ({ parameter : val }, index = dates ) if self . dates is None : msg = ( f \"No dates are defined. \" f \"Please, first specify the dates before setting the time-series of { parameter } ; \" f 'or make use of the \"from_file\"-method.' ) raise TypeError ( msg ) if parameter == \"LAC\" : parameter = \"light_attenuation\" daily_params = ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" ) if parameter in daily_params : setattr ( self , parameter , set_value ( value )) elif parameter == \"storm\" : years = set ( self . get_dates () . dt . year ) self . storm_category = pd . DataFrame ( data = value , index = years ) else : msg = f \"Entered parameter ( { parameter } ) not included. See documentation.\" raise ValueError ( msg ) temp_celsius () -> pd . DataFrame property \u00b6 Gets the temperature property in Celsius. Returns: Type Description pd . DataFrame pd.DataFrame: value representation. Source code in src/core/common/environment.py 193 194 195 196 197 198 199 200 201 202 203 @property def temp_celsius ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Celsius. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values > 100 ) and self . temperature is not None : return self . temperature - 273.15 return self . temperature temp_kelvin () -> pd . DataFrame property \u00b6 Gets the temperature property in Kelvin. Returns: Type Description pd . DataFrame pd.DataFrame: value representation. Source code in src/core/common/environment.py 181 182 183 184 185 186 187 188 189 190 191 @property def temp_kelvin ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Kelvin. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values < 100 ) and self . temperature is not None : return self . temperature + 273.15 return self . temperature temp_mmm () -> pd . DataFrame property \u00b6 Temperature in Monthly mean. Returns: Type Description pd . DataFrame pd.DataFrame: value as a pandas DataFrame. Source code in src/core/common/environment.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 @property def temp_mmm ( self ) -> pd . DataFrame : \"\"\" Temperature in Monthly mean. Returns: pd.DataFrame: value as a pandas DataFrame. \"\"\" monthly_mean = self . temp_kelvin . groupby ( [ self . temp_kelvin . index . year , self . temp_kelvin . index . month ] ) . agg ([ \"mean\" ]) monthly_maximum_mean = monthly_mean . groupby ( level = 0 ) . agg ([ \"min\" , \"max\" ]) monthly_maximum_mean . columns = monthly_maximum_mean . columns . droplevel ([ 0 , 1 ]) return monthly_maximum_mean validate_dataframe_or_path ( value : EnvInputAttr ) -> pd . DataFrame classmethod \u00b6 Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Parameters: Name Type Description Default value EnvInputAttr Value to be validated (Union[pd.DataFrame, Path, str]). required Raises: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description pd . DataFrame pd.DataFrame: Validated attribute value. Source code in src/core/common/environment.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @validator ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" , pre = True ) @classmethod def validate_dataframe_or_path ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Args: value (EnvInputAttr): Value to be validated (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated attribute value. \"\"\" def read_index ( value_file : Path ) -> pd . DataFrame : \"\"\"Function applicable to time-series in Pandas.\"\"\" time_series = pd . read_csv ( value_file , sep = \" \\t \" ) if time_series . isnull () . values . any (): msg = f \"NaNs detected in time series { value_file } \" raise ValueError ( msg ) time_series [ \"date\" ] = pd . to_datetime ( time_series [ \"date\" ]) time_series . set_index ( \"date\" , inplace = True ) return time_series if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) return read_index ( value ) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) validate_storm_category ( value : EnvInputAttr ) -> pd . DataFrame classmethod \u00b6 Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Parameters: Name Type Description Default value EnvInputAttr Value assigned to the attribute (Union[pd.DataFrame, Path, str]). required Raises: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description pd . DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @validator ( \"storm_category\" , pre = True ) @classmethod def validate_storm_category ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Args: value (EnvInputAttr): Value assigned to the attribute (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) csv_values = pd . read_csv ( value , sep = \" \\t \" ) csv_values . set_index ( \"year\" , inplace = True ) return csv_values raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) Singletons \u00b6 This file is intended to contain all the common classes used as unique object throughout the NBSDynamics project. Although these classes are defined elsewhere, here we implement them as singletons. RESHAPE \u00b6 Bases: Singleton , DataReshape DataReshape Singleton. Source code in src/core/common/singletons.py 24 25 26 27 28 29 class RESHAPE ( Singleton , DataReshape ): \"\"\" `DataReshape` Singleton. \"\"\" pass Singleton \u00b6 Bases: object Singleton class representing the design pattern. This class can be used for concepts that are not meant to change state during a simulation such as DataReshape, represented by RESHAPE. Source code in src/core/common/singletons.py 9 10 11 12 13 14 15 16 17 18 19 20 21 class Singleton ( object ): \"\"\" Singleton class representing the design pattern. This class can be used for concepts that are not meant to change state during a simulation such as DataReshape, represented by RESHAPE. \"\"\" _instance = None def __new__ ( cls , * args , ** kwargs ): if not isinstance ( cls . _instance , cls ): cls . _instance = object . __new__ ( cls , * args , ** kwargs ) return cls . _instance SpaceTime \u00b6 coral_model - utils veg_model - utils @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman DataReshape \u00b6 Bases: SpaceTime Reshape data to create a spacetime matrix. Source code in src/core/common/space_time.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class DataReshape ( SpaceTime ): \"\"\"Reshape data to create a spacetime matrix.\"\"\" def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" super () . __init__ ( spacetime = spacetime ) def variable2matrix ( self , variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ): \"\"\"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # dimension-value variable = self . variable2array ( variable ) self . dimension_value ( variable , dimension ) # # transformation if dimension == \"space\" : return np . tile ( variable , ( self . time , 1 )) . transpose () elif dimension == \"time\" : return np . tile ( variable , ( self . space , 1 )) def dimension_value ( self , variable : Union [ list , tuple , np . ndarray ], dimension : str ): \"\"\"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str \"\"\" try : _ = len ( variable ) except TypeError : variable = [ variable ] if not len ( variable ) == getattr ( self , dimension ): msg = f \"Incorrect variable size, { len ( variable ) } =/= { getattr ( self , dimension ) } .\" raise ValueError ( msg ) @staticmethod def variable2array ( variable : Union [ float , int , list , np . ndarray ]): \"\"\" \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray \"\"\" if isinstance ( variable , str ): msg = f \"Variable cannot be of { type ( variable ) } .\" raise NotImplementedError ( msg ) elif isinstance ( variable , ( float , int )): return np . array ([ float ( variable )]) elif isinstance ( variable , ( list , tuple )): return np . array ( variable ) elif isinstance ( variable , np . ndarray ) and not variable . shape : return np . array ([ variable ]) return variable def matrix2array ( self , matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ): \"\"\"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # input as numpy.array matrix = np . array ( matrix ) # dimension-value if ( not matrix . shape == self . spacetime and not matrix . shape [: 2 ] == self . spacetime ): msg = ( f \"Matrix-shape does not correspond with spacetime-dimensions:\" f \" \\n { matrix . shape } =/= { self . spacetime } \" ) raise ValueError ( msg ) # conversion-strategy conversions = ( None , \"mean\" , \"max\" , \"min\" , \"sum\" ) if conversion not in conversions : msg = f \" { conversion } not in { conversions } .\" raise ValueError ( msg ) # # transformation # last position if conversion is None : if dimension == \"space\" : return matrix [:, - 1 ] elif dimension == \"time\" : return matrix [ - 1 , :] # conversion if dimension == \"space\" : return getattr ( matrix , conversion )( axis = 1 ) elif dimension == \"time\" : return getattr ( matrix , conversion )( axis = 0 ) __init__ ( spacetime : Optional [ Tuple ] = None ) \u00b6 :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional Source code in src/core/common/space_time.py 128 129 130 131 132 133 def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" super () . __init__ ( spacetime = spacetime ) dimension_value ( variable : Union [ list , tuple , np . ndarray ], dimension : str ) \u00b6 Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str Source code in src/core/common/space_time.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def dimension_value ( self , variable : Union [ list , tuple , np . ndarray ], dimension : str ): \"\"\"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str \"\"\" try : _ = len ( variable ) except TypeError : variable = [ variable ] if not len ( variable ) == getattr ( self , dimension ): msg = f \"Incorrect variable size, { len ( variable ) } =/= { getattr ( self , dimension ) } .\" raise ValueError ( msg ) matrix2array ( matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ) \u00b6 Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def matrix2array ( self , matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ): \"\"\"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # input as numpy.array matrix = np . array ( matrix ) # dimension-value if ( not matrix . shape == self . spacetime and not matrix . shape [: 2 ] == self . spacetime ): msg = ( f \"Matrix-shape does not correspond with spacetime-dimensions:\" f \" \\n { matrix . shape } =/= { self . spacetime } \" ) raise ValueError ( msg ) # conversion-strategy conversions = ( None , \"mean\" , \"max\" , \"min\" , \"sum\" ) if conversion not in conversions : msg = f \" { conversion } not in { conversions } .\" raise ValueError ( msg ) # # transformation # last position if conversion is None : if dimension == \"space\" : return matrix [:, - 1 ] elif dimension == \"time\" : return matrix [ - 1 , :] # conversion if dimension == \"space\" : return getattr ( matrix , conversion )( axis = 1 ) elif dimension == \"time\" : return getattr ( matrix , conversion )( axis = 0 ) variable2array ( variable : Union [ float , int , list , np . ndarray ]) staticmethod \u00b6 \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 @staticmethod def variable2array ( variable : Union [ float , int , list , np . ndarray ]): \"\"\" \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray \"\"\" if isinstance ( variable , str ): msg = f \"Variable cannot be of { type ( variable ) } .\" raise NotImplementedError ( msg ) elif isinstance ( variable , ( float , int )): return np . array ([ float ( variable )]) elif isinstance ( variable , ( list , tuple )): return np . array ( variable ) elif isinstance ( variable , np . ndarray ) and not variable . shape : return np . array ([ variable ]) return variable variable2matrix ( variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ) \u00b6 Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray Source code in src/core/common/space_time.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def variable2matrix ( self , variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ): \"\"\"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # dimension-value variable = self . variable2array ( variable ) self . dimension_value ( variable , dimension ) # # transformation if dimension == \"space\" : return np . tile ( variable , ( self . time , 1 )) . transpose () elif dimension == \"time\" : return np . tile ( variable , ( self . space , 1 )) SpaceTime \u00b6 Spacetime-object, which validates the definition of the spacetime dimensions. Source code in src/core/common/space_time.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class SpaceTime : \"\"\"Spacetime-object, which validates the definition of the spacetime dimensions.\"\"\" __spacetime = None def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" if spacetime is not None : self . spacetime = spacetime self . set_coral_only ( self . spacetime ) self . set_veg_only ( self . spacetime ) def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"SpaceTime( { self . __spacetime } )\" def __str__ ( self ): \"\"\"Print representation.\"\"\" return str ( self . spacetime ) @property def spacetime ( self ): \"\"\"Spacetime dimensions. :rtype: tuple \"\"\" if self . __spacetime is None : return 1 , 1 return self . __spacetime @spacetime . setter def spacetime ( self , space_time : Union [ Tuple , list , np . ndarray ]): \"\"\" :param space_time: spacetime dimensions :type space_time: tuple, list, numpy.ndarray \"\"\" if not isinstance ( space_time , ( tuple , list , np . ndarray )): msg = f \"spacetime must be of type tuple, { type ( space_time ) } is given.\" raise TypeError ( msg ) if not len ( space_time ) == 2 : msg = f \"spacetime must be of size 2, { len ( space_time ) } is given.\" raise ValueError ( msg ) if not all ( isinstance ( dim , int ) for dim in space_time ): msg = f \"spacetime must consist of integers only, { [ type ( dim ) for dim in space_time ] } is given.\" raise TypeError ( msg ) self . __spacetime = tuple ( space_time ) self . set_coral_only ( tuple ( space_time )) self . set_veg_only ( tuple ( space_time )) @property def space ( self ) -> int : \"\"\"Space dimension. :rtype: int \"\"\" return self . spacetime [ 0 ] @space . setter def space ( self , x : int ): \"\"\" :param x: space dimension :type x: int \"\"\" self . spacetime = ( x , self . time ) @property def time ( self ) -> int : \"\"\"Time dimension. :rtype: int \"\"\" return self . spacetime [ 1 ] @time . setter def time ( self , t : int ): \"\"\" :param t: time dimension :type t: int \"\"\" self . spacetime = ( self . space , t ) # TODO: Refactor to a private method def set_coral_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" CoralOnly . spacetime = spacetime def set_veg_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the VegOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" VegOnly . spacetime = spacetime __init__ ( spacetime : Optional [ Tuple ] = None ) \u00b6 :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional Source code in src/core/common/space_time.py 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" if spacetime is not None : self . spacetime = spacetime self . set_coral_only ( self . spacetime ) self . set_veg_only ( self . spacetime ) __repr__ () \u00b6 Development representation. Source code in src/core/common/space_time.py 35 36 37 def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"SpaceTime( { self . __spacetime } )\" __str__ () \u00b6 Print representation. Source code in src/core/common/space_time.py 39 40 41 def __str__ ( self ): \"\"\"Print representation.\"\"\" return str ( self . spacetime ) set_coral_only ( spacetime : Tuple ) \u00b6 Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple Source code in src/core/common/space_time.py 108 109 110 111 112 113 114 def set_coral_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" CoralOnly . spacetime = spacetime set_veg_only ( spacetime : Tuple ) \u00b6 Automatically set the spacetime dimensions for the VegOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple Source code in src/core/common/space_time.py 116 117 118 119 120 121 122 def set_veg_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the VegOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" VegOnly . spacetime = spacetime space () -> int property writable \u00b6 Space dimension. :rtype: int Source code in src/core/common/space_time.py 75 76 77 78 79 80 81 @property def space ( self ) -> int : \"\"\"Space dimension. :rtype: int \"\"\" return self . spacetime [ 0 ] spacetime () property writable \u00b6 Spacetime dimensions. :rtype: tuple Source code in src/core/common/space_time.py 43 44 45 46 47 48 49 50 51 @property def spacetime ( self ): \"\"\"Spacetime dimensions. :rtype: tuple \"\"\" if self . __spacetime is None : return 1 , 1 return self . __spacetime time () -> int property writable \u00b6 Time dimension. :rtype: int Source code in src/core/common/space_time.py 91 92 93 94 95 96 97 @property def time ( self ) -> int : \"\"\"Time dimension. :rtype: int \"\"\" return self . spacetime [ 1 ] time_series_year ( time_series : DataFrame , year : int ) \u00b6 Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int Source code in src/core/common/space_time.py 268 269 270 271 272 273 274 275 276 277 def time_series_year ( time_series : DataFrame , year : int ): \"\"\"Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int \"\"\" return time_series [ time_series . index . year == year ] . values . transpose ()[ 0 ]","title":"Common"},{"location":"reference/core/common/common/#common-classes-for-the-nbsdynamics-package","text":"","title":"Common classes for the NBSDynamics package."},{"location":"reference/core/common/common/#constants","text":"","title":"Constants"},{"location":"reference/core/common/common/#src.core.common.base_constants.BaseConstants","text":"Bases: BaseModel , abc . ABC Object containing all constants used in coral_model simulations. Source code in src/core/common/base_constants.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class BaseConstants ( BaseModel , abc . ABC ): \"\"\"Object containing all constants used in coral_model simulations.\"\"\" # Input file input_file : Optional [ Path ] def correct_values ( self ): \"\"\" Corrects values that require extra operations. \"\"\" pass @classmethod def from_input_file ( cls , input_file : Path ): \"\"\" Generates a 'Constants' class based on the defined parameters in the input_file. Args: input_file (Path): Path to the constants input (.txt) file. \"\"\" def split_line ( line : str ): s_line = line . split ( \"=\" ) if len ( s_line ) <= 1 : raise ValueError return s_line [ 0 ] . strip (), s_line [ 1 ] . strip () def format_line ( line : str ) -> str : return split_line ( line . split ( \"#\" )[ 0 ]) def normalize_line ( line : str ) -> str : return line . strip () input_lines = [ format_line ( n_line ) for line in input_file . read_text () . splitlines ( keepends = False ) if line and not ( n_line := normalize_line ( line )) . startswith ( \"#\" ) ] cls_constants = cls ( ** dict ( input_lines )) cls_constants . correct_values () return cls_constants","title":"BaseConstants"},{"location":"reference/core/common/common/#src.core.common.base_constants.BaseConstants.correct_values","text":"Corrects values that require extra operations. Source code in src/core/common/base_constants.py 14 15 16 17 18 def correct_values ( self ): \"\"\" Corrects values that require extra operations. \"\"\" pass","title":"correct_values()"},{"location":"reference/core/common/common/#src.core.common.base_constants.BaseConstants.from_input_file","text":"Generates a 'Constants' class based on the defined parameters in the input_file. Parameters: Name Type Description Default input_file Path Path to the constants input (.txt) file. required Source code in src/core/common/base_constants.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @classmethod def from_input_file ( cls , input_file : Path ): \"\"\" Generates a 'Constants' class based on the defined parameters in the input_file. Args: input_file (Path): Path to the constants input (.txt) file. \"\"\" def split_line ( line : str ): s_line = line . split ( \"=\" ) if len ( s_line ) <= 1 : raise ValueError return s_line [ 0 ] . strip (), s_line [ 1 ] . strip () def format_line ( line : str ) -> str : return split_line ( line . split ( \"#\" )[ 0 ]) def normalize_line ( line : str ) -> str : return line . strip () input_lines = [ format_line ( n_line ) for line in input_file . read_text () . splitlines ( keepends = False ) if line and not ( n_line := normalize_line ( line )) . startswith ( \"#\" ) ] cls_constants = cls ( ** dict ( input_lines )) cls_constants . correct_values () return cls_constants","title":"from_input_file()"},{"location":"reference/core/common/common/#environment","text":"coral_mostoel - environment @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman","title":"Environment"},{"location":"reference/core/common/common/#src.core.common.environment.Environment","text":"Bases: BaseModel Source code in src/core/common/environment.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 class Environment ( BaseModel ): dates : Optional [ pd . DataFrame ] = ( \"1990, 01, 01\" , \"2021, 12, 20\" ) light : Optional [ pd . DataFrame ] light_attenuation : Optional [ pd . DataFrame ] temperature : Optional [ pd . DataFrame ] aragonite : Optional [ pd . DataFrame ] storm_category : Optional [ pd . DataFrame ] @validator ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" , pre = True ) @classmethod def validate_dataframe_or_path ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Args: value (EnvInputAttr): Value to be validated (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated attribute value. \"\"\" def read_index ( value_file : Path ) -> pd . DataFrame : \"\"\"Function applicable to time-series in Pandas.\"\"\" time_series = pd . read_csv ( value_file , sep = \" \\t \" ) if time_series . isnull () . values . any (): msg = f \"NaNs detected in time series { value_file } \" raise ValueError ( msg ) time_series [ \"date\" ] = pd . to_datetime ( time_series [ \"date\" ]) time_series . set_index ( \"date\" , inplace = True ) return time_series if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) return read_index ( value ) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) @validator ( \"storm_category\" , pre = True ) @classmethod def validate_storm_category ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Args: value (EnvInputAttr): Value assigned to the attribute (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) csv_values = pd . read_csv ( value , sep = \" \\t \" ) csv_values . set_index ( \"year\" , inplace = True ) return csv_values raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) @validator ( \"dates\" , pre = True ) @classmethod def prevalidate_dates ( cls , value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] ) -> pd . DataFrame : \"\"\" Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Args: value (Union[pd.DataFrame, Iterable[Union[str, datetime]]]): Value assigned to the attribute. Raises: NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , Iterable ): return cls . get_dates_dataframe ( value [ 0 ], value [ - 1 ]) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) @validator ( \"dates\" , always = True , pre = False ) @classmethod def check_dates ( cls , v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame : \"\"\" Validates the dates value (post-process). Args: v (Optional[pd.DataFrame]): Value pre-validated for dates (if any). values (dict): Dictionary containing the rest of values given to initialize 'Environment'. Returns: pd.DataFrame: Validated dates value. \"\"\" # Validate dates have values. if isinstance ( v , pd . DataFrame ): return v light_value : pd . DataFrame = values . get ( \"light\" , None ) if light_value is not None : # TODO: Check column name of light-file return light_value . reset_index () . drop ( \"light\" , axis = 1 ) temp_value : pd . DataFrame = values . get ( \"temperature\" , None ) if temp_value is not None : return temp_value . reset_index () . drop ( \"sst\" , axis = 1 ) return None @staticmethod def get_dates_dataframe ( start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ) -> pd . DataFrame : dates = pd . date_range ( start_date , end_date , freq = \"D\" ) return pd . DataFrame ({ \"date\" : dates }) def get_dates ( self ) -> Iterable [ datetime ]: \"\"\" Just a shortcut being used in some occasions to get the datetime series array. Raises: ValueError: When no dates could be set for the 'Environment'. Returns: pd.Series[datetime]: Collection of timeseries stored in Environment.dates \"\"\" if self . dates is None : raise ValueError ( \"No values were assigned to dates.\" ) return pd . to_datetime ( self . dates [ \"date\" ]) def set_dates ( self , start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ): \"\"\" Set dates manually, ignoring possible dates in environmental time-series. Args: start_date (Union[str, datetime]): Start of the range dates. end_date (Union[str, datetime]): End of the range dates. \"\"\" self . dates = self . get_dates_dataframe ( start_date , end_date ) @property def temp_kelvin ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Kelvin. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values < 100 ) and self . temperature is not None : return self . temperature + 273.15 return self . temperature @property def temp_celsius ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Celsius. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values > 100 ) and self . temperature is not None : return self . temperature - 273.15 return self . temperature @property def temp_mmm ( self ) -> pd . DataFrame : \"\"\" Temperature in Monthly mean. Returns: pd.DataFrame: value as a pandas DataFrame. \"\"\" monthly_mean = self . temp_kelvin . groupby ( [ self . temp_kelvin . index . year , self . temp_kelvin . index . month ] ) . agg ([ \"mean\" ]) monthly_maximum_mean = monthly_mean . groupby ( level = 0 ) . agg ([ \"min\" , \"max\" ]) monthly_maximum_mean . columns = monthly_maximum_mean . columns . droplevel ([ 0 , 1 ]) return monthly_maximum_mean EnvironmentValue = Union [ float , list , tuple , np . ndarray , pd . DataFrame ] def set_parameter_values ( self , parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ): \"\"\" Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Args: parameter (str): Parameter to be set. value (EnvironmentValue): New value for the parameter. pre_date (Optional[int], optional): Time-series start before simulation dates [yrs]. Defaults to None. \"\"\" def set_value ( val ): \"\"\"Function to set value.\"\"\" simple_dates = self . get_dates () if pre_date is None : return pd . DataFrame ({ parameter : val }, index = simple_dates ) dates = pd . date_range ( simple_dates . iloc [ 0 ] - pd . DateOffset ( years = pre_date ), simple_dates . iloc [ - 1 ], freq = \"D\" , ) return pd . DataFrame ({ parameter : val }, index = dates ) if self . dates is None : msg = ( f \"No dates are defined. \" f \"Please, first specify the dates before setting the time-series of { parameter } ; \" f 'or make use of the \"from_file\"-method.' ) raise TypeError ( msg ) if parameter == \"LAC\" : parameter = \"light_attenuation\" daily_params = ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" ) if parameter in daily_params : setattr ( self , parameter , set_value ( value )) elif parameter == \"storm\" : years = set ( self . get_dates () . dt . year ) self . storm_category = pd . DataFrame ( data = value , index = years ) else : msg = f \"Entered parameter ( { parameter } ) not included. See documentation.\" raise ValueError ( msg )","title":"Environment"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.check_dates","text":"Validates the dates value (post-process). Parameters: Name Type Description Default v Optional [ pd . DataFrame ] Value pre-validated for dates (if any). required values dict Dictionary containing the rest of values given to initialize 'Environment'. required Returns: Type Description pd . DataFrame pd.DataFrame: Validated dates value. Source code in src/core/common/environment.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @validator ( \"dates\" , always = True , pre = False ) @classmethod def check_dates ( cls , v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame : \"\"\" Validates the dates value (post-process). Args: v (Optional[pd.DataFrame]): Value pre-validated for dates (if any). values (dict): Dictionary containing the rest of values given to initialize 'Environment'. Returns: pd.DataFrame: Validated dates value. \"\"\" # Validate dates have values. if isinstance ( v , pd . DataFrame ): return v light_value : pd . DataFrame = values . get ( \"light\" , None ) if light_value is not None : # TODO: Check column name of light-file return light_value . reset_index () . drop ( \"light\" , axis = 1 ) temp_value : pd . DataFrame = values . get ( \"temperature\" , None ) if temp_value is not None : return temp_value . reset_index () . drop ( \"sst\" , axis = 1 ) return None","title":"check_dates()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.get_dates","text":"Just a shortcut being used in some occasions to get the datetime series array. Raises: Type Description ValueError When no dates could be set for the 'Environment'. Returns: Type Description Iterable [ datetime ] pd.Series[datetime]: Collection of timeseries stored in Environment.dates Source code in src/core/common/environment.py 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_dates ( self ) -> Iterable [ datetime ]: \"\"\" Just a shortcut being used in some occasions to get the datetime series array. Raises: ValueError: When no dates could be set for the 'Environment'. Returns: pd.Series[datetime]: Collection of timeseries stored in Environment.dates \"\"\" if self . dates is None : raise ValueError ( \"No values were assigned to dates.\" ) return pd . to_datetime ( self . dates [ \"date\" ])","title":"get_dates()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.prevalidate_dates","text":"Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Parameters: Name Type Description Default value Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] Value assigned to the attribute. required Raises: Type Description NotImplementedError When the provided value is not supported. Returns: Type Description pd . DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @validator ( \"dates\" , pre = True ) @classmethod def prevalidate_dates ( cls , value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] ) -> pd . DataFrame : \"\"\" Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Args: value (Union[pd.DataFrame, Iterable[Union[str, datetime]]]): Value assigned to the attribute. Raises: NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , Iterable ): return cls . get_dates_dataframe ( value [ 0 ], value [ - 1 ]) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" )","title":"prevalidate_dates()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.set_dates","text":"Set dates manually, ignoring possible dates in environmental time-series. Parameters: Name Type Description Default start_date Union [ str , datetime ] Start of the range dates. required end_date Union [ str , datetime ] End of the range dates. required Source code in src/core/common/environment.py 168 169 170 171 172 173 174 175 176 177 178 179 def set_dates ( self , start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ): \"\"\" Set dates manually, ignoring possible dates in environmental time-series. Args: start_date (Union[str, datetime]): Start of the range dates. end_date (Union[str, datetime]): End of the range dates. \"\"\" self . dates = self . get_dates_dataframe ( start_date , end_date )","title":"set_dates()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.set_parameter_values","text":"Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Parameters: Name Type Description Default parameter str Parameter to be set. required value EnvironmentValue New value for the parameter. required pre_date Optional [ int ] Time-series start before simulation dates [yrs]. Defaults to None. None Source code in src/core/common/environment.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def set_parameter_values ( self , parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ): \"\"\" Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Args: parameter (str): Parameter to be set. value (EnvironmentValue): New value for the parameter. pre_date (Optional[int], optional): Time-series start before simulation dates [yrs]. Defaults to None. \"\"\" def set_value ( val ): \"\"\"Function to set value.\"\"\" simple_dates = self . get_dates () if pre_date is None : return pd . DataFrame ({ parameter : val }, index = simple_dates ) dates = pd . date_range ( simple_dates . iloc [ 0 ] - pd . DateOffset ( years = pre_date ), simple_dates . iloc [ - 1 ], freq = \"D\" , ) return pd . DataFrame ({ parameter : val }, index = dates ) if self . dates is None : msg = ( f \"No dates are defined. \" f \"Please, first specify the dates before setting the time-series of { parameter } ; \" f 'or make use of the \"from_file\"-method.' ) raise TypeError ( msg ) if parameter == \"LAC\" : parameter = \"light_attenuation\" daily_params = ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" ) if parameter in daily_params : setattr ( self , parameter , set_value ( value )) elif parameter == \"storm\" : years = set ( self . get_dates () . dt . year ) self . storm_category = pd . DataFrame ( data = value , index = years ) else : msg = f \"Entered parameter ( { parameter } ) not included. See documentation.\" raise ValueError ( msg )","title":"set_parameter_values()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.temp_celsius","text":"Gets the temperature property in Celsius. Returns: Type Description pd . DataFrame pd.DataFrame: value representation. Source code in src/core/common/environment.py 193 194 195 196 197 198 199 200 201 202 203 @property def temp_celsius ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Celsius. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values > 100 ) and self . temperature is not None : return self . temperature - 273.15 return self . temperature","title":"temp_celsius()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.temp_kelvin","text":"Gets the temperature property in Kelvin. Returns: Type Description pd . DataFrame pd.DataFrame: value representation. Source code in src/core/common/environment.py 181 182 183 184 185 186 187 188 189 190 191 @property def temp_kelvin ( self ) -> pd . DataFrame : \"\"\" Gets the temperature property in Kelvin. Returns: pd.DataFrame: value representation. \"\"\" if all ( self . temperature . values < 100 ) and self . temperature is not None : return self . temperature + 273.15 return self . temperature","title":"temp_kelvin()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.temp_mmm","text":"Temperature in Monthly mean. Returns: Type Description pd . DataFrame pd.DataFrame: value as a pandas DataFrame. Source code in src/core/common/environment.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 @property def temp_mmm ( self ) -> pd . DataFrame : \"\"\" Temperature in Monthly mean. Returns: pd.DataFrame: value as a pandas DataFrame. \"\"\" monthly_mean = self . temp_kelvin . groupby ( [ self . temp_kelvin . index . year , self . temp_kelvin . index . month ] ) . agg ([ \"mean\" ]) monthly_maximum_mean = monthly_mean . groupby ( level = 0 ) . agg ([ \"min\" , \"max\" ]) monthly_maximum_mean . columns = monthly_maximum_mean . columns . droplevel ([ 0 , 1 ]) return monthly_maximum_mean","title":"temp_mmm()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.validate_dataframe_or_path","text":"Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Parameters: Name Type Description Default value EnvInputAttr Value to be validated (Union[pd.DataFrame, Path, str]). required Raises: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description pd . DataFrame pd.DataFrame: Validated attribute value. Source code in src/core/common/environment.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @validator ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" , pre = True ) @classmethod def validate_dataframe_or_path ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Args: value (EnvInputAttr): Value to be validated (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated attribute value. \"\"\" def read_index ( value_file : Path ) -> pd . DataFrame : \"\"\"Function applicable to time-series in Pandas.\"\"\" time_series = pd . read_csv ( value_file , sep = \" \\t \" ) if time_series . isnull () . values . any (): msg = f \"NaNs detected in time series { value_file } \" raise ValueError ( msg ) time_series [ \"date\" ] = pd . to_datetime ( time_series [ \"date\" ]) time_series . set_index ( \"date\" , inplace = True ) return time_series if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) return read_index ( value ) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" )","title":"validate_dataframe_or_path()"},{"location":"reference/core/common/common/#src.core.common.environment.Environment.validate_storm_category","text":"Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Parameters: Name Type Description Default value EnvInputAttr Value assigned to the attribute (Union[pd.DataFrame, Path, str]). required Raises: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description pd . DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @validator ( \"storm_category\" , pre = True ) @classmethod def validate_storm_category ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Args: value (EnvInputAttr): Value assigned to the attribute (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) csv_values = pd . read_csv ( value , sep = \" \\t \" ) csv_values . set_index ( \"year\" , inplace = True ) return csv_values raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" )","title":"validate_storm_category()"},{"location":"reference/core/common/common/#singletons","text":"This file is intended to contain all the common classes used as unique object throughout the NBSDynamics project. Although these classes are defined elsewhere, here we implement them as singletons.","title":"Singletons"},{"location":"reference/core/common/common/#src.core.common.singletons.RESHAPE","text":"Bases: Singleton , DataReshape DataReshape Singleton. Source code in src/core/common/singletons.py 24 25 26 27 28 29 class RESHAPE ( Singleton , DataReshape ): \"\"\" `DataReshape` Singleton. \"\"\" pass","title":"RESHAPE"},{"location":"reference/core/common/common/#src.core.common.singletons.Singleton","text":"Bases: object Singleton class representing the design pattern. This class can be used for concepts that are not meant to change state during a simulation such as DataReshape, represented by RESHAPE. Source code in src/core/common/singletons.py 9 10 11 12 13 14 15 16 17 18 19 20 21 class Singleton ( object ): \"\"\" Singleton class representing the design pattern. This class can be used for concepts that are not meant to change state during a simulation such as DataReshape, represented by RESHAPE. \"\"\" _instance = None def __new__ ( cls , * args , ** kwargs ): if not isinstance ( cls . _instance , cls ): cls . _instance = object . __new__ ( cls , * args , ** kwargs ) return cls . _instance","title":"Singleton"},{"location":"reference/core/common/common/#spacetime","text":"coral_model - utils veg_model - utils @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman","title":"SpaceTime"},{"location":"reference/core/common/common/#src.core.common.space_time.DataReshape","text":"Bases: SpaceTime Reshape data to create a spacetime matrix. Source code in src/core/common/space_time.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class DataReshape ( SpaceTime ): \"\"\"Reshape data to create a spacetime matrix.\"\"\" def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" super () . __init__ ( spacetime = spacetime ) def variable2matrix ( self , variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ): \"\"\"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # dimension-value variable = self . variable2array ( variable ) self . dimension_value ( variable , dimension ) # # transformation if dimension == \"space\" : return np . tile ( variable , ( self . time , 1 )) . transpose () elif dimension == \"time\" : return np . tile ( variable , ( self . space , 1 )) def dimension_value ( self , variable : Union [ list , tuple , np . ndarray ], dimension : str ): \"\"\"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str \"\"\" try : _ = len ( variable ) except TypeError : variable = [ variable ] if not len ( variable ) == getattr ( self , dimension ): msg = f \"Incorrect variable size, { len ( variable ) } =/= { getattr ( self , dimension ) } .\" raise ValueError ( msg ) @staticmethod def variable2array ( variable : Union [ float , int , list , np . ndarray ]): \"\"\" \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray \"\"\" if isinstance ( variable , str ): msg = f \"Variable cannot be of { type ( variable ) } .\" raise NotImplementedError ( msg ) elif isinstance ( variable , ( float , int )): return np . array ([ float ( variable )]) elif isinstance ( variable , ( list , tuple )): return np . array ( variable ) elif isinstance ( variable , np . ndarray ) and not variable . shape : return np . array ([ variable ]) return variable def matrix2array ( self , matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ): \"\"\"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # input as numpy.array matrix = np . array ( matrix ) # dimension-value if ( not matrix . shape == self . spacetime and not matrix . shape [: 2 ] == self . spacetime ): msg = ( f \"Matrix-shape does not correspond with spacetime-dimensions:\" f \" \\n { matrix . shape } =/= { self . spacetime } \" ) raise ValueError ( msg ) # conversion-strategy conversions = ( None , \"mean\" , \"max\" , \"min\" , \"sum\" ) if conversion not in conversions : msg = f \" { conversion } not in { conversions } .\" raise ValueError ( msg ) # # transformation # last position if conversion is None : if dimension == \"space\" : return matrix [:, - 1 ] elif dimension == \"time\" : return matrix [ - 1 , :] # conversion if dimension == \"space\" : return getattr ( matrix , conversion )( axis = 1 ) elif dimension == \"time\" : return getattr ( matrix , conversion )( axis = 0 )","title":"DataReshape"},{"location":"reference/core/common/common/#src.core.common.space_time.DataReshape.__init__","text":":param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional Source code in src/core/common/space_time.py 128 129 130 131 132 133 def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" super () . __init__ ( spacetime = spacetime )","title":"__init__()"},{"location":"reference/core/common/common/#src.core.common.space_time.DataReshape.dimension_value","text":"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str Source code in src/core/common/space_time.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def dimension_value ( self , variable : Union [ list , tuple , np . ndarray ], dimension : str ): \"\"\"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str \"\"\" try : _ = len ( variable ) except TypeError : variable = [ variable ] if not len ( variable ) == getattr ( self , dimension ): msg = f \"Incorrect variable size, { len ( variable ) } =/= { getattr ( self , dimension ) } .\" raise ValueError ( msg )","title":"dimension_value()"},{"location":"reference/core/common/common/#src.core.common.space_time.DataReshape.matrix2array","text":"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def matrix2array ( self , matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ): \"\"\"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # input as numpy.array matrix = np . array ( matrix ) # dimension-value if ( not matrix . shape == self . spacetime and not matrix . shape [: 2 ] == self . spacetime ): msg = ( f \"Matrix-shape does not correspond with spacetime-dimensions:\" f \" \\n { matrix . shape } =/= { self . spacetime } \" ) raise ValueError ( msg ) # conversion-strategy conversions = ( None , \"mean\" , \"max\" , \"min\" , \"sum\" ) if conversion not in conversions : msg = f \" { conversion } not in { conversions } .\" raise ValueError ( msg ) # # transformation # last position if conversion is None : if dimension == \"space\" : return matrix [:, - 1 ] elif dimension == \"time\" : return matrix [ - 1 , :] # conversion if dimension == \"space\" : return getattr ( matrix , conversion )( axis = 1 ) elif dimension == \"time\" : return getattr ( matrix , conversion )( axis = 0 )","title":"matrix2array()"},{"location":"reference/core/common/common/#src.core.common.space_time.DataReshape.variable2array","text":"\"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 @staticmethod def variable2array ( variable : Union [ float , int , list , np . ndarray ]): \"\"\" \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray \"\"\" if isinstance ( variable , str ): msg = f \"Variable cannot be of { type ( variable ) } .\" raise NotImplementedError ( msg ) elif isinstance ( variable , ( float , int )): return np . array ([ float ( variable )]) elif isinstance ( variable , ( list , tuple )): return np . array ( variable ) elif isinstance ( variable , np . ndarray ) and not variable . shape : return np . array ([ variable ]) return variable","title":"variable2array()"},{"location":"reference/core/common/common/#src.core.common.space_time.DataReshape.variable2matrix","text":"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray Source code in src/core/common/space_time.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def variable2matrix ( self , variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ): \"\"\"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # dimension-value variable = self . variable2array ( variable ) self . dimension_value ( variable , dimension ) # # transformation if dimension == \"space\" : return np . tile ( variable , ( self . time , 1 )) . transpose () elif dimension == \"time\" : return np . tile ( variable , ( self . space , 1 ))","title":"variable2matrix()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime","text":"Spacetime-object, which validates the definition of the spacetime dimensions. Source code in src/core/common/space_time.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class SpaceTime : \"\"\"Spacetime-object, which validates the definition of the spacetime dimensions.\"\"\" __spacetime = None def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" if spacetime is not None : self . spacetime = spacetime self . set_coral_only ( self . spacetime ) self . set_veg_only ( self . spacetime ) def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"SpaceTime( { self . __spacetime } )\" def __str__ ( self ): \"\"\"Print representation.\"\"\" return str ( self . spacetime ) @property def spacetime ( self ): \"\"\"Spacetime dimensions. :rtype: tuple \"\"\" if self . __spacetime is None : return 1 , 1 return self . __spacetime @spacetime . setter def spacetime ( self , space_time : Union [ Tuple , list , np . ndarray ]): \"\"\" :param space_time: spacetime dimensions :type space_time: tuple, list, numpy.ndarray \"\"\" if not isinstance ( space_time , ( tuple , list , np . ndarray )): msg = f \"spacetime must be of type tuple, { type ( space_time ) } is given.\" raise TypeError ( msg ) if not len ( space_time ) == 2 : msg = f \"spacetime must be of size 2, { len ( space_time ) } is given.\" raise ValueError ( msg ) if not all ( isinstance ( dim , int ) for dim in space_time ): msg = f \"spacetime must consist of integers only, { [ type ( dim ) for dim in space_time ] } is given.\" raise TypeError ( msg ) self . __spacetime = tuple ( space_time ) self . set_coral_only ( tuple ( space_time )) self . set_veg_only ( tuple ( space_time )) @property def space ( self ) -> int : \"\"\"Space dimension. :rtype: int \"\"\" return self . spacetime [ 0 ] @space . setter def space ( self , x : int ): \"\"\" :param x: space dimension :type x: int \"\"\" self . spacetime = ( x , self . time ) @property def time ( self ) -> int : \"\"\"Time dimension. :rtype: int \"\"\" return self . spacetime [ 1 ] @time . setter def time ( self , t : int ): \"\"\" :param t: time dimension :type t: int \"\"\" self . spacetime = ( self . space , t ) # TODO: Refactor to a private method def set_coral_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" CoralOnly . spacetime = spacetime def set_veg_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the VegOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" VegOnly . spacetime = spacetime","title":"SpaceTime"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.__init__","text":":param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional Source code in src/core/common/space_time.py 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" if spacetime is not None : self . spacetime = spacetime self . set_coral_only ( self . spacetime ) self . set_veg_only ( self . spacetime )","title":"__init__()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.__repr__","text":"Development representation. Source code in src/core/common/space_time.py 35 36 37 def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"SpaceTime( { self . __spacetime } )\"","title":"__repr__()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.__str__","text":"Print representation. Source code in src/core/common/space_time.py 39 40 41 def __str__ ( self ): \"\"\"Print representation.\"\"\" return str ( self . spacetime )","title":"__str__()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.set_coral_only","text":"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple Source code in src/core/common/space_time.py 108 109 110 111 112 113 114 def set_coral_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" CoralOnly . spacetime = spacetime","title":"set_coral_only()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.set_veg_only","text":"Automatically set the spacetime dimensions for the VegOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple Source code in src/core/common/space_time.py 116 117 118 119 120 121 122 def set_veg_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the VegOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" VegOnly . spacetime = spacetime","title":"set_veg_only()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.space","text":"Space dimension. :rtype: int Source code in src/core/common/space_time.py 75 76 77 78 79 80 81 @property def space ( self ) -> int : \"\"\"Space dimension. :rtype: int \"\"\" return self . spacetime [ 0 ]","title":"space()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.spacetime","text":"Spacetime dimensions. :rtype: tuple Source code in src/core/common/space_time.py 43 44 45 46 47 48 49 50 51 @property def spacetime ( self ): \"\"\"Spacetime dimensions. :rtype: tuple \"\"\" if self . __spacetime is None : return 1 , 1 return self . __spacetime","title":"spacetime()"},{"location":"reference/core/common/common/#src.core.common.space_time.SpaceTime.time","text":"Time dimension. :rtype: int Source code in src/core/common/space_time.py 91 92 93 94 95 96 97 @property def time ( self ) -> int : \"\"\"Time dimension. :rtype: int \"\"\" return self . spacetime [ 1 ]","title":"time()"},{"location":"reference/core/common/common/#src.core.common.space_time.time_series_year","text":"Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int Source code in src/core/common/space_time.py 268 269 270 271 272 273 274 275 276 277 def time_series_year ( time_series : DataFrame , year : int ): \"\"\"Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int \"\"\" return time_series [ time_series . index . year == year ] . values . transpose ()[ 0 ]","title":"time_series_year()"},{"location":"reference/core/hydrodynamics/hydromodels/","text":"Hydrodynamic simulation models. \u00b6 Factory \u00b6 HydrodynamicsFactory \u00b6 Factory class to select hydrodynamic models. It also works as a binding model-protocol between the hydrodynamic models and the HydrodynamicProtocol . Source code in src/core/hydrodynamics/factory.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class HydrodynamicsFactory : \"\"\" Factory class to select hydrodynamic models. It also works as a binding model-protocol between the hydrodynamic models and the `HydrodynamicProtocol`. \"\"\" supported_modes : List [ HydrodynamicProtocol ] = [ Reef0D , Reef1D , DimrModel , FlowFmModel , Transect , ] @staticmethod def get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol : \"\"\" Returns the type associated with the given model name. Args: model_name (str): Model name to retrieve. Raises: ValueError: When the model name is not associated with a valid `HydrodynamicProtocol`. Returns: HydrodynamicProtocol: The requested model type. \"\"\" nm_name = model_name . lower () if model_name is not None else model_name hydromodel : HydrodynamicProtocol = next ( ( m_type for m_type in HydrodynamicsFactory . supported_modes if m_type . __name__ . lower () == nm_name ), None , ) if hydromodel is None : msg = f \" { model_name } not in { [ x . __name__ for x in HydrodynamicsFactory . supported_modes ] } .\" raise ValueError ( msg ) return hydromodel @staticmethod def create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol : \"\"\" Creates a `HydrodynamicProtocol` based on the model_name type and the dictionary of values (if any) given. Args: model_name (str): Model type name. Returns: HydrodynamicProtocol: Instance of the requested model. \"\"\" m_type : HydrodynamicProtocol = HydrodynamicsFactory . get_hydrodynamic_model_type ( model_name ) return m_type ( ** kwargs ) create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol staticmethod \u00b6 Creates a HydrodynamicProtocol based on the model_name type and the dictionary of values (if any) given. Parameters: Name Type Description Default model_name str Model type name. required Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol Instance of the requested model. Source code in src/core/hydrodynamics/factory.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @staticmethod def create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol : \"\"\" Creates a `HydrodynamicProtocol` based on the model_name type and the dictionary of values (if any) given. Args: model_name (str): Model type name. Returns: HydrodynamicProtocol: Instance of the requested model. \"\"\" m_type : HydrodynamicProtocol = HydrodynamicsFactory . get_hydrodynamic_model_type ( model_name ) return m_type ( ** kwargs ) get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol staticmethod \u00b6 Returns the type associated with the given model name. Parameters: Name Type Description Default model_name str Model name to retrieve. required Raises: Type Description ValueError When the model name is not associated with a valid HydrodynamicProtocol . Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol The requested model type. Source code in src/core/hydrodynamics/factory.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @staticmethod def get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol : \"\"\" Returns the type associated with the given model name. Args: model_name (str): Model name to retrieve. Raises: ValueError: When the model name is not associated with a valid `HydrodynamicProtocol`. Returns: HydrodynamicProtocol: The requested model type. \"\"\" nm_name = model_name . lower () if model_name is not None else model_name hydromodel : HydrodynamicProtocol = next ( ( m_type for m_type in HydrodynamicsFactory . supported_modes if m_type . __name__ . lower () == nm_name ), None , ) if hydromodel is None : msg = f \" { model_name } not in { [ x . __name__ for x in HydrodynamicsFactory . supported_modes ] } .\" raise ValueError ( msg ) return hydromodel Protocol \u00b6 HydrodynamicProtocol \u00b6 Bases: Protocol Protocol describing the mandatory properties and methods to be implemented by any hydromodel. The binding between a model and the protocol is made at the factory level ('HydrodynamicsFactory'). Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @runtime_checkable class HydrodynamicProtocol ( Protocol ): \"\"\" Protocol describing the mandatory properties and methods to be implemented by any hydromodel. The binding between a model and the protocol is made at the factory level ('HydrodynamicsFactory'). \"\"\" @property def config_file ( self ) -> Path : \"\"\" Configuration file for the model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the configuration file. \"\"\" raise NotImplementedError @property def definition_file ( self ) -> Path : \"\"\" Model definition file, its format (extension) may vary per file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the definition file. \"\"\" raise NotImplementedError @property def settings ( self ) -> str : \"\"\" Print settings of the hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: The settings as string representation. \"\"\" raise NotImplementedError @property def water_depth ( self ) -> np . ndarray : \"\"\" Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Water depth value as numpy array. \"\"\" raise NotImplementedError @property def space ( self ) -> int : \"\"\" Space-dimension Raises: NotImplementedError: When the model does not implement its own definition. Returns: int: Value of the space-dimension. \"\"\" raise NotImplementedError @property def x_coordinates ( self ) -> np . ndarray : \"\"\" The x-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X coordinates as numpy array. \"\"\" raise NotImplementedError @property def y_coordinates ( self ) -> np . ndarray : \"\"\" The y-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Y coordinates as numpy array. \"\"\" raise NotImplementedError @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X,Y coordinates as numpy array. \"\"\" raise NotImplementedError def initiate ( self ): \"\"\" Initiates the working model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update ( self , biota : Biota , stormcat : int ): \"\"\" Updates the model with the given parameters. Args: biota (Biota): Model representing a living entity. stormcat (int): Category of storm to apply. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def finalise ( self ): \"\"\" Finalizes the model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError config_file () -> Path property \u00b6 Configuration file for the model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Path Path The path to the configuration file. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 16 17 18 19 20 21 22 23 24 25 26 27 @property def config_file ( self ) -> Path : \"\"\" Configuration file for the model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the configuration file. \"\"\" raise NotImplementedError definition_file () -> Path property \u00b6 Model definition file, its format (extension) may vary per file. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Path Path The path to the definition file. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 29 30 31 32 33 34 35 36 37 38 39 40 @property def definition_file ( self ) -> Path : \"\"\" Model definition file, its format (extension) may vary per file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the definition file. \"\"\" raise NotImplementedError finalise () \u00b6 Finalizes the model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 142 143 144 145 146 147 148 149 def finalise ( self ): \"\"\" Finalizes the model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError initiate () \u00b6 Initiates the working model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 120 121 122 123 124 125 126 127 def initiate ( self ): \"\"\" Initiates the working model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError settings () -> str property \u00b6 Print settings of the hydrodynamic model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str The settings as string representation. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 42 43 44 45 46 47 48 49 50 51 52 53 @property def settings ( self ) -> str : \"\"\" Print settings of the hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: The settings as string representation. \"\"\" raise NotImplementedError space () -> int property \u00b6 Space-dimension Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description int int Value of the space-dimension. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 68 69 70 71 72 73 74 75 76 77 78 79 @property def space ( self ) -> int : \"\"\" Space-dimension Raises: NotImplementedError: When the model does not implement its own definition. Returns: int: Value of the space-dimension. \"\"\" raise NotImplementedError update ( biota : Biota , stormcat : int ) \u00b6 Updates the model with the given parameters. Parameters: Name Type Description Default biota Biota Model representing a living entity. required stormcat int Category of storm to apply. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 129 130 131 132 133 134 135 136 137 138 139 140 def update ( self , biota : Biota , stormcat : int ): \"\"\" Updates the model with the given parameters. Args: biota (Biota): Model representing a living entity. stormcat (int): Category of storm to apply. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError water_depth () -> np . ndarray property \u00b6 Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: Water depth value as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 55 56 57 58 59 60 61 62 63 64 65 66 @property def water_depth ( self ) -> np . ndarray : \"\"\" Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Water depth value as numpy array. \"\"\" raise NotImplementedError x_coordinates () -> np . ndarray property \u00b6 The x-coordinates of the model domain. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: X coordinates as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 81 82 83 84 85 86 87 88 89 90 91 92 @property def x_coordinates ( self ) -> np . ndarray : \"\"\" The x-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X coordinates as numpy array. \"\"\" raise NotImplementedError xy_coordinates () -> np . ndarray property \u00b6 The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: X,Y coordinates as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 107 108 109 110 111 112 113 114 115 116 117 118 @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X,Y coordinates as numpy array. \"\"\" raise NotImplementedError y_coordinates () -> np . ndarray property \u00b6 The y-coordinates of the model domain. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: Y coordinates as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 94 95 96 97 98 99 100 101 102 103 104 105 @property def y_coordinates ( self ) -> np . ndarray : \"\"\" The y-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Y coordinates as numpy array. \"\"\" raise NotImplementedError Delft3D \u00b6 Delft3D \u00b6 Bases: ExtraModel , abc . ABC Implements the HydrodynamicProtocol . Coupling of coral_model to Delft3D using the BMI wrapper. Source code in src/core/hydrodynamics/delft3d.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class Delft3D ( ExtraModel , abc . ABC ): \"\"\" Implements the `HydrodynamicProtocol`. Coupling of coral_model to Delft3D using the BMI wrapper. \"\"\" # Define model attributes. time_step : Optional [ np . datetime64 ] = None model_wrapper : Optional [ BMIWrapper ] = None d3d_home : Optional [ Path ] = None # Delft3D binaries home directory. working_dir : Optional [ Path ] = None # Model working directory. definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None dll_path : Optional [ Path ] = None update_interval : Optional [ int ] = None update_interval_storm : Optional [ int ] = None def __repr__ ( self ): return \"Delft3D()\" @property @abstractmethod def space ( self ) -> Optional [ int ]: raise NotImplementedError def get_variable ( self , variable : str ) -> Optional [ WrapperVariable ]: \"\"\" Get variable from the model wrapper. Args: variable (str): Variable to retrieve. Returns: Optional[WrapperVariable]: Value found. \"\"\" return self . model_wrapper . get_var ( variable ) def set_variable ( self , variable : str , value : Optional [ WrapperVariable ]): \"\"\" Set variable to model wrapper. Args: variable (str): Variable to set. value (Optional[WrapperVariable]): Value to set. \"\"\" self . model_wrapper . set_var ( variable , value ) def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" ,) [ self . input_check_definition ( file ) for file in files ] interval_types = ( \"update_interval\" , \"update_interval_storm\" ) [ self . input_check_definition ( interval ) for interval in interval_types ] def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self . model_wrapper , obj ) is None : msg = f \" { obj } undefined (required for Delft3D coupling)\" raise ValueError ( msg ) def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" sums = self . get_variable ( \"is_sumvalsnd\" ) sums . fill ( 0.0 ) self . set_variable ( \"is_sumvalsnd\" , sums ) maxs = self . get_variable ( \"is_maxvalsnd\" ) maxs . fill ( 0.0 ) self . set_variable ( \"is_maxvalsnd\" , maxs ) def set_morphology ( self , coral : Coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" self . set_variable ( \"rnveg\" , coral . as_vegetation_density ) self . set_variable ( \"diaveg\" , coral . dc_rep ) self . set_variable ( \"stemheight\" , coral . hc ) def set_vegetation ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ] ): \"\"\"Set vegetation dimensions to Delft3D-model. :param veg_species1: vegetation of a specific species :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type veg_species2: Vegetation \"\"\" if not veg_species2 : self . set_variable ( \"rnveg\" , veg_species1 . veg_den ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , veg_species1 . av_stemdia ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , veg_species1 . av_height ) # [m] 2D plant heights (m) else : ## TODO TEST THIS! self . set_variable ( \"rnveg\" , ( veg_species1 . veg_den + veg_species2 . veg_den ) ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , ( veg_species1 . av_stemdia + veg_species2 . av_stemdia ) ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , ( veg_species1 . av_height + veg_species2 . av_height ) ) # [m] 2D plant heights (m) def get_mean_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; mean values.\"\"\" if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) current_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per def get_max_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; max. values.\"\"\" current_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per def get_hydromorphodynamics ( self ): \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" # TODO Add the minimum values when it is implemented in the model as a variable max_tau = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 0 ] max_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] max_wl = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 2 ] bed_level = self . get_variable ( \"bl\" ) return max_tau , max_wl , max_vel , bed_level def get_current_hydromorphodynamics ( self , time_step ): # only needed as long as we cannot get minval from the wrapper \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" self . time_step = time_step bed_level = self . get_variable ( \"bl\" )[ range ( self . space )] # bed_level = np.delete(bed_level, np.where(bed_level <= -5)) # cur_tau = self.get_variable('taus') # cur_vel = self.get_variable('u1') # cur1_vel = self.get_variable('ucx') # cur2_vel = self.get_variable('ucy') # cur_wl = self.get_variable('s1') dt_int = self . get_variable ( \"is_dtint\" ) cur_tau = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 0 ] / self . time_step ) cur_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) cur_wl = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) return cur_tau , cur_wl , cur_vel , bed_level @abstractmethod def configure_model_wrapper ( self ): \"\"\" Configures the model wrapper with the specifics of its type. Raises: NotImplementedError: When the concrete class does not define its own implementation. \"\"\" raise NotImplementedError @abstractmethod def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables to include in a Delft3D model run. \"\"\" raise NotImplementedError ( \"Implement in concrete class\" ) def _get_sys_environment_key ( self ) -> str : os_key = dict ( win32 = \"PATH\" , linux = \"LD_LIBRARY_PATH\" , darwin = \"DYLD_LIBRARY_PATH\" ) env_key : str = os_key . get ( sys . platform , None ) if env_key is None : raise NotImplementedError ( f \"System { sys . platform } not supported for a Delft3D run.\" ) return env_key def set_environment_variables ( self ): \"\"\" Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) not in path_var : path_var += f \"; { str ( env_var ) } \" os . environ [ env_key ] = path_var def cleanup_environment_variables ( self ): \"\"\" Remove unnecessary environment variables from system. \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) in path_var : path_var . replace ( f \"; { str ( env_var ) } \" , \"\" ) os . environ [ env_key ] = path_var def initiate ( self ): \"\"\" Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. \"\"\" self . set_environment_variables () self . configure_model_wrapper () self . model_wrapper . initialize () def update ( self , coral , stormcat = 0 ): \"\"\"Update the Delft3D-model.\"\"\" self . time_step = ( self . update_interval_storm if stormcat > 0 else self . update_interval ) self . reset_counters () self . model_wrapper . update ( self . time_step ) return ( self . get_max_hydrodynamics () if stormcat > 0 else self . get_mean_hydrodynamics () ) ## TODO input timestep is in days! what is the unit here? def update_hydromorphodynamics ( self , veg_species1 : Vegetation , time_step : int , veg_species2 : Optional [ Vegetation ], ): \"\"\"Update the Delft3D-model. :param veg_species1: vegetation of a specific species :param time_step: time step of delft FM in seconds :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type time_step: int :type veg_species2: Vegetation \"\"\" self . time_step = time_step self . reset_counters () self . set_vegetation ( veg_species1 , veg_species2 ) # if not veg_species2: # self.set_vegetation(veg_species1) # else: # self . model_wrapper . update ( self . time_step ) return self . get_current_hydromorphodynamics ( time_step = self . time_step ) def finalise ( self ): \"\"\"Finalize the working model.\"\"\" self . model_wrapper . finalize () cleanup_environment_variables () \u00b6 Remove unnecessary environment variables from system. Source code in src/core/hydrodynamics/delft3d.py 235 236 237 238 239 240 241 242 243 244 245 246 def cleanup_environment_variables ( self ): \"\"\" Remove unnecessary environment variables from system. \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) in path_var : path_var . replace ( f \"; { str ( env_var ) } \" , \"\" ) os . environ [ env_key ] = path_var configure_model_wrapper () abstractmethod \u00b6 Configures the model wrapper with the specifics of its type. Raises: Type Description NotImplementedError When the concrete class does not define its own implementation. Source code in src/core/hydrodynamics/delft3d.py 193 194 195 196 197 198 199 200 201 @abstractmethod def configure_model_wrapper ( self ): \"\"\" Configures the model wrapper with the specifics of its type. Raises: NotImplementedError: When the concrete class does not define its own implementation. \"\"\" raise NotImplementedError finalise () \u00b6 Finalize the working model. Source code in src/core/hydrodynamics/delft3d.py 298 299 300 def finalise ( self ): \"\"\"Finalize the working model.\"\"\" self . model_wrapper . finalize () get_current_hydromorphodynamics ( time_step ) \u00b6 Get hydrodynamic results; max. values. And minimum in the future Source code in src/core/hydrodynamics/delft3d.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def get_current_hydromorphodynamics ( self , time_step ): # only needed as long as we cannot get minval from the wrapper \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" self . time_step = time_step bed_level = self . get_variable ( \"bl\" )[ range ( self . space )] # bed_level = np.delete(bed_level, np.where(bed_level <= -5)) # cur_tau = self.get_variable('taus') # cur_vel = self.get_variable('u1') # cur1_vel = self.get_variable('ucx') # cur2_vel = self.get_variable('ucy') # cur_wl = self.get_variable('s1') dt_int = self . get_variable ( \"is_dtint\" ) cur_tau = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 0 ] / self . time_step ) cur_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) cur_wl = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) return cur_tau , cur_wl , cur_vel , bed_level get_environment_variables () -> List [ str ] abstractmethod \u00b6 Gets the Python environment variables to include in a Delft3D model run. Source code in src/core/hydrodynamics/delft3d.py 203 204 205 206 207 208 @abstractmethod def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables to include in a Delft3D model run. \"\"\" raise NotImplementedError ( \"Implement in concrete class\" ) get_hydromorphodynamics () \u00b6 Get hydrodynamic results; max. values. And minimum in the future Source code in src/core/hydrodynamics/delft3d.py 158 159 160 161 162 163 164 165 166 def get_hydromorphodynamics ( self ): \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" # TODO Add the minimum values when it is implemented in the model as a variable max_tau = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 0 ] max_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] max_wl = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 2 ] bed_level = self . get_variable ( \"bl\" ) return max_tau , max_wl , max_vel , bed_level get_max_hydrodynamics () \u00b6 Get hydrodynamic results; max. values. Source code in src/core/hydrodynamics/delft3d.py 151 152 153 154 155 156 def get_max_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; max. values.\"\"\" current_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per get_mean_hydrodynamics () \u00b6 Get hydrodynamic results; mean values. Source code in src/core/hydrodynamics/delft3d.py 140 141 142 143 144 145 146 147 148 149 def get_mean_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; mean values.\"\"\" if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) current_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per get_variable ( variable : str ) -> Optional [ WrapperVariable ] \u00b6 Get variable from the model wrapper. Parameters: Name Type Description Default variable str Variable to retrieve. required Returns: Type Description Optional [ WrapperVariable ] Optional[WrapperVariable]: Value found. Source code in src/core/hydrodynamics/delft3d.py 48 49 50 51 52 53 54 55 56 57 58 def get_variable ( self , variable : str ) -> Optional [ WrapperVariable ]: \"\"\" Get variable from the model wrapper. Args: variable (str): Variable to retrieve. Returns: Optional[WrapperVariable]: Value found. \"\"\" return self . model_wrapper . get_var ( variable ) initiate () \u00b6 Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. Source code in src/core/hydrodynamics/delft3d.py 248 249 250 251 252 253 254 def initiate ( self ): \"\"\" Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. \"\"\" self . set_environment_variables () self . configure_model_wrapper () self . model_wrapper . initialize () input_check () \u00b6 Check if all requested content is provided Source code in src/core/hydrodynamics/delft3d.py 70 71 72 73 74 75 76 77 78 79 80 def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" ,) [ self . input_check_definition ( file ) for file in files ] interval_types = ( \"update_interval\" , \"update_interval_storm\" ) [ self . input_check_definition ( interval ) for interval in interval_types ] input_check_definition ( obj ) \u00b6 Check definition of critical object. Source code in src/core/hydrodynamics/delft3d.py 82 83 84 85 86 def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self . model_wrapper , obj ) is None : msg = f \" { obj } undefined (required for Delft3D coupling)\" raise ValueError ( msg ) reset_counters () \u00b6 Reset properties for next model update. Source code in src/core/hydrodynamics/delft3d.py 88 89 90 91 92 93 94 95 96 def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" sums = self . get_variable ( \"is_sumvalsnd\" ) sums . fill ( 0.0 ) self . set_variable ( \"is_sumvalsnd\" , sums ) maxs = self . get_variable ( \"is_maxvalsnd\" ) maxs . fill ( 0.0 ) self . set_variable ( \"is_maxvalsnd\" , maxs ) set_environment_variables () \u00b6 Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH Source code in src/core/hydrodynamics/delft3d.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def set_environment_variables ( self ): \"\"\" Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) not in path_var : path_var += f \"; { str ( env_var ) } \" os . environ [ env_key ] = path_var set_morphology ( coral : Coral ) \u00b6 Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/delft3d.py 98 99 100 101 102 103 104 105 106 def set_morphology ( self , coral : Coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" self . set_variable ( \"rnveg\" , coral . as_vegetation_density ) self . set_variable ( \"diaveg\" , coral . dc_rep ) self . set_variable ( \"stemheight\" , coral . hc ) set_variable ( variable : str , value : Optional [ WrapperVariable ]) \u00b6 Set variable to model wrapper. Parameters: Name Type Description Default variable str Variable to set. required value Optional [ WrapperVariable ] Value to set. required Source code in src/core/hydrodynamics/delft3d.py 60 61 62 63 64 65 66 67 68 def set_variable ( self , variable : str , value : Optional [ WrapperVariable ]): \"\"\" Set variable to model wrapper. Args: variable (str): Variable to set. value (Optional[WrapperVariable]): Value to set. \"\"\" self . model_wrapper . set_var ( variable , value ) set_vegetation ( veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ]) \u00b6 Set vegetation dimensions to Delft3D-model. :param veg_species1: vegetation of a specific species :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type veg_species2: Vegetation Source code in src/core/hydrodynamics/delft3d.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def set_vegetation ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ] ): \"\"\"Set vegetation dimensions to Delft3D-model. :param veg_species1: vegetation of a specific species :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type veg_species2: Vegetation \"\"\" if not veg_species2 : self . set_variable ( \"rnveg\" , veg_species1 . veg_den ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , veg_species1 . av_stemdia ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , veg_species1 . av_height ) # [m] 2D plant heights (m) else : ## TODO TEST THIS! self . set_variable ( \"rnveg\" , ( veg_species1 . veg_den + veg_species2 . veg_den ) ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , ( veg_species1 . av_stemdia + veg_species2 . av_stemdia ) ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , ( veg_species1 . av_height + veg_species2 . av_height ) ) # [m] 2D plant heights (m) update ( coral , stormcat = 0 ) \u00b6 Update the Delft3D-model. Source code in src/core/hydrodynamics/delft3d.py 256 257 258 259 260 261 262 263 264 265 266 267 268 def update ( self , coral , stormcat = 0 ): \"\"\"Update the Delft3D-model.\"\"\" self . time_step = ( self . update_interval_storm if stormcat > 0 else self . update_interval ) self . reset_counters () self . model_wrapper . update ( self . time_step ) return ( self . get_max_hydrodynamics () if stormcat > 0 else self . get_mean_hydrodynamics () ) update_hydromorphodynamics ( veg_species1 : Vegetation , time_step : int , veg_species2 : Optional [ Vegetation ]) \u00b6 Update the Delft3D-model. :param veg_species1: vegetation of a specific species :param time_step: time step of delft FM in seconds :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type time_step: int :type veg_species2: Vegetation Source code in src/core/hydrodynamics/delft3d.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def update_hydromorphodynamics ( self , veg_species1 : Vegetation , time_step : int , veg_species2 : Optional [ Vegetation ], ): \"\"\"Update the Delft3D-model. :param veg_species1: vegetation of a specific species :param time_step: time step of delft FM in seconds :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type time_step: int :type veg_species2: Vegetation \"\"\" self . time_step = time_step self . reset_counters () self . set_vegetation ( veg_species1 , veg_species2 ) # if not veg_species2: # self.set_vegetation(veg_species1) # else: # self . model_wrapper . update ( self . time_step ) return self . get_current_hydromorphodynamics ( time_step = self . time_step ) DimrModel \u00b6 Bases: Delft3D Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a DIMR model configuration. Source code in src/core/hydrodynamics/delft3d.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 class DimrModel ( Delft3D ): \"\"\" Class implementing the `HydrodynamicProtocol` which makes use of a `BMIWrapper` to run its calculations. Based on a DIMR model configuration. \"\"\" @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dimr\" / \"bin\" / \"dimr_dll.dll\" return values def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables required to run a Dimr model. \"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , self . d3d_home / \"dimr\" / \"bin\" , self . d3d_home / \"dwaves\" / \"bin\" , self . d3d_home / \"esmf\" / \"scripts\" , self . d3d_home / \"swan\" / \"scripts\" , ] @property def settings ( self ) -> Path : incl = \"DFlow- and DWaves-modules\" files = ( f \" \\n\\t DFlow file : { self . definition_file } \" f \" \\n\\t Configuration file : { self . config_file } \" ) return ( f \"Coupling with Delft3D model (incl. { incl } ) with the following settings:\" f \" \\n\\t Delft3D home dir. : { self . d3d_home } \" f \" { files } \" ) @property def space ( self ) -> None : return None @property def water_depth ( self ): return None @property def x_coordinates ( self ): return None @property def y_coordinates ( self ): return None @property def xy_coordinates ( self ): return None def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . config_file . as_posix () ) check_dll_path ( values : dict ) -> dict classmethod \u00b6 Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Name Type Description dict dict Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dimr\" / \"bin\" / \"dimr_dll.dll\" return values configure_model_wrapper () \u00b6 Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py 500 501 502 503 504 505 506 507 508 509 def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . config_file . as_posix () ) get_environment_variables () -> List [ str ] \u00b6 Gets the Python environment variables required to run a Dimr model. Source code in src/core/hydrodynamics/delft3d.py 453 454 455 456 457 458 459 460 461 462 463 464 465 def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables required to run a Dimr model. \"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , self . d3d_home / \"dimr\" / \"bin\" , self . d3d_home / \"dwaves\" / \"bin\" , self . d3d_home / \"esmf\" / \"scripts\" , self . d3d_home / \"swan\" / \"scripts\" , ] FlowFmModel \u00b6 Bases: Delft3D Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a FlowFM model configuration. Source code in src/core/hydrodynamics/delft3d.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 class FlowFmModel ( Delft3D ): \"\"\" Class implementing the `HydrodynamicProtocol` which makes use of a `BMIWrapper` to run its calculations. Based on a FlowFM model configuration. \"\"\" _space : Optional [ int ] = None _water_depth : Optional [ np . ndarray ] = None _x_coordinates : Optional [ np . array ] = None _y_coordinates : Optional [ np . array ] = None @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dflowfm\" / \"bin\" / \"dflowfm.dll\" return values @property def settings ( self ) -> str : incl = \"DFlow-module\" files = f \" \\n\\t DFlow file : { self . definition_file } \" return ( f \"Coupling with Delft3D model (incl. { incl } ) with the following settings:\" f \" \\n\\t Delft3D home dir. : { self . d3d_home } \" f \" { files } \" ) @property def space ( self ) -> Optional [ int ]: \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . model_wrapper is None : return None self . _space : Optional [ np . ndarray ] = ( self . get_variable ( \"ndxi\" ) if self . _space is None else self . _space ) return self . _space . item () @property def water_depth ( self ) -> Optional [ np . ndarray ]: \"\"\"Water depth.\"\"\" if self . model_wrapper is None : return None if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) if self . _water_depth is None : return ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) else : return self . _water_depth @property def x_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's x-coordinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _x_coordinates = ( self . get_variable ( \"xzw\" )[ range ( self . space )] if self . _x_coordinates is None else self . _x_coordinates ) return self . _x_coordinates @property def y_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's y-coodinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _y_coordinates = ( self . get_variable ( \"yzw\" )[ range ( self . space )] if self . _y_coordinates is None else self . _y_coordinates ) return self . _y_coordinates @property def xy_coordinates ( self ) -> np . ndarray : \"\"\"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray \"\"\" if self . model_wrapper is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) def get_environment_variables ( self ) -> List [ str ]: \"\"\"Gets the Python environment variables required to run a FlowFM model.\"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , ] def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . definition_file . as_posix () ) check_dll_path ( values : dict ) -> dict classmethod \u00b6 Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Name Type Description dict dict Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dflowfm\" / \"bin\" / \"dflowfm.dll\" return values configure_model_wrapper () \u00b6 Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py 416 417 418 419 420 421 422 423 424 425 def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . definition_file . as_posix () ) get_environment_variables () -> List [ str ] \u00b6 Gets the Python environment variables required to run a FlowFM model. Source code in src/core/hydrodynamics/delft3d.py 409 410 411 412 413 414 def get_environment_variables ( self ) -> List [ str ]: \"\"\"Gets the Python environment variables required to run a FlowFM model.\"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , ] space () -> Optional [ int ] property \u00b6 Number of non-boundary boxes; i.e. within-domain boxes. Source code in src/core/hydrodynamics/delft3d.py 345 346 347 348 349 350 351 352 353 @property def space ( self ) -> Optional [ int ]: \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . model_wrapper is None : return None self . _space : Optional [ np . ndarray ] = ( self . get_variable ( \"ndxi\" ) if self . _space is None else self . _space ) return self . _space . item () water_depth () -> Optional [ np . ndarray ] property \u00b6 Water depth. Source code in src/core/hydrodynamics/delft3d.py 355 356 357 358 359 360 361 362 363 364 365 366 367 @property def water_depth ( self ) -> Optional [ np . ndarray ]: \"\"\"Water depth.\"\"\" if self . model_wrapper is None : return None if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) if self . _water_depth is None : return ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) else : return self . _water_depth x_coordinates () -> np . ndarray property \u00b6 Center of gravity's x-coordinates as part of space . Source code in src/core/hydrodynamics/delft3d.py 369 370 371 372 373 374 375 376 377 378 379 @property def x_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's x-coordinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _x_coordinates = ( self . get_variable ( \"xzw\" )[ range ( self . space )] if self . _x_coordinates is None else self . _x_coordinates ) return self . _x_coordinates xy_coordinates () -> np . ndarray property \u00b6 The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray Source code in src/core/hydrodynamics/delft3d.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @property def xy_coordinates ( self ) -> np . ndarray : \"\"\"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray \"\"\" if self . model_wrapper is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) y_coordinates () -> np . ndarray property \u00b6 Center of gravity's y-coodinates as part of space . Source code in src/core/hydrodynamics/delft3d.py 381 382 383 384 385 386 387 388 389 390 391 @property def y_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's y-coodinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _y_coordinates = ( self . get_variable ( \"yzw\" )[ range ( self . space )] if self . _y_coordinates is None else self . _y_coordinates ) return self . _y_coordinates Transect \u00b6 Transect \u00b6 Bases: ExtraModel Implements the HydrodynamicProtocol . Simple 1D depth transect with imposed currents and waves Source code in src/core/hydrodynamics/transect.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class Transect ( ExtraModel ): \"\"\" Implements the `HydrodynamicProtocol`. Simple 1D depth transect with imposed currents and waves \"\"\" working_dir : Optional [ Path ] = None definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None time_step : Optional [ np . datetime64 ] = None x_coordinates : Optional [ np . ndarray ] = None y_coordinates : Optional [ np . ndarray ] = None water_depth : Optional [ np . ndarray ] = None outpoint : Optional [ np . ndarray ] = None # Coordinates where his output is desired def __repr__ ( self ): return \"Transect()\" @property def settings ( self ): \"\"\"Print settings of simple transect imposed forcing.\"\"\" files = ( f \" \\n\\t Transect config file : { self . config_file } \" f \" \\n\\t Transect forcings file : { self . definition_file } \" ) msg = ( f \"1D schematic cross-shore transect with forced hydrodynamics: \" f \" \\n\\t Transect model working dir. : { self . working_dir } \" f \" { files } \" ) return msg def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" , \"config\" ) [ self . input_check_definition ( file ) for file in files ] def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self , obj ) is None : msg = f \" { obj } undefined (required for Transect)\" raise ValueError ( msg ) @property def space ( self ): \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . x_coordinates is None : return None return len ( self . x_coordinates ) @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: np.ndarray: The (x,y) coordinates. \"\"\" if self . x_coordinates is None or self . y_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" pass def set_morphology ( self , coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" pass def initiate ( self ): \"\"\" Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. \"\"\" csv : np . ndarray = np . genfromtxt ( self . config_file , delimiter = \",\" , skip_header = 1 ) self . x_coordinates = csv [:, 0 ] self . y_coordinates = csv [:, 1 ] self . water_depth = csv [:, 2 ] self . outpoint = csv [:, 3 ] == 1 forcings : np . ndarray = np . genfromtxt ( self . definition_file , delimiter = \",\" , skip_header = 1 ) self . stormcat = forcings [:, 0 ] self . return_period = forcings [:, 1 ] self . wave_height = forcings [:, 2 ] self . wave_period = forcings [:, 3 ] self . wave_angle = forcings [:, 4 ] self . max_curr_vel = forcings [:, 5 ] def update ( self , coral , stormcat = 0 ): \"\"\" Update the model, which is just knowing the waves Args: coral (Coral): Coral morphology to use. stormcat (int, optional): Storm category. Defaults to 0. Raises: ValueError: When stormcat not in [0,3] range. Returns: Tuple: Tuple containing calculated current velocity, wave velocity and wave period. \"\"\" mean_current_vel = 0 if stormcat in [ 0 , 1 , 2 , 3 ]: Hs = self . wave_height [ stormcat ] T = self . wave_period [ stormcat ] max_current_vel = self . max_curr_vel [ stormcat ] h = self . water_depth wave_vel = ( Hs / 4 * np . sqrt ( 9.81 / h ) * np . exp ( - np . power (( 3.65 / T * np . sqrt ( h / 9.81 )), 2.1 )) ) else : raise ValueError ( f \"stormcat = { stormcat } , must be either 0,1,2,3\" ) if stormcat == 0 : return mean_current_vel , wave_vel , T else : return max_current_vel , wave_vel , T def finalise ( self ): \"\"\"Finalize the working model.\"\"\" pass finalise () \u00b6 Finalize the working model. Source code in src/core/hydrodynamics/transect.py 153 154 155 def finalise ( self ): \"\"\"Finalize the working model.\"\"\" pass initiate () \u00b6 Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. Source code in src/core/hydrodynamics/transect.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def initiate ( self ): \"\"\" Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. \"\"\" csv : np . ndarray = np . genfromtxt ( self . config_file , delimiter = \",\" , skip_header = 1 ) self . x_coordinates = csv [:, 0 ] self . y_coordinates = csv [:, 1 ] self . water_depth = csv [:, 2 ] self . outpoint = csv [:, 3 ] == 1 forcings : np . ndarray = np . genfromtxt ( self . definition_file , delimiter = \",\" , skip_header = 1 ) self . stormcat = forcings [:, 0 ] self . return_period = forcings [:, 1 ] self . wave_height = forcings [:, 2 ] self . wave_period = forcings [:, 3 ] self . wave_angle = forcings [:, 4 ] self . max_curr_vel = forcings [:, 5 ] input_check () \u00b6 Check if all requested content is provided Source code in src/core/hydrodynamics/transect.py 45 46 47 48 49 50 51 52 def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" , \"config\" ) [ self . input_check_definition ( file ) for file in files ] input_check_definition ( obj ) \u00b6 Check definition of critical object. Source code in src/core/hydrodynamics/transect.py 54 55 56 57 58 def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self , obj ) is None : msg = f \" { obj } undefined (required for Transect)\" raise ValueError ( msg ) reset_counters () \u00b6 Reset properties for next model update. Source code in src/core/hydrodynamics/transect.py 86 87 88 def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" pass set_morphology ( coral ) \u00b6 Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/transect.py 90 91 92 93 94 95 96 def set_morphology ( self , coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" pass settings () property \u00b6 Print settings of simple transect imposed forcing. Source code in src/core/hydrodynamics/transect.py 31 32 33 34 35 36 37 38 39 40 41 42 43 @property def settings ( self ): \"\"\"Print settings of simple transect imposed forcing.\"\"\" files = ( f \" \\n\\t Transect config file : { self . config_file } \" f \" \\n\\t Transect forcings file : { self . definition_file } \" ) msg = ( f \"1D schematic cross-shore transect with forced hydrodynamics: \" f \" \\n\\t Transect model working dir. : { self . working_dir } \" f \" { files } \" ) return msg space () property \u00b6 Number of non-boundary boxes; i.e. within-domain boxes. Source code in src/core/hydrodynamics/transect.py 60 61 62 63 64 65 @property def space ( self ): \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . x_coordinates is None : return None return len ( self . x_coordinates ) update ( coral , stormcat = 0 ) \u00b6 Update the model, which is just knowing the waves Parameters: Name Type Description Default coral Coral Coral morphology to use. required stormcat int Storm category. Defaults to 0. 0 Raises: Type Description ValueError When stormcat not in [0,3] range. Returns: Name Type Description Tuple Tuple containing calculated current velocity, wave velocity and wave period. Source code in src/core/hydrodynamics/transect.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def update ( self , coral , stormcat = 0 ): \"\"\" Update the model, which is just knowing the waves Args: coral (Coral): Coral morphology to use. stormcat (int, optional): Storm category. Defaults to 0. Raises: ValueError: When stormcat not in [0,3] range. Returns: Tuple: Tuple containing calculated current velocity, wave velocity and wave period. \"\"\" mean_current_vel = 0 if stormcat in [ 0 , 1 , 2 , 3 ]: Hs = self . wave_height [ stormcat ] T = self . wave_period [ stormcat ] max_current_vel = self . max_curr_vel [ stormcat ] h = self . water_depth wave_vel = ( Hs / 4 * np . sqrt ( 9.81 / h ) * np . exp ( - np . power (( 3.65 / T * np . sqrt ( h / 9.81 )), 2.1 )) ) else : raise ValueError ( f \"stormcat = { stormcat } , must be either 0,1,2,3\" ) if stormcat == 0 : return mean_current_vel , wave_vel , T else : return max_current_vel , wave_vel , T xy_coordinates () -> np . ndarray property \u00b6 The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: Type Description np . ndarray np.ndarray: The (x,y) coordinates. Source code in src/core/hydrodynamics/transect.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: np.ndarray: The (x,y) coordinates. \"\"\" if self . x_coordinates is None or self . y_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) Reef 0D \u00b6 Reef0D \u00b6 Bases: BaseModel Implements the HydrodynamicProtocol . Source code in src/core/hydrodynamics/reef_0d.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Reef0D ( BaseModel ): \"\"\"Implements the `HydrodynamicProtocol`.\"\"\" working_dir : Optional [ Path ] = None definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None x_coordinates : Optional [ np . ndarray ] = None y_coordinates : Optional [ np . ndarray ] = None water_depth : Optional [ np . ndarray ] = None @property def settings ( self ): \"\"\"Print settings of Reef0D-model.\"\"\" return \"Not yet implemented.\" @property def xy_coordinates ( self ): if self . x_coordinates is None or self . y_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) @property def space ( self ): if self . xy_coordinates is None : return None return len ( self . xy_coordinates ) def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError finalise () \u00b6 Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py 61 62 63 def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError initiate () \u00b6 Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py 42 43 44 def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError settings () property \u00b6 Print settings of Reef0D-model. Source code in src/core/hydrodynamics/reef_0d.py 20 21 22 23 @property def settings ( self ): \"\"\"Print settings of Reef0D-model.\"\"\" return \"Not yet implemented.\" update ( coral : Coral , storm = False ) -> tuple \u00b6 Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_0d.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None Reef 1D \u00b6 Reef1D \u00b6 Bases: BaseModel Implements the HydrodynamicProtocol . Simplified one-dimensional hydrodynamic model over a (coral) reef. Internal 1D hydrodynamic model for order-of-magnitude calculations on the hydrodynamic conditions on a coral reef, where both flow and waves are included. Source code in src/core/hydrodynamics/reef_1d.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Reef1D ( BaseModel ): \"\"\" Implements the `HydrodynamicProtocol`. Simplified one-dimensional hydrodynamic model over a (coral) reef. Internal 1D hydrodynamic model for order-of-magnitude calculations on the hydrodynamic conditions on a coral reef, where both flow and waves are included. \"\"\" # TODO: Complete the one-dimensional hydrodynamic model working_dir : Optional [ Path ] = None definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None water_depth : Optional [ np . ndarray ] = None can_dia : Optional [ Any ] = None can_height : Optional [ Any ] = None can_den : Optional [ Any ] = None bath : Optional [ Any ] = None Hs : Optional [ Any ] = None Tp : Optional [ Any ] = None dx : Optional [ Any ] = None def __repr__ ( self ): msg = ( f \"Reef1D(bathymetry= { self . bath } , wave_height= { self . Hs } , \" f \"wave_period= { self . Tp } )\" ) return msg @property def settings ( self ): \"\"\"Print settings of Reef1D-model.\"\"\" bath_value = None min_max_bath = None space_dx = None if self . bath is not None : bath_value = type ( self . bath ) . __name__ min_max_bath = f \" { min ( self . bath ) } - { max ( self . bath ) } \" if self . dx is not None : space_dx = self . space * self . dx msg = ( f \"One-dimensional simple hydrodynamic model to simulate the \" f \"hydrodynamics on a (coral) reef with the following settings:\" f \" \\n\\t Bathymetric cross-shore data : { bath_value } \" f \" \\n\\t\\t range [m] : { min_max_bath } \" f \" \\n\\t\\t length [m] : { space_dx } \" f \" \\n\\t Significant wave height [m] : { self . Hs } \" f \" \\n\\t Peak wave period [s] : { self . Tp } \" ) return msg @property def space ( self ): if self . bath is None : return None return len ( self . bath ) @property def x_coordinates ( self ): if self . space is None or self . dx is None : return None return np . arange ( 0 , self . space , self . dx ) @property def y_coordinates ( self ): return np . array ([ 0 ]) @property def xy_coordinates ( self ): if self . x_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ 0 ]] for i in range ( len ( self . x_coordinates )) ] ) @property def vel_wave ( self ): return 0 @property def vel_curr_mn ( self ): return 0 @property def vel_curr_mx ( self ): return 0 @property def per_wav ( self ): return self . Tp @property def water_level ( self ): return 0 @property def depth ( self ): return self . bath + self . water_level @staticmethod def dispersion ( wave_length , wave_period , depth , grav_acc ): \"\"\"Dispersion relation to determine the wave length based on the wave period. \"\"\" func = wave_length - (( grav_acc * wave_period ** 2 ) / ( 2 * np . pi )) * np . tanh ( 2 * np . pi * depth / wave_length ) return func @property def wave_length ( self ): \"\"\"Solve the dispersion relation to retrieve the wave length.\"\"\" L0 = 9.81 * self . per_wav ** 2 L = np . zeros ( len ( self . depth )) for i , h in enumerate ( self . depth ): if h > 0 : L [ i ] = fsolve ( self . dispersion , L0 , args = ( self . per_wav , h , 9.81 )) return L @property def wave_frequency ( self ): return 2 * np . pi / self . per_wav @property def wave_number ( self ): k = np . zeros ( len ( self . wave_length )) k [ self . wave_length > 0 ] = 2 * np . pi / self . wave_length [ self . wave_length > 0 ] return k @property def wave_celerity ( self ): return self . wave_length / self . per_wav @property def group_celerity ( self ): n = 0.5 * ( 1 + ( 2 * self . wave_number * self . depth ) / ( np . sinh ( self . wave_number * self . depth )) ) return n * self . wave_celerity def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError dispersion ( wave_length , wave_period , depth , grav_acc ) staticmethod \u00b6 Dispersion relation to determine the wave length based on the wave period. Source code in src/core/hydrodynamics/reef_1d.py 116 117 118 119 120 121 122 123 124 @staticmethod def dispersion ( wave_length , wave_period , depth , grav_acc ): \"\"\"Dispersion relation to determine the wave length based on the wave period. \"\"\" func = wave_length - (( grav_acc * wave_period ** 2 ) / ( 2 * np . pi )) * np . tanh ( 2 * np . pi * depth / wave_length ) return func finalise () \u00b6 Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py 178 179 180 def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError initiate () \u00b6 Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py 159 160 161 def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError settings () property \u00b6 Print settings of Reef1D-model. Source code in src/core/hydrodynamics/reef_1d.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @property def settings ( self ): \"\"\"Print settings of Reef1D-model.\"\"\" bath_value = None min_max_bath = None space_dx = None if self . bath is not None : bath_value = type ( self . bath ) . __name__ min_max_bath = f \" { min ( self . bath ) } - { max ( self . bath ) } \" if self . dx is not None : space_dx = self . space * self . dx msg = ( f \"One-dimensional simple hydrodynamic model to simulate the \" f \"hydrodynamics on a (coral) reef with the following settings:\" f \" \\n\\t Bathymetric cross-shore data : { bath_value } \" f \" \\n\\t\\t range [m] : { min_max_bath } \" f \" \\n\\t\\t length [m] : { space_dx } \" f \" \\n\\t Significant wave height [m] : { self . Hs } \" f \" \\n\\t Peak wave period [s] : { self . Tp } \" ) return msg update ( coral : Coral , storm = False ) -> tuple \u00b6 Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_1d.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None wave_length () property \u00b6 Solve the dispersion relation to retrieve the wave length. Source code in src/core/hydrodynamics/reef_1d.py 126 127 128 129 130 131 132 133 134 @property def wave_length ( self ): \"\"\"Solve the dispersion relation to retrieve the wave length.\"\"\" L0 = 9.81 * self . per_wav ** 2 L = np . zeros ( len ( self . depth )) for i , h in enumerate ( self . depth ): if h > 0 : L [ i ] = fsolve ( self . dispersion , L0 , args = ( self . per_wav , h , 9.81 )) return L","title":"Hydromodels"},{"location":"reference/core/hydrodynamics/hydromodels/#hydrodynamic-simulation-models","text":"","title":"Hydrodynamic simulation models."},{"location":"reference/core/hydrodynamics/hydromodels/#factory","text":"","title":"Factory"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.factory.HydrodynamicsFactory","text":"Factory class to select hydrodynamic models. It also works as a binding model-protocol between the hydrodynamic models and the HydrodynamicProtocol . Source code in src/core/hydrodynamics/factory.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class HydrodynamicsFactory : \"\"\" Factory class to select hydrodynamic models. It also works as a binding model-protocol between the hydrodynamic models and the `HydrodynamicProtocol`. \"\"\" supported_modes : List [ HydrodynamicProtocol ] = [ Reef0D , Reef1D , DimrModel , FlowFmModel , Transect , ] @staticmethod def get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol : \"\"\" Returns the type associated with the given model name. Args: model_name (str): Model name to retrieve. Raises: ValueError: When the model name is not associated with a valid `HydrodynamicProtocol`. Returns: HydrodynamicProtocol: The requested model type. \"\"\" nm_name = model_name . lower () if model_name is not None else model_name hydromodel : HydrodynamicProtocol = next ( ( m_type for m_type in HydrodynamicsFactory . supported_modes if m_type . __name__ . lower () == nm_name ), None , ) if hydromodel is None : msg = f \" { model_name } not in { [ x . __name__ for x in HydrodynamicsFactory . supported_modes ] } .\" raise ValueError ( msg ) return hydromodel @staticmethod def create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol : \"\"\" Creates a `HydrodynamicProtocol` based on the model_name type and the dictionary of values (if any) given. Args: model_name (str): Model type name. Returns: HydrodynamicProtocol: Instance of the requested model. \"\"\" m_type : HydrodynamicProtocol = HydrodynamicsFactory . get_hydrodynamic_model_type ( model_name ) return m_type ( ** kwargs )","title":"HydrodynamicsFactory"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.factory.HydrodynamicsFactory.create","text":"Creates a HydrodynamicProtocol based on the model_name type and the dictionary of values (if any) given. Parameters: Name Type Description Default model_name str Model type name. required Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol Instance of the requested model. Source code in src/core/hydrodynamics/factory.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @staticmethod def create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol : \"\"\" Creates a `HydrodynamicProtocol` based on the model_name type and the dictionary of values (if any) given. Args: model_name (str): Model type name. Returns: HydrodynamicProtocol: Instance of the requested model. \"\"\" m_type : HydrodynamicProtocol = HydrodynamicsFactory . get_hydrodynamic_model_type ( model_name ) return m_type ( ** kwargs )","title":"create()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.factory.HydrodynamicsFactory.get_hydrodynamic_model_type","text":"Returns the type associated with the given model name. Parameters: Name Type Description Default model_name str Model name to retrieve. required Raises: Type Description ValueError When the model name is not associated with a valid HydrodynamicProtocol . Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol The requested model type. Source code in src/core/hydrodynamics/factory.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @staticmethod def get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol : \"\"\" Returns the type associated with the given model name. Args: model_name (str): Model name to retrieve. Raises: ValueError: When the model name is not associated with a valid `HydrodynamicProtocol`. Returns: HydrodynamicProtocol: The requested model type. \"\"\" nm_name = model_name . lower () if model_name is not None else model_name hydromodel : HydrodynamicProtocol = next ( ( m_type for m_type in HydrodynamicsFactory . supported_modes if m_type . __name__ . lower () == nm_name ), None , ) if hydromodel is None : msg = f \" { model_name } not in { [ x . __name__ for x in HydrodynamicsFactory . supported_modes ] } .\" raise ValueError ( msg ) return hydromodel","title":"get_hydrodynamic_model_type()"},{"location":"reference/core/hydrodynamics/hydromodels/#protocol","text":"","title":"Protocol"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol","text":"Bases: Protocol Protocol describing the mandatory properties and methods to be implemented by any hydromodel. The binding between a model and the protocol is made at the factory level ('HydrodynamicsFactory'). Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @runtime_checkable class HydrodynamicProtocol ( Protocol ): \"\"\" Protocol describing the mandatory properties and methods to be implemented by any hydromodel. The binding between a model and the protocol is made at the factory level ('HydrodynamicsFactory'). \"\"\" @property def config_file ( self ) -> Path : \"\"\" Configuration file for the model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the configuration file. \"\"\" raise NotImplementedError @property def definition_file ( self ) -> Path : \"\"\" Model definition file, its format (extension) may vary per file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the definition file. \"\"\" raise NotImplementedError @property def settings ( self ) -> str : \"\"\" Print settings of the hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: The settings as string representation. \"\"\" raise NotImplementedError @property def water_depth ( self ) -> np . ndarray : \"\"\" Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Water depth value as numpy array. \"\"\" raise NotImplementedError @property def space ( self ) -> int : \"\"\" Space-dimension Raises: NotImplementedError: When the model does not implement its own definition. Returns: int: Value of the space-dimension. \"\"\" raise NotImplementedError @property def x_coordinates ( self ) -> np . ndarray : \"\"\" The x-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X coordinates as numpy array. \"\"\" raise NotImplementedError @property def y_coordinates ( self ) -> np . ndarray : \"\"\" The y-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Y coordinates as numpy array. \"\"\" raise NotImplementedError @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X,Y coordinates as numpy array. \"\"\" raise NotImplementedError def initiate ( self ): \"\"\" Initiates the working model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update ( self , biota : Biota , stormcat : int ): \"\"\" Updates the model with the given parameters. Args: biota (Biota): Model representing a living entity. stormcat (int): Category of storm to apply. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def finalise ( self ): \"\"\" Finalizes the model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"HydrodynamicProtocol"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.config_file","text":"Configuration file for the model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Path Path The path to the configuration file. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 16 17 18 19 20 21 22 23 24 25 26 27 @property def config_file ( self ) -> Path : \"\"\" Configuration file for the model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the configuration file. \"\"\" raise NotImplementedError","title":"config_file()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.definition_file","text":"Model definition file, its format (extension) may vary per file. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Path Path The path to the definition file. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 29 30 31 32 33 34 35 36 37 38 39 40 @property def definition_file ( self ) -> Path : \"\"\" Model definition file, its format (extension) may vary per file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: The path to the definition file. \"\"\" raise NotImplementedError","title":"definition_file()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.finalise","text":"Finalizes the model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 142 143 144 145 146 147 148 149 def finalise ( self ): \"\"\" Finalizes the model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.initiate","text":"Initiates the working model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 120 121 122 123 124 125 126 127 def initiate ( self ): \"\"\" Initiates the working model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.settings","text":"Print settings of the hydrodynamic model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str The settings as string representation. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 42 43 44 45 46 47 48 49 50 51 52 53 @property def settings ( self ) -> str : \"\"\" Print settings of the hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: The settings as string representation. \"\"\" raise NotImplementedError","title":"settings()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.space","text":"Space-dimension Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description int int Value of the space-dimension. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 68 69 70 71 72 73 74 75 76 77 78 79 @property def space ( self ) -> int : \"\"\" Space-dimension Raises: NotImplementedError: When the model does not implement its own definition. Returns: int: Value of the space-dimension. \"\"\" raise NotImplementedError","title":"space()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.update","text":"Updates the model with the given parameters. Parameters: Name Type Description Default biota Biota Model representing a living entity. required stormcat int Category of storm to apply. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 129 130 131 132 133 134 135 136 137 138 139 140 def update ( self , biota : Biota , stormcat : int ): \"\"\" Updates the model with the given parameters. Args: biota (Biota): Model representing a living entity. stormcat (int): Category of storm to apply. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.water_depth","text":"Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: Water depth value as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 55 56 57 58 59 60 61 62 63 64 65 66 @property def water_depth ( self ) -> np . ndarray : \"\"\" Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Water depth value as numpy array. \"\"\" raise NotImplementedError","title":"water_depth()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.x_coordinates","text":"The x-coordinates of the model domain. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: X coordinates as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 81 82 83 84 85 86 87 88 89 90 91 92 @property def x_coordinates ( self ) -> np . ndarray : \"\"\" The x-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X coordinates as numpy array. \"\"\" raise NotImplementedError","title":"x_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.xy_coordinates","text":"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: X,Y coordinates as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 107 108 109 110 111 112 113 114 115 116 117 118 @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: X,Y coordinates as numpy array. \"\"\" raise NotImplementedError","title":"xy_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.y_coordinates","text":"The y-coordinates of the model domain. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description np . ndarray np.ndarray: Y coordinates as numpy array. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py 94 95 96 97 98 99 100 101 102 103 104 105 @property def y_coordinates ( self ) -> np . ndarray : \"\"\" The y-coordinates of the model domain. Raises: NotImplementedError: When the model does not implement its own definition. Returns: np.ndarray: Y coordinates as numpy array. \"\"\" raise NotImplementedError","title":"y_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#delft3d","text":"","title":"Delft3D"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D","text":"Bases: ExtraModel , abc . ABC Implements the HydrodynamicProtocol . Coupling of coral_model to Delft3D using the BMI wrapper. Source code in src/core/hydrodynamics/delft3d.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class Delft3D ( ExtraModel , abc . ABC ): \"\"\" Implements the `HydrodynamicProtocol`. Coupling of coral_model to Delft3D using the BMI wrapper. \"\"\" # Define model attributes. time_step : Optional [ np . datetime64 ] = None model_wrapper : Optional [ BMIWrapper ] = None d3d_home : Optional [ Path ] = None # Delft3D binaries home directory. working_dir : Optional [ Path ] = None # Model working directory. definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None dll_path : Optional [ Path ] = None update_interval : Optional [ int ] = None update_interval_storm : Optional [ int ] = None def __repr__ ( self ): return \"Delft3D()\" @property @abstractmethod def space ( self ) -> Optional [ int ]: raise NotImplementedError def get_variable ( self , variable : str ) -> Optional [ WrapperVariable ]: \"\"\" Get variable from the model wrapper. Args: variable (str): Variable to retrieve. Returns: Optional[WrapperVariable]: Value found. \"\"\" return self . model_wrapper . get_var ( variable ) def set_variable ( self , variable : str , value : Optional [ WrapperVariable ]): \"\"\" Set variable to model wrapper. Args: variable (str): Variable to set. value (Optional[WrapperVariable]): Value to set. \"\"\" self . model_wrapper . set_var ( variable , value ) def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" ,) [ self . input_check_definition ( file ) for file in files ] interval_types = ( \"update_interval\" , \"update_interval_storm\" ) [ self . input_check_definition ( interval ) for interval in interval_types ] def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self . model_wrapper , obj ) is None : msg = f \" { obj } undefined (required for Delft3D coupling)\" raise ValueError ( msg ) def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" sums = self . get_variable ( \"is_sumvalsnd\" ) sums . fill ( 0.0 ) self . set_variable ( \"is_sumvalsnd\" , sums ) maxs = self . get_variable ( \"is_maxvalsnd\" ) maxs . fill ( 0.0 ) self . set_variable ( \"is_maxvalsnd\" , maxs ) def set_morphology ( self , coral : Coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" self . set_variable ( \"rnveg\" , coral . as_vegetation_density ) self . set_variable ( \"diaveg\" , coral . dc_rep ) self . set_variable ( \"stemheight\" , coral . hc ) def set_vegetation ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ] ): \"\"\"Set vegetation dimensions to Delft3D-model. :param veg_species1: vegetation of a specific species :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type veg_species2: Vegetation \"\"\" if not veg_species2 : self . set_variable ( \"rnveg\" , veg_species1 . veg_den ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , veg_species1 . av_stemdia ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , veg_species1 . av_height ) # [m] 2D plant heights (m) else : ## TODO TEST THIS! self . set_variable ( \"rnveg\" , ( veg_species1 . veg_den + veg_species2 . veg_den ) ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , ( veg_species1 . av_stemdia + veg_species2 . av_stemdia ) ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , ( veg_species1 . av_height + veg_species2 . av_height ) ) # [m] 2D plant heights (m) def get_mean_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; mean values.\"\"\" if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) current_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per def get_max_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; max. values.\"\"\" current_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per def get_hydromorphodynamics ( self ): \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" # TODO Add the minimum values when it is implemented in the model as a variable max_tau = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 0 ] max_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] max_wl = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 2 ] bed_level = self . get_variable ( \"bl\" ) return max_tau , max_wl , max_vel , bed_level def get_current_hydromorphodynamics ( self , time_step ): # only needed as long as we cannot get minval from the wrapper \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" self . time_step = time_step bed_level = self . get_variable ( \"bl\" )[ range ( self . space )] # bed_level = np.delete(bed_level, np.where(bed_level <= -5)) # cur_tau = self.get_variable('taus') # cur_vel = self.get_variable('u1') # cur1_vel = self.get_variable('ucx') # cur2_vel = self.get_variable('ucy') # cur_wl = self.get_variable('s1') dt_int = self . get_variable ( \"is_dtint\" ) cur_tau = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 0 ] / self . time_step ) cur_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) cur_wl = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) return cur_tau , cur_wl , cur_vel , bed_level @abstractmethod def configure_model_wrapper ( self ): \"\"\" Configures the model wrapper with the specifics of its type. Raises: NotImplementedError: When the concrete class does not define its own implementation. \"\"\" raise NotImplementedError @abstractmethod def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables to include in a Delft3D model run. \"\"\" raise NotImplementedError ( \"Implement in concrete class\" ) def _get_sys_environment_key ( self ) -> str : os_key = dict ( win32 = \"PATH\" , linux = \"LD_LIBRARY_PATH\" , darwin = \"DYLD_LIBRARY_PATH\" ) env_key : str = os_key . get ( sys . platform , None ) if env_key is None : raise NotImplementedError ( f \"System { sys . platform } not supported for a Delft3D run.\" ) return env_key def set_environment_variables ( self ): \"\"\" Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) not in path_var : path_var += f \"; { str ( env_var ) } \" os . environ [ env_key ] = path_var def cleanup_environment_variables ( self ): \"\"\" Remove unnecessary environment variables from system. \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) in path_var : path_var . replace ( f \"; { str ( env_var ) } \" , \"\" ) os . environ [ env_key ] = path_var def initiate ( self ): \"\"\" Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. \"\"\" self . set_environment_variables () self . configure_model_wrapper () self . model_wrapper . initialize () def update ( self , coral , stormcat = 0 ): \"\"\"Update the Delft3D-model.\"\"\" self . time_step = ( self . update_interval_storm if stormcat > 0 else self . update_interval ) self . reset_counters () self . model_wrapper . update ( self . time_step ) return ( self . get_max_hydrodynamics () if stormcat > 0 else self . get_mean_hydrodynamics () ) ## TODO input timestep is in days! what is the unit here? def update_hydromorphodynamics ( self , veg_species1 : Vegetation , time_step : int , veg_species2 : Optional [ Vegetation ], ): \"\"\"Update the Delft3D-model. :param veg_species1: vegetation of a specific species :param time_step: time step of delft FM in seconds :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type time_step: int :type veg_species2: Vegetation \"\"\" self . time_step = time_step self . reset_counters () self . set_vegetation ( veg_species1 , veg_species2 ) # if not veg_species2: # self.set_vegetation(veg_species1) # else: # self . model_wrapper . update ( self . time_step ) return self . get_current_hydromorphodynamics ( time_step = self . time_step ) def finalise ( self ): \"\"\"Finalize the working model.\"\"\" self . model_wrapper . finalize ()","title":"Delft3D"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.cleanup_environment_variables","text":"Remove unnecessary environment variables from system. Source code in src/core/hydrodynamics/delft3d.py 235 236 237 238 239 240 241 242 243 244 245 246 def cleanup_environment_variables ( self ): \"\"\" Remove unnecessary environment variables from system. \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) in path_var : path_var . replace ( f \"; { str ( env_var ) } \" , \"\" ) os . environ [ env_key ] = path_var","title":"cleanup_environment_variables()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.configure_model_wrapper","text":"Configures the model wrapper with the specifics of its type. Raises: Type Description NotImplementedError When the concrete class does not define its own implementation. Source code in src/core/hydrodynamics/delft3d.py 193 194 195 196 197 198 199 200 201 @abstractmethod def configure_model_wrapper ( self ): \"\"\" Configures the model wrapper with the specifics of its type. Raises: NotImplementedError: When the concrete class does not define its own implementation. \"\"\" raise NotImplementedError","title":"configure_model_wrapper()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.finalise","text":"Finalize the working model. Source code in src/core/hydrodynamics/delft3d.py 298 299 300 def finalise ( self ): \"\"\"Finalize the working model.\"\"\" self . model_wrapper . finalize ()","title":"finalise()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_current_hydromorphodynamics","text":"Get hydrodynamic results; max. values. And minimum in the future Source code in src/core/hydrodynamics/delft3d.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def get_current_hydromorphodynamics ( self , time_step ): # only needed as long as we cannot get minval from the wrapper \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" self . time_step = time_step bed_level = self . get_variable ( \"bl\" )[ range ( self . space )] # bed_level = np.delete(bed_level, np.where(bed_level <= -5)) # cur_tau = self.get_variable('taus') # cur_vel = self.get_variable('u1') # cur1_vel = self.get_variable('ucx') # cur2_vel = self.get_variable('ucy') # cur_wl = self.get_variable('s1') dt_int = self . get_variable ( \"is_dtint\" ) cur_tau = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 0 ] / self . time_step ) cur_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) cur_wl = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) return cur_tau , cur_wl , cur_vel , bed_level","title":"get_current_hydromorphodynamics()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_environment_variables","text":"Gets the Python environment variables to include in a Delft3D model run. Source code in src/core/hydrodynamics/delft3d.py 203 204 205 206 207 208 @abstractmethod def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables to include in a Delft3D model run. \"\"\" raise NotImplementedError ( \"Implement in concrete class\" )","title":"get_environment_variables()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_hydromorphodynamics","text":"Get hydrodynamic results; max. values. And minimum in the future Source code in src/core/hydrodynamics/delft3d.py 158 159 160 161 162 163 164 165 166 def get_hydromorphodynamics ( self ): \"\"\"Get hydrodynamic results; max. values. And minimum in the future\"\"\" # TODO Add the minimum values when it is implemented in the model as a variable max_tau = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 0 ] max_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] max_wl = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 2 ] bed_level = self . get_variable ( \"bl\" ) return max_tau , max_wl , max_vel , bed_level","title":"get_hydromorphodynamics()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_max_hydrodynamics","text":"Get hydrodynamic results; max. values. Source code in src/core/hydrodynamics/delft3d.py 151 152 153 154 155 156 def get_max_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; max. values.\"\"\" current_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per","title":"get_max_hydrodynamics()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_mean_hydrodynamics","text":"Get hydrodynamic results; mean values. Source code in src/core/hydrodynamics/delft3d.py 140 141 142 143 144 145 146 147 148 149 def get_mean_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; mean values.\"\"\" if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) current_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per","title":"get_mean_hydrodynamics()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_variable","text":"Get variable from the model wrapper. Parameters: Name Type Description Default variable str Variable to retrieve. required Returns: Type Description Optional [ WrapperVariable ] Optional[WrapperVariable]: Value found. Source code in src/core/hydrodynamics/delft3d.py 48 49 50 51 52 53 54 55 56 57 58 def get_variable ( self , variable : str ) -> Optional [ WrapperVariable ]: \"\"\" Get variable from the model wrapper. Args: variable (str): Variable to retrieve. Returns: Optional[WrapperVariable]: Value found. \"\"\" return self . model_wrapper . get_var ( variable )","title":"get_variable()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.initiate","text":"Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. Source code in src/core/hydrodynamics/delft3d.py 248 249 250 251 252 253 254 def initiate ( self ): \"\"\" Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. \"\"\" self . set_environment_variables () self . configure_model_wrapper () self . model_wrapper . initialize ()","title":"initiate()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.input_check","text":"Check if all requested content is provided Source code in src/core/hydrodynamics/delft3d.py 70 71 72 73 74 75 76 77 78 79 80 def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" ,) [ self . input_check_definition ( file ) for file in files ] interval_types = ( \"update_interval\" , \"update_interval_storm\" ) [ self . input_check_definition ( interval ) for interval in interval_types ]","title":"input_check()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.input_check_definition","text":"Check definition of critical object. Source code in src/core/hydrodynamics/delft3d.py 82 83 84 85 86 def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self . model_wrapper , obj ) is None : msg = f \" { obj } undefined (required for Delft3D coupling)\" raise ValueError ( msg )","title":"input_check_definition()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.reset_counters","text":"Reset properties for next model update. Source code in src/core/hydrodynamics/delft3d.py 88 89 90 91 92 93 94 95 96 def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" sums = self . get_variable ( \"is_sumvalsnd\" ) sums . fill ( 0.0 ) self . set_variable ( \"is_sumvalsnd\" , sums ) maxs = self . get_variable ( \"is_maxvalsnd\" ) maxs . fill ( 0.0 ) self . set_variable ( \"is_maxvalsnd\" , maxs )","title":"reset_counters()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_environment_variables","text":"Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH Source code in src/core/hydrodynamics/delft3d.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def set_environment_variables ( self ): \"\"\" Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) not in path_var : path_var += f \"; { str ( env_var ) } \" os . environ [ env_key ] = path_var","title":"set_environment_variables()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_morphology","text":"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/delft3d.py 98 99 100 101 102 103 104 105 106 def set_morphology ( self , coral : Coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" self . set_variable ( \"rnveg\" , coral . as_vegetation_density ) self . set_variable ( \"diaveg\" , coral . dc_rep ) self . set_variable ( \"stemheight\" , coral . hc )","title":"set_morphology()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_variable","text":"Set variable to model wrapper. Parameters: Name Type Description Default variable str Variable to set. required value Optional [ WrapperVariable ] Value to set. required Source code in src/core/hydrodynamics/delft3d.py 60 61 62 63 64 65 66 67 68 def set_variable ( self , variable : str , value : Optional [ WrapperVariable ]): \"\"\" Set variable to model wrapper. Args: variable (str): Variable to set. value (Optional[WrapperVariable]): Value to set. \"\"\" self . model_wrapper . set_var ( variable , value )","title":"set_variable()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_vegetation","text":"Set vegetation dimensions to Delft3D-model. :param veg_species1: vegetation of a specific species :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type veg_species2: Vegetation Source code in src/core/hydrodynamics/delft3d.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def set_vegetation ( self , veg_species1 : Vegetation , veg_species2 : Optional [ Vegetation ] ): \"\"\"Set vegetation dimensions to Delft3D-model. :param veg_species1: vegetation of a specific species :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type veg_species2: Vegetation \"\"\" if not veg_species2 : self . set_variable ( \"rnveg\" , veg_species1 . veg_den ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , veg_species1 . av_stemdia ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , veg_species1 . av_height ) # [m] 2D plant heights (m) else : ## TODO TEST THIS! self . set_variable ( \"rnveg\" , ( veg_species1 . veg_den + veg_species2 . veg_den ) ) # [1/m2] 3D plant density , 2D part is basis input (1/m2) self . set_variable ( \"diaveg\" , ( veg_species1 . av_stemdia + veg_species2 . av_stemdia ) ) # [m] 3D plant diameter, 2D part is basis input (m) self . set_variable ( \"stemheight\" , ( veg_species1 . av_height + veg_species2 . av_height ) ) # [m] 2D plant heights (m)","title":"set_vegetation()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.update","text":"Update the Delft3D-model. Source code in src/core/hydrodynamics/delft3d.py 256 257 258 259 260 261 262 263 264 265 266 267 268 def update ( self , coral , stormcat = 0 ): \"\"\"Update the Delft3D-model.\"\"\" self . time_step = ( self . update_interval_storm if stormcat > 0 else self . update_interval ) self . reset_counters () self . model_wrapper . update ( self . time_step ) return ( self . get_max_hydrodynamics () if stormcat > 0 else self . get_mean_hydrodynamics () )","title":"update()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.update_hydromorphodynamics","text":"Update the Delft3D-model. :param veg_species1: vegetation of a specific species :param time_step: time step of delft FM in seconds :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type time_step: int :type veg_species2: Vegetation Source code in src/core/hydrodynamics/delft3d.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def update_hydromorphodynamics ( self , veg_species1 : Vegetation , time_step : int , veg_species2 : Optional [ Vegetation ], ): \"\"\"Update the Delft3D-model. :param veg_species1: vegetation of a specific species :param time_step: time step of delft FM in seconds :param veg_species2: vegetation of an optional second species :type veg_species1: Vegetation :type time_step: int :type veg_species2: Vegetation \"\"\" self . time_step = time_step self . reset_counters () self . set_vegetation ( veg_species1 , veg_species2 ) # if not veg_species2: # self.set_vegetation(veg_species1) # else: # self . model_wrapper . update ( self . time_step ) return self . get_current_hydromorphodynamics ( time_step = self . time_step )","title":"update_hydromorphodynamics()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel","text":"Bases: Delft3D Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a DIMR model configuration. Source code in src/core/hydrodynamics/delft3d.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 class DimrModel ( Delft3D ): \"\"\" Class implementing the `HydrodynamicProtocol` which makes use of a `BMIWrapper` to run its calculations. Based on a DIMR model configuration. \"\"\" @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dimr\" / \"bin\" / \"dimr_dll.dll\" return values def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables required to run a Dimr model. \"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , self . d3d_home / \"dimr\" / \"bin\" , self . d3d_home / \"dwaves\" / \"bin\" , self . d3d_home / \"esmf\" / \"scripts\" , self . d3d_home / \"swan\" / \"scripts\" , ] @property def settings ( self ) -> Path : incl = \"DFlow- and DWaves-modules\" files = ( f \" \\n\\t DFlow file : { self . definition_file } \" f \" \\n\\t Configuration file : { self . config_file } \" ) return ( f \"Coupling with Delft3D model (incl. { incl } ) with the following settings:\" f \" \\n\\t Delft3D home dir. : { self . d3d_home } \" f \" { files } \" ) @property def space ( self ) -> None : return None @property def water_depth ( self ): return None @property def x_coordinates ( self ): return None @property def y_coordinates ( self ): return None @property def xy_coordinates ( self ): return None def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . config_file . as_posix () )","title":"DimrModel"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel.check_dll_path","text":"Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Name Type Description dict dict Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dimr\" / \"bin\" / \"dimr_dll.dll\" return values","title":"check_dll_path()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel.configure_model_wrapper","text":"Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py 500 501 502 503 504 505 506 507 508 509 def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . config_file . as_posix () )","title":"configure_model_wrapper()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel.get_environment_variables","text":"Gets the Python environment variables required to run a Dimr model. Source code in src/core/hydrodynamics/delft3d.py 453 454 455 456 457 458 459 460 461 462 463 464 465 def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables required to run a Dimr model. \"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , self . d3d_home / \"dimr\" / \"bin\" , self . d3d_home / \"dwaves\" / \"bin\" , self . d3d_home / \"esmf\" / \"scripts\" , self . d3d_home / \"swan\" / \"scripts\" , ]","title":"get_environment_variables()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel","text":"Bases: Delft3D Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a FlowFM model configuration. Source code in src/core/hydrodynamics/delft3d.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 class FlowFmModel ( Delft3D ): \"\"\" Class implementing the `HydrodynamicProtocol` which makes use of a `BMIWrapper` to run its calculations. Based on a FlowFM model configuration. \"\"\" _space : Optional [ int ] = None _water_depth : Optional [ np . ndarray ] = None _x_coordinates : Optional [ np . array ] = None _y_coordinates : Optional [ np . array ] = None @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dflowfm\" / \"bin\" / \"dflowfm.dll\" return values @property def settings ( self ) -> str : incl = \"DFlow-module\" files = f \" \\n\\t DFlow file : { self . definition_file } \" return ( f \"Coupling with Delft3D model (incl. { incl } ) with the following settings:\" f \" \\n\\t Delft3D home dir. : { self . d3d_home } \" f \" { files } \" ) @property def space ( self ) -> Optional [ int ]: \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . model_wrapper is None : return None self . _space : Optional [ np . ndarray ] = ( self . get_variable ( \"ndxi\" ) if self . _space is None else self . _space ) return self . _space . item () @property def water_depth ( self ) -> Optional [ np . ndarray ]: \"\"\"Water depth.\"\"\" if self . model_wrapper is None : return None if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) if self . _water_depth is None : return ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) else : return self . _water_depth @property def x_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's x-coordinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _x_coordinates = ( self . get_variable ( \"xzw\" )[ range ( self . space )] if self . _x_coordinates is None else self . _x_coordinates ) return self . _x_coordinates @property def y_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's y-coodinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _y_coordinates = ( self . get_variable ( \"yzw\" )[ range ( self . space )] if self . _y_coordinates is None else self . _y_coordinates ) return self . _y_coordinates @property def xy_coordinates ( self ) -> np . ndarray : \"\"\"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray \"\"\" if self . model_wrapper is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) def get_environment_variables ( self ) -> List [ str ]: \"\"\"Gets the Python environment variables required to run a FlowFM model.\"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , ] def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . definition_file . as_posix () )","title":"FlowFmModel"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.check_dll_path","text":"Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Name Type Description dict dict Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dflowfm\" / \"bin\" / \"dflowfm.dll\" return values","title":"check_dll_path()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.configure_model_wrapper","text":"Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py 416 417 418 419 420 421 422 423 424 425 def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . definition_file . as_posix () )","title":"configure_model_wrapper()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.get_environment_variables","text":"Gets the Python environment variables required to run a FlowFM model. Source code in src/core/hydrodynamics/delft3d.py 409 410 411 412 413 414 def get_environment_variables ( self ) -> List [ str ]: \"\"\"Gets the Python environment variables required to run a FlowFM model.\"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , ]","title":"get_environment_variables()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.space","text":"Number of non-boundary boxes; i.e. within-domain boxes. Source code in src/core/hydrodynamics/delft3d.py 345 346 347 348 349 350 351 352 353 @property def space ( self ) -> Optional [ int ]: \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . model_wrapper is None : return None self . _space : Optional [ np . ndarray ] = ( self . get_variable ( \"ndxi\" ) if self . _space is None else self . _space ) return self . _space . item ()","title":"space()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.water_depth","text":"Water depth. Source code in src/core/hydrodynamics/delft3d.py 355 356 357 358 359 360 361 362 363 364 365 366 367 @property def water_depth ( self ) -> Optional [ np . ndarray ]: \"\"\"Water depth.\"\"\" if self . model_wrapper is None : return None if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) if self . _water_depth is None : return ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 2 ] / self . time_step ) else : return self . _water_depth","title":"water_depth()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.x_coordinates","text":"Center of gravity's x-coordinates as part of space . Source code in src/core/hydrodynamics/delft3d.py 369 370 371 372 373 374 375 376 377 378 379 @property def x_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's x-coordinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _x_coordinates = ( self . get_variable ( \"xzw\" )[ range ( self . space )] if self . _x_coordinates is None else self . _x_coordinates ) return self . _x_coordinates","title":"x_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.xy_coordinates","text":"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray Source code in src/core/hydrodynamics/delft3d.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @property def xy_coordinates ( self ) -> np . ndarray : \"\"\"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray \"\"\" if self . model_wrapper is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] )","title":"xy_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.y_coordinates","text":"Center of gravity's y-coodinates as part of space . Source code in src/core/hydrodynamics/delft3d.py 381 382 383 384 385 386 387 388 389 390 391 @property def y_coordinates ( self ) -> np . ndarray : \"\"\"Center of gravity's y-coodinates as part of `space`.\"\"\" if self . model_wrapper is None : return None self . _y_coordinates = ( self . get_variable ( \"yzw\" )[ range ( self . space )] if self . _y_coordinates is None else self . _y_coordinates ) return self . _y_coordinates","title":"y_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#transect","text":"","title":"Transect"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect","text":"Bases: ExtraModel Implements the HydrodynamicProtocol . Simple 1D depth transect with imposed currents and waves Source code in src/core/hydrodynamics/transect.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class Transect ( ExtraModel ): \"\"\" Implements the `HydrodynamicProtocol`. Simple 1D depth transect with imposed currents and waves \"\"\" working_dir : Optional [ Path ] = None definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None time_step : Optional [ np . datetime64 ] = None x_coordinates : Optional [ np . ndarray ] = None y_coordinates : Optional [ np . ndarray ] = None water_depth : Optional [ np . ndarray ] = None outpoint : Optional [ np . ndarray ] = None # Coordinates where his output is desired def __repr__ ( self ): return \"Transect()\" @property def settings ( self ): \"\"\"Print settings of simple transect imposed forcing.\"\"\" files = ( f \" \\n\\t Transect config file : { self . config_file } \" f \" \\n\\t Transect forcings file : { self . definition_file } \" ) msg = ( f \"1D schematic cross-shore transect with forced hydrodynamics: \" f \" \\n\\t Transect model working dir. : { self . working_dir } \" f \" { files } \" ) return msg def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" , \"config\" ) [ self . input_check_definition ( file ) for file in files ] def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self , obj ) is None : msg = f \" { obj } undefined (required for Transect)\" raise ValueError ( msg ) @property def space ( self ): \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . x_coordinates is None : return None return len ( self . x_coordinates ) @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: np.ndarray: The (x,y) coordinates. \"\"\" if self . x_coordinates is None or self . y_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" pass def set_morphology ( self , coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" pass def initiate ( self ): \"\"\" Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. \"\"\" csv : np . ndarray = np . genfromtxt ( self . config_file , delimiter = \",\" , skip_header = 1 ) self . x_coordinates = csv [:, 0 ] self . y_coordinates = csv [:, 1 ] self . water_depth = csv [:, 2 ] self . outpoint = csv [:, 3 ] == 1 forcings : np . ndarray = np . genfromtxt ( self . definition_file , delimiter = \",\" , skip_header = 1 ) self . stormcat = forcings [:, 0 ] self . return_period = forcings [:, 1 ] self . wave_height = forcings [:, 2 ] self . wave_period = forcings [:, 3 ] self . wave_angle = forcings [:, 4 ] self . max_curr_vel = forcings [:, 5 ] def update ( self , coral , stormcat = 0 ): \"\"\" Update the model, which is just knowing the waves Args: coral (Coral): Coral morphology to use. stormcat (int, optional): Storm category. Defaults to 0. Raises: ValueError: When stormcat not in [0,3] range. Returns: Tuple: Tuple containing calculated current velocity, wave velocity and wave period. \"\"\" mean_current_vel = 0 if stormcat in [ 0 , 1 , 2 , 3 ]: Hs = self . wave_height [ stormcat ] T = self . wave_period [ stormcat ] max_current_vel = self . max_curr_vel [ stormcat ] h = self . water_depth wave_vel = ( Hs / 4 * np . sqrt ( 9.81 / h ) * np . exp ( - np . power (( 3.65 / T * np . sqrt ( h / 9.81 )), 2.1 )) ) else : raise ValueError ( f \"stormcat = { stormcat } , must be either 0,1,2,3\" ) if stormcat == 0 : return mean_current_vel , wave_vel , T else : return max_current_vel , wave_vel , T def finalise ( self ): \"\"\"Finalize the working model.\"\"\" pass","title":"Transect"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.finalise","text":"Finalize the working model. Source code in src/core/hydrodynamics/transect.py 153 154 155 def finalise ( self ): \"\"\"Finalize the working model.\"\"\" pass","title":"finalise()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.initiate","text":"Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. Source code in src/core/hydrodynamics/transect.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def initiate ( self ): \"\"\" Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. \"\"\" csv : np . ndarray = np . genfromtxt ( self . config_file , delimiter = \",\" , skip_header = 1 ) self . x_coordinates = csv [:, 0 ] self . y_coordinates = csv [:, 1 ] self . water_depth = csv [:, 2 ] self . outpoint = csv [:, 3 ] == 1 forcings : np . ndarray = np . genfromtxt ( self . definition_file , delimiter = \",\" , skip_header = 1 ) self . stormcat = forcings [:, 0 ] self . return_period = forcings [:, 1 ] self . wave_height = forcings [:, 2 ] self . wave_period = forcings [:, 3 ] self . wave_angle = forcings [:, 4 ] self . max_curr_vel = forcings [:, 5 ]","title":"initiate()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.input_check","text":"Check if all requested content is provided Source code in src/core/hydrodynamics/transect.py 45 46 47 48 49 50 51 52 def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" , \"config\" ) [ self . input_check_definition ( file ) for file in files ]","title":"input_check()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.input_check_definition","text":"Check definition of critical object. Source code in src/core/hydrodynamics/transect.py 54 55 56 57 58 def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self , obj ) is None : msg = f \" { obj } undefined (required for Transect)\" raise ValueError ( msg )","title":"input_check_definition()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.reset_counters","text":"Reset properties for next model update. Source code in src/core/hydrodynamics/transect.py 86 87 88 def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" pass","title":"reset_counters()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.set_morphology","text":"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/transect.py 90 91 92 93 94 95 96 def set_morphology ( self , coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" pass","title":"set_morphology()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.settings","text":"Print settings of simple transect imposed forcing. Source code in src/core/hydrodynamics/transect.py 31 32 33 34 35 36 37 38 39 40 41 42 43 @property def settings ( self ): \"\"\"Print settings of simple transect imposed forcing.\"\"\" files = ( f \" \\n\\t Transect config file : { self . config_file } \" f \" \\n\\t Transect forcings file : { self . definition_file } \" ) msg = ( f \"1D schematic cross-shore transect with forced hydrodynamics: \" f \" \\n\\t Transect model working dir. : { self . working_dir } \" f \" { files } \" ) return msg","title":"settings()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.space","text":"Number of non-boundary boxes; i.e. within-domain boxes. Source code in src/core/hydrodynamics/transect.py 60 61 62 63 64 65 @property def space ( self ): \"\"\"Number of non-boundary boxes; i.e. within-domain boxes.\"\"\" if self . x_coordinates is None : return None return len ( self . x_coordinates )","title":"space()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.update","text":"Update the model, which is just knowing the waves Parameters: Name Type Description Default coral Coral Coral morphology to use. required stormcat int Storm category. Defaults to 0. 0 Raises: Type Description ValueError When stormcat not in [0,3] range. Returns: Name Type Description Tuple Tuple containing calculated current velocity, wave velocity and wave period. Source code in src/core/hydrodynamics/transect.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def update ( self , coral , stormcat = 0 ): \"\"\" Update the model, which is just knowing the waves Args: coral (Coral): Coral morphology to use. stormcat (int, optional): Storm category. Defaults to 0. Raises: ValueError: When stormcat not in [0,3] range. Returns: Tuple: Tuple containing calculated current velocity, wave velocity and wave period. \"\"\" mean_current_vel = 0 if stormcat in [ 0 , 1 , 2 , 3 ]: Hs = self . wave_height [ stormcat ] T = self . wave_period [ stormcat ] max_current_vel = self . max_curr_vel [ stormcat ] h = self . water_depth wave_vel = ( Hs / 4 * np . sqrt ( 9.81 / h ) * np . exp ( - np . power (( 3.65 / T * np . sqrt ( h / 9.81 )), 2.1 )) ) else : raise ValueError ( f \"stormcat = { stormcat } , must be either 0,1,2,3\" ) if stormcat == 0 : return mean_current_vel , wave_vel , T else : return max_current_vel , wave_vel , T","title":"update()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.xy_coordinates","text":"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: Type Description np . ndarray np.ndarray: The (x,y) coordinates. Source code in src/core/hydrodynamics/transect.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @property def xy_coordinates ( self ) -> np . ndarray : \"\"\" The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: np.ndarray: The (x,y) coordinates. \"\"\" if self . x_coordinates is None or self . y_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] )","title":"xy_coordinates()"},{"location":"reference/core/hydrodynamics/hydromodels/#reef-0d","text":"","title":"Reef 0D"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D","text":"Bases: BaseModel Implements the HydrodynamicProtocol . Source code in src/core/hydrodynamics/reef_0d.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Reef0D ( BaseModel ): \"\"\"Implements the `HydrodynamicProtocol`.\"\"\" working_dir : Optional [ Path ] = None definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None x_coordinates : Optional [ np . ndarray ] = None y_coordinates : Optional [ np . ndarray ] = None water_depth : Optional [ np . ndarray ] = None @property def settings ( self ): \"\"\"Print settings of Reef0D-model.\"\"\" return \"Not yet implemented.\" @property def xy_coordinates ( self ): if self . x_coordinates is None or self . y_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ i ]] for i in range ( len ( self . x_coordinates )) ] ) @property def space ( self ): if self . xy_coordinates is None : return None return len ( self . xy_coordinates ) def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError","title":"Reef0D"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.finalise","text":"Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py 61 62 63 def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.initiate","text":"Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py 42 43 44 def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.settings","text":"Print settings of Reef0D-model. Source code in src/core/hydrodynamics/reef_0d.py 20 21 22 23 @property def settings ( self ): \"\"\"Print settings of Reef0D-model.\"\"\" return \"Not yet implemented.\"","title":"settings()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.update","text":"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_0d.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None","title":"update()"},{"location":"reference/core/hydrodynamics/hydromodels/#reef-1d","text":"","title":"Reef 1D"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D","text":"Bases: BaseModel Implements the HydrodynamicProtocol . Simplified one-dimensional hydrodynamic model over a (coral) reef. Internal 1D hydrodynamic model for order-of-magnitude calculations on the hydrodynamic conditions on a coral reef, where both flow and waves are included. Source code in src/core/hydrodynamics/reef_1d.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Reef1D ( BaseModel ): \"\"\" Implements the `HydrodynamicProtocol`. Simplified one-dimensional hydrodynamic model over a (coral) reef. Internal 1D hydrodynamic model for order-of-magnitude calculations on the hydrodynamic conditions on a coral reef, where both flow and waves are included. \"\"\" # TODO: Complete the one-dimensional hydrodynamic model working_dir : Optional [ Path ] = None definition_file : Optional [ Path ] = None config_file : Optional [ Path ] = None water_depth : Optional [ np . ndarray ] = None can_dia : Optional [ Any ] = None can_height : Optional [ Any ] = None can_den : Optional [ Any ] = None bath : Optional [ Any ] = None Hs : Optional [ Any ] = None Tp : Optional [ Any ] = None dx : Optional [ Any ] = None def __repr__ ( self ): msg = ( f \"Reef1D(bathymetry= { self . bath } , wave_height= { self . Hs } , \" f \"wave_period= { self . Tp } )\" ) return msg @property def settings ( self ): \"\"\"Print settings of Reef1D-model.\"\"\" bath_value = None min_max_bath = None space_dx = None if self . bath is not None : bath_value = type ( self . bath ) . __name__ min_max_bath = f \" { min ( self . bath ) } - { max ( self . bath ) } \" if self . dx is not None : space_dx = self . space * self . dx msg = ( f \"One-dimensional simple hydrodynamic model to simulate the \" f \"hydrodynamics on a (coral) reef with the following settings:\" f \" \\n\\t Bathymetric cross-shore data : { bath_value } \" f \" \\n\\t\\t range [m] : { min_max_bath } \" f \" \\n\\t\\t length [m] : { space_dx } \" f \" \\n\\t Significant wave height [m] : { self . Hs } \" f \" \\n\\t Peak wave period [s] : { self . Tp } \" ) return msg @property def space ( self ): if self . bath is None : return None return len ( self . bath ) @property def x_coordinates ( self ): if self . space is None or self . dx is None : return None return np . arange ( 0 , self . space , self . dx ) @property def y_coordinates ( self ): return np . array ([ 0 ]) @property def xy_coordinates ( self ): if self . x_coordinates is None : return None return np . array ( [ [ self . x_coordinates [ i ], self . y_coordinates [ 0 ]] for i in range ( len ( self . x_coordinates )) ] ) @property def vel_wave ( self ): return 0 @property def vel_curr_mn ( self ): return 0 @property def vel_curr_mx ( self ): return 0 @property def per_wav ( self ): return self . Tp @property def water_level ( self ): return 0 @property def depth ( self ): return self . bath + self . water_level @staticmethod def dispersion ( wave_length , wave_period , depth , grav_acc ): \"\"\"Dispersion relation to determine the wave length based on the wave period. \"\"\" func = wave_length - (( grav_acc * wave_period ** 2 ) / ( 2 * np . pi )) * np . tanh ( 2 * np . pi * depth / wave_length ) return func @property def wave_length ( self ): \"\"\"Solve the dispersion relation to retrieve the wave length.\"\"\" L0 = 9.81 * self . per_wav ** 2 L = np . zeros ( len ( self . depth )) for i , h in enumerate ( self . depth ): if h > 0 : L [ i ] = fsolve ( self . dispersion , L0 , args = ( self . per_wav , h , 9.81 )) return L @property def wave_frequency ( self ): return 2 * np . pi / self . per_wav @property def wave_number ( self ): k = np . zeros ( len ( self . wave_length )) k [ self . wave_length > 0 ] = 2 * np . pi / self . wave_length [ self . wave_length > 0 ] return k @property def wave_celerity ( self ): return self . wave_length / self . per_wav @property def group_celerity ( self ): n = 0.5 * ( 1 + ( 2 * self . wave_number * self . depth ) / ( np . sinh ( self . wave_number * self . depth )) ) return n * self . wave_celerity def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError","title":"Reef1D"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.dispersion","text":"Dispersion relation to determine the wave length based on the wave period. Source code in src/core/hydrodynamics/reef_1d.py 116 117 118 119 120 121 122 123 124 @staticmethod def dispersion ( wave_length , wave_period , depth , grav_acc ): \"\"\"Dispersion relation to determine the wave length based on the wave period. \"\"\" func = wave_length - (( grav_acc * wave_period ** 2 ) / ( 2 * np . pi )) * np . tanh ( 2 * np . pi * depth / wave_length ) return func","title":"dispersion()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.finalise","text":"Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py 178 179 180 def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.initiate","text":"Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py 159 160 161 def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.settings","text":"Print settings of Reef1D-model. Source code in src/core/hydrodynamics/reef_1d.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @property def settings ( self ): \"\"\"Print settings of Reef1D-model.\"\"\" bath_value = None min_max_bath = None space_dx = None if self . bath is not None : bath_value = type ( self . bath ) . __name__ min_max_bath = f \" { min ( self . bath ) } - { max ( self . bath ) } \" if self . dx is not None : space_dx = self . space * self . dx msg = ( f \"One-dimensional simple hydrodynamic model to simulate the \" f \"hydrodynamics on a (coral) reef with the following settings:\" f \" \\n\\t Bathymetric cross-shore data : { bath_value } \" f \" \\n\\t\\t range [m] : { min_max_bath } \" f \" \\n\\t\\t length [m] : { space_dx } \" f \" \\n\\t Significant wave height [m] : { self . Hs } \" f \" \\n\\t Peak wave period [s] : { self . Tp } \" ) return msg","title":"settings()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.update","text":"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_1d.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None","title":"update()"},{"location":"reference/core/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.wave_length","text":"Solve the dispersion relation to retrieve the wave length. Source code in src/core/hydrodynamics/reef_1d.py 126 127 128 129 130 131 132 133 134 @property def wave_length ( self ): \"\"\"Solve the dispersion relation to retrieve the wave length.\"\"\" L0 = 9.81 * self . per_wav ** 2 L = np . zeros ( len ( self . depth )) for i , h in enumerate ( self . depth ): if h > 0 : L [ i ] = fsolve ( self . dispersion , L0 , args = ( self . per_wav , h , 9.81 )) return L","title":"wave_length()"},{"location":"reference/core/output/output/","text":"Output classes for the NBSDynamics package. \u00b6 Protocol \u00b6 OutputProtocol \u00b6 Bases: Protocol Protocol defining how an Output model should look like. Source code in src/core/output/output_protocol.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @runtime_checkable class OutputProtocol ( Protocol ): \"\"\" Protocol defining how an Output model should look like. \"\"\" @property def output_params ( self ) -> BaseOutputParameters : \"\"\" The output parameters needed to interact with the netcdf dataset. Raises: NotImplementedError: When the model does not implement its own definition. Returns: BaseOutputParameters: Object with netcdf parameters as attrs.. \"\"\" raise NotImplementedError @property def output_filename ( self ) -> str : \"\"\" The basename with extension the output file will have. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Output filename. \"\"\" raise NotImplementedError @property def output_filepath ( self ) -> Path : \"\"\" The full path to the output file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: Output filepath. \"\"\" raise NotImplementedError def initialize ( self , biota : Biota ): \"\"\" Initializes an output model with the given biota input. Args: biota (Biota): Biota input model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update ( self , biota : Biota , year : int ): \"\"\" Updates the output model with the given biota and year. Args: biota (Biota): Biota input model. year (int): Current calculation year. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError initialize ( biota : Biota ) \u00b6 Initializes an output model with the given biota input. Parameters: Name Type Description Default biota Biota Biota input model. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py 53 54 55 56 57 58 59 60 61 62 63 def initialize ( self , biota : Biota ): \"\"\" Initializes an output model with the given biota input. Args: biota (Biota): Biota input model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError output_filename () -> str property \u00b6 The basename with extension the output file will have. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str Output filename. Source code in src/core/output/output_protocol.py 27 28 29 30 31 32 33 34 35 36 37 38 @property def output_filename ( self ) -> str : \"\"\" The basename with extension the output file will have. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Output filename. \"\"\" raise NotImplementedError output_filepath () -> Path property \u00b6 The full path to the output file. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Path Path Output filepath. Source code in src/core/output/output_protocol.py 40 41 42 43 44 45 46 47 48 49 50 51 @property def output_filepath ( self ) -> Path : \"\"\" The full path to the output file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: Output filepath. \"\"\" raise NotImplementedError output_params () -> BaseOutputParameters property \u00b6 The output parameters needed to interact with the netcdf dataset. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description BaseOutputParameters BaseOutputParameters Object with netcdf parameters as attrs.. Source code in src/core/output/output_protocol.py 14 15 16 17 18 19 20 21 22 23 24 25 @property def output_params ( self ) -> BaseOutputParameters : \"\"\" The output parameters needed to interact with the netcdf dataset. Raises: NotImplementedError: When the model does not implement its own definition. Returns: BaseOutputParameters: Object with netcdf parameters as attrs.. \"\"\" raise NotImplementedError update ( biota : Biota , year : int ) \u00b6 Updates the output model with the given biota and year. Parameters: Name Type Description Default biota Biota Biota input model. required year int Current calculation year. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py 65 66 67 68 69 70 71 72 73 74 75 76 def update ( self , biota : Biota , year : int ): \"\"\" Updates the output model with the given biota and year. Args: biota (Biota): Biota input model. year (int): Current calculation year. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Wrapper \u00b6 BaseOutputWrapper \u00b6 Bases: BaseModel Output files based on predefined output content. Generate output files of Biota model(s) simulation. Output files are formatted as NetCDF4-files. Source code in src/core/output/base_output_wrapper.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class BaseOutputWrapper ( BaseModel ): \"\"\" Output files based on predefined output content. Generate output files of Biota model(s) simulation. Output files are formatted as NetCDF4-files. \"\"\" output_dir : Path = Path . cwd () / \"output\" # directory to write the output to xy_coordinates : Optional [ np . ndarray ] # (x,y)-coordinates first_date : Optional [ Union [ np . datetime64 , datetime ]] # first date of simulation outpoint : Optional [ np . ndarray ] # boolean indicating per (x,y) point if his output is desired # Output models. map_output : Optional [ BaseOutput ] his_output : Optional [ BaseOutput ] def __str__ ( self ): \"\"\"String-representation of Output.\"\"\" return ( f \"Output exported: \\n\\t { self . map_output } \\n\\t { self . his_output } \" if self . defined else \"Output undefined.\" ) def __repr__ ( self ): \"\"\"Representation of Output.\"\"\" return f \"Output(xy_coordinates= { self . xy_coordinates } , first_date= { self . first_date } )\" @root_validator ( pre = True ) @classmethod def check_output_dir ( cls , values : dict ) -> dict : \"\"\" Checks an `output_dir` attribute is given for the `output_model` instances `map_output` and `his_output`. Args: values (dict): Dictionary of attribute values given by the user. Returns: dict: Dictionary of attribute values with a valid `output_dir` value. \"\"\" def check_output_model_dir ( out_model : dict ) -> Optional [ dict ]: if out_model is None : return None out_dir_val = out_model . get ( \"output_dir\" , None ) if out_dir_val is None : out_model [ \"output_dir\" ] = values [ \"output_dir\" ] return out_model values [ \"map_output\" ] = check_output_model_dir ( values . get ( \"map_output\" , None )) values [ \"his_output\" ] = check_output_model_dir ( values . get ( \"his_output\" , None )) return values @property def defined ( self ) -> bool : \"\"\"Output is defined.\"\"\" def output_model_defined ( out_model : OutputProtocol ) -> bool : if out_model is None : return False return ( out_model . output_params is not None and out_model . output_filepath . exists () ) return output_model_defined ( self . map_output ) or output_model_defined ( self . his_output ) @staticmethod def get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Determine space indices based on the (x,y)-coordinates of the stations. Args: xy_coordinates (np.ndarray): Input xy-coordinates system. outpoint (np.ndarray): Boolean per x-y indicating if his output is desired. Returns: Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations \"\"\" nout_his = len ( xy_coordinates [ outpoint , 0 ]) x_coord = xy_coordinates [:, 0 ] y_coord = xy_coordinates [:, 1 ] x_station = xy_coordinates [ outpoint , 0 ] y_station = xy_coordinates [ outpoint , 1 ] idx = np . zeros ( nout_his ) for s in range ( len ( idx )): idx [ s ] = np . argmin ( ( x_coord - x_station [ s ]) ** 2 + ( y_coord - y_station [ s ]) ** 2 ) idx_stations = idx . astype ( int ) return xy_coordinates [ idx_stations , :], idx_stations def initialize ( self , biota : Biota ): \"\"\" Initializes all available output models (His and Map). Args: biota (Biota): Biota model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( biota ) self . map_output . initialize ( biota ) __repr__ () \u00b6 Representation of Output. Source code in src/core/output/base_output_wrapper.py 39 40 41 def __repr__ ( self ): \"\"\"Representation of Output.\"\"\" return f \"Output(xy_coordinates= { self . xy_coordinates } , first_date= { self . first_date } )\" __str__ () \u00b6 String-representation of Output. Source code in src/core/output/base_output_wrapper.py 31 32 33 34 35 36 37 def __str__ ( self ): \"\"\"String-representation of Output.\"\"\" return ( f \"Output exported: \\n\\t { self . map_output } \\n\\t { self . his_output } \" if self . defined else \"Output undefined.\" ) check_output_dir ( values : dict ) -> dict classmethod \u00b6 Checks an output_dir attribute is given for the output_model instances map_output and his_output . Parameters: Name Type Description Default values dict Dictionary of attribute values given by the user. required Returns: Name Type Description dict dict Dictionary of attribute values with a valid output_dir value. Source code in src/core/output/base_output_wrapper.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @root_validator ( pre = True ) @classmethod def check_output_dir ( cls , values : dict ) -> dict : \"\"\" Checks an `output_dir` attribute is given for the `output_model` instances `map_output` and `his_output`. Args: values (dict): Dictionary of attribute values given by the user. Returns: dict: Dictionary of attribute values with a valid `output_dir` value. \"\"\" def check_output_model_dir ( out_model : dict ) -> Optional [ dict ]: if out_model is None : return None out_dir_val = out_model . get ( \"output_dir\" , None ) if out_dir_val is None : out_model [ \"output_dir\" ] = values [ \"output_dir\" ] return out_model values [ \"map_output\" ] = check_output_model_dir ( values . get ( \"map_output\" , None )) values [ \"his_output\" ] = check_output_model_dir ( values . get ( \"his_output\" , None )) return values defined () -> bool property \u00b6 Output is defined. Source code in src/core/output/base_output_wrapper.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @property def defined ( self ) -> bool : \"\"\"Output is defined.\"\"\" def output_model_defined ( out_model : OutputProtocol ) -> bool : if out_model is None : return False return ( out_model . output_params is not None and out_model . output_filepath . exists () ) return output_model_defined ( self . map_output ) or output_model_defined ( self . his_output ) get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ] staticmethod \u00b6 Determine space indices based on the (x,y)-coordinates of the stations. Parameters: Name Type Description Default xy_coordinates np . ndarray Input xy-coordinates system. required outpoint np . ndarray Boolean per x-y indicating if his output is desired. required Returns: Type Description Tuple [ np . ndarray , np . ndarray ] Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations Source code in src/core/output/base_output_wrapper.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @staticmethod def get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Determine space indices based on the (x,y)-coordinates of the stations. Args: xy_coordinates (np.ndarray): Input xy-coordinates system. outpoint (np.ndarray): Boolean per x-y indicating if his output is desired. Returns: Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations \"\"\" nout_his = len ( xy_coordinates [ outpoint , 0 ]) x_coord = xy_coordinates [:, 0 ] y_coord = xy_coordinates [:, 1 ] x_station = xy_coordinates [ outpoint , 0 ] y_station = xy_coordinates [ outpoint , 1 ] idx = np . zeros ( nout_his ) for s in range ( len ( idx )): idx [ s ] = np . argmin ( ( x_coord - x_station [ s ]) ** 2 + ( y_coord - y_station [ s ]) ** 2 ) idx_stations = idx . astype ( int ) return xy_coordinates [ idx_stations , :], idx_stations initialize ( biota : Biota ) \u00b6 Initializes all available output models (His and Map). Parameters: Name Type Description Default biota Biota Biota model to be used in the output. required Source code in src/core/output/base_output_wrapper.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def initialize ( self , biota : Biota ): \"\"\" Initializes all available output models (His and Map). Args: biota (Biota): Biota model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( biota ) self . map_output . initialize ( biota ) Output models \u00b6 BaseOutput \u00b6 Bases: BaseModel , ABC Base class containing the generic definition of an output model. Source code in src/core/output/base_output_model.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class BaseOutput ( BaseModel , ABC ): \"\"\" Base class containing the generic definition of an output model. \"\"\" output_dir : Path output_filename : str # Output model attributes. output_params : BaseOutputParameters = BaseOutputParameters () def valid_output ( self ) -> bool : \"\"\" Verifies whether this model can generate valid output. Returns: bool: Output is valid. \"\"\" return self . output_params . valid_output () @property def output_filepath ( self ) -> Path : \"\"\" Gets the full path to the output netcdf file. Returns: Path: Output .nc file. \"\"\" return self . output_dir / self . output_filename def initialize ( self , biota : Optional [ Biota ]): \"\"\" Method to initialize the Output Model based on a given biota model. This method should be implemented in the concrete classes. Args: biota (Optional[Biota]): Base model for the generated output. \"\"\" pass initialize ( biota : Optional [ Biota ]) \u00b6 Method to initialize the Output Model based on a given biota model. This method should be implemented in the concrete classes. Parameters: Name Type Description Default biota Optional [ Biota ] Base model for the generated output. required Source code in src/core/output/base_output_model.py 50 51 52 53 54 55 56 57 58 def initialize ( self , biota : Optional [ Biota ]): \"\"\" Method to initialize the Output Model based on a given biota model. This method should be implemented in the concrete classes. Args: biota (Optional[Biota]): Base model for the generated output. \"\"\" pass output_filepath () -> Path property \u00b6 Gets the full path to the output netcdf file. Returns: Name Type Description Path Path Output .nc file. Source code in src/core/output/base_output_model.py 40 41 42 43 44 45 46 47 48 @property def output_filepath ( self ) -> Path : \"\"\" Gets the full path to the output netcdf file. Returns: Path: Output .nc file. \"\"\" return self . output_dir / self . output_filename valid_output () -> bool \u00b6 Verifies whether this model can generate valid output. Returns: Name Type Description bool bool Output is valid. Source code in src/core/output/base_output_model.py 31 32 33 34 35 36 37 38 def valid_output ( self ) -> bool : \"\"\" Verifies whether this model can generate valid output. Returns: bool: Output is valid. \"\"\" return self . output_params . valid_output () BaseOutputParameters \u00b6 Bases: BaseModel , ABC Source code in src/core/output/base_output_model.py 9 10 11 12 13 14 15 16 17 class BaseOutputParameters ( BaseModel , ABC ): def valid_output ( self ) -> bool : \"\"\" Validates whether all the fields from this class have a value. Returns: bool: When all the values are 'filled'. \"\"\" return any ( self . dict () . values ()) valid_output () -> bool \u00b6 Validates whether all the fields from this class have a value. Returns: Name Type Description bool bool When all the values are 'filled'. Source code in src/core/output/base_output_model.py 10 11 12 13 14 15 16 17 def valid_output ( self ) -> bool : \"\"\" Validates whether all the fields from this class have a value. Returns: bool: When all the values are 'filled'. \"\"\" return any ( self . dict () . values ())","title":"Output"},{"location":"reference/core/output/output/#output-classes-for-the-nbsdynamics-package","text":"","title":"Output classes for the NBSDynamics package."},{"location":"reference/core/output/output/#protocol","text":"","title":"Protocol"},{"location":"reference/core/output/output/#src.core.output.output_protocol.OutputProtocol","text":"Bases: Protocol Protocol defining how an Output model should look like. Source code in src/core/output/output_protocol.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @runtime_checkable class OutputProtocol ( Protocol ): \"\"\" Protocol defining how an Output model should look like. \"\"\" @property def output_params ( self ) -> BaseOutputParameters : \"\"\" The output parameters needed to interact with the netcdf dataset. Raises: NotImplementedError: When the model does not implement its own definition. Returns: BaseOutputParameters: Object with netcdf parameters as attrs.. \"\"\" raise NotImplementedError @property def output_filename ( self ) -> str : \"\"\" The basename with extension the output file will have. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Output filename. \"\"\" raise NotImplementedError @property def output_filepath ( self ) -> Path : \"\"\" The full path to the output file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: Output filepath. \"\"\" raise NotImplementedError def initialize ( self , biota : Biota ): \"\"\" Initializes an output model with the given biota input. Args: biota (Biota): Biota input model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def update ( self , biota : Biota , year : int ): \"\"\" Updates the output model with the given biota and year. Args: biota (Biota): Biota input model. year (int): Current calculation year. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"OutputProtocol"},{"location":"reference/core/output/output/#src.core.output.output_protocol.OutputProtocol.initialize","text":"Initializes an output model with the given biota input. Parameters: Name Type Description Default biota Biota Biota input model. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py 53 54 55 56 57 58 59 60 61 62 63 def initialize ( self , biota : Biota ): \"\"\" Initializes an output model with the given biota input. Args: biota (Biota): Biota input model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"initialize()"},{"location":"reference/core/output/output/#src.core.output.output_protocol.OutputProtocol.output_filename","text":"The basename with extension the output file will have. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str Output filename. Source code in src/core/output/output_protocol.py 27 28 29 30 31 32 33 34 35 36 37 38 @property def output_filename ( self ) -> str : \"\"\" The basename with extension the output file will have. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Output filename. \"\"\" raise NotImplementedError","title":"output_filename()"},{"location":"reference/core/output/output/#src.core.output.output_protocol.OutputProtocol.output_filepath","text":"The full path to the output file. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Path Path Output filepath. Source code in src/core/output/output_protocol.py 40 41 42 43 44 45 46 47 48 49 50 51 @property def output_filepath ( self ) -> Path : \"\"\" The full path to the output file. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Path: Output filepath. \"\"\" raise NotImplementedError","title":"output_filepath()"},{"location":"reference/core/output/output/#src.core.output.output_protocol.OutputProtocol.output_params","text":"The output parameters needed to interact with the netcdf dataset. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description BaseOutputParameters BaseOutputParameters Object with netcdf parameters as attrs.. Source code in src/core/output/output_protocol.py 14 15 16 17 18 19 20 21 22 23 24 25 @property def output_params ( self ) -> BaseOutputParameters : \"\"\" The output parameters needed to interact with the netcdf dataset. Raises: NotImplementedError: When the model does not implement its own definition. Returns: BaseOutputParameters: Object with netcdf parameters as attrs.. \"\"\" raise NotImplementedError","title":"output_params()"},{"location":"reference/core/output/output/#src.core.output.output_protocol.OutputProtocol.update","text":"Updates the output model with the given biota and year. Parameters: Name Type Description Default biota Biota Biota input model. required year int Current calculation year. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py 65 66 67 68 69 70 71 72 73 74 75 76 def update ( self , biota : Biota , year : int ): \"\"\" Updates the output model with the given biota and year. Args: biota (Biota): Biota input model. year (int): Current calculation year. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update()"},{"location":"reference/core/output/output/#wrapper","text":"","title":"Wrapper"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper","text":"Bases: BaseModel Output files based on predefined output content. Generate output files of Biota model(s) simulation. Output files are formatted as NetCDF4-files. Source code in src/core/output/base_output_wrapper.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class BaseOutputWrapper ( BaseModel ): \"\"\" Output files based on predefined output content. Generate output files of Biota model(s) simulation. Output files are formatted as NetCDF4-files. \"\"\" output_dir : Path = Path . cwd () / \"output\" # directory to write the output to xy_coordinates : Optional [ np . ndarray ] # (x,y)-coordinates first_date : Optional [ Union [ np . datetime64 , datetime ]] # first date of simulation outpoint : Optional [ np . ndarray ] # boolean indicating per (x,y) point if his output is desired # Output models. map_output : Optional [ BaseOutput ] his_output : Optional [ BaseOutput ] def __str__ ( self ): \"\"\"String-representation of Output.\"\"\" return ( f \"Output exported: \\n\\t { self . map_output } \\n\\t { self . his_output } \" if self . defined else \"Output undefined.\" ) def __repr__ ( self ): \"\"\"Representation of Output.\"\"\" return f \"Output(xy_coordinates= { self . xy_coordinates } , first_date= { self . first_date } )\" @root_validator ( pre = True ) @classmethod def check_output_dir ( cls , values : dict ) -> dict : \"\"\" Checks an `output_dir` attribute is given for the `output_model` instances `map_output` and `his_output`. Args: values (dict): Dictionary of attribute values given by the user. Returns: dict: Dictionary of attribute values with a valid `output_dir` value. \"\"\" def check_output_model_dir ( out_model : dict ) -> Optional [ dict ]: if out_model is None : return None out_dir_val = out_model . get ( \"output_dir\" , None ) if out_dir_val is None : out_model [ \"output_dir\" ] = values [ \"output_dir\" ] return out_model values [ \"map_output\" ] = check_output_model_dir ( values . get ( \"map_output\" , None )) values [ \"his_output\" ] = check_output_model_dir ( values . get ( \"his_output\" , None )) return values @property def defined ( self ) -> bool : \"\"\"Output is defined.\"\"\" def output_model_defined ( out_model : OutputProtocol ) -> bool : if out_model is None : return False return ( out_model . output_params is not None and out_model . output_filepath . exists () ) return output_model_defined ( self . map_output ) or output_model_defined ( self . his_output ) @staticmethod def get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Determine space indices based on the (x,y)-coordinates of the stations. Args: xy_coordinates (np.ndarray): Input xy-coordinates system. outpoint (np.ndarray): Boolean per x-y indicating if his output is desired. Returns: Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations \"\"\" nout_his = len ( xy_coordinates [ outpoint , 0 ]) x_coord = xy_coordinates [:, 0 ] y_coord = xy_coordinates [:, 1 ] x_station = xy_coordinates [ outpoint , 0 ] y_station = xy_coordinates [ outpoint , 1 ] idx = np . zeros ( nout_his ) for s in range ( len ( idx )): idx [ s ] = np . argmin ( ( x_coord - x_station [ s ]) ** 2 + ( y_coord - y_station [ s ]) ** 2 ) idx_stations = idx . astype ( int ) return xy_coordinates [ idx_stations , :], idx_stations def initialize ( self , biota : Biota ): \"\"\" Initializes all available output models (His and Map). Args: biota (Biota): Biota model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( biota ) self . map_output . initialize ( biota )","title":"BaseOutputWrapper"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper.__repr__","text":"Representation of Output. Source code in src/core/output/base_output_wrapper.py 39 40 41 def __repr__ ( self ): \"\"\"Representation of Output.\"\"\" return f \"Output(xy_coordinates= { self . xy_coordinates } , first_date= { self . first_date } )\"","title":"__repr__()"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper.__str__","text":"String-representation of Output. Source code in src/core/output/base_output_wrapper.py 31 32 33 34 35 36 37 def __str__ ( self ): \"\"\"String-representation of Output.\"\"\" return ( f \"Output exported: \\n\\t { self . map_output } \\n\\t { self . his_output } \" if self . defined else \"Output undefined.\" )","title":"__str__()"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper.check_output_dir","text":"Checks an output_dir attribute is given for the output_model instances map_output and his_output . Parameters: Name Type Description Default values dict Dictionary of attribute values given by the user. required Returns: Name Type Description dict dict Dictionary of attribute values with a valid output_dir value. Source code in src/core/output/base_output_wrapper.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @root_validator ( pre = True ) @classmethod def check_output_dir ( cls , values : dict ) -> dict : \"\"\" Checks an `output_dir` attribute is given for the `output_model` instances `map_output` and `his_output`. Args: values (dict): Dictionary of attribute values given by the user. Returns: dict: Dictionary of attribute values with a valid `output_dir` value. \"\"\" def check_output_model_dir ( out_model : dict ) -> Optional [ dict ]: if out_model is None : return None out_dir_val = out_model . get ( \"output_dir\" , None ) if out_dir_val is None : out_model [ \"output_dir\" ] = values [ \"output_dir\" ] return out_model values [ \"map_output\" ] = check_output_model_dir ( values . get ( \"map_output\" , None )) values [ \"his_output\" ] = check_output_model_dir ( values . get ( \"his_output\" , None )) return values","title":"check_output_dir()"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper.defined","text":"Output is defined. Source code in src/core/output/base_output_wrapper.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @property def defined ( self ) -> bool : \"\"\"Output is defined.\"\"\" def output_model_defined ( out_model : OutputProtocol ) -> bool : if out_model is None : return False return ( out_model . output_params is not None and out_model . output_filepath . exists () ) return output_model_defined ( self . map_output ) or output_model_defined ( self . his_output )","title":"defined()"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper.get_xy_stations","text":"Determine space indices based on the (x,y)-coordinates of the stations. Parameters: Name Type Description Default xy_coordinates np . ndarray Input xy-coordinates system. required outpoint np . ndarray Boolean per x-y indicating if his output is desired. required Returns: Type Description Tuple [ np . ndarray , np . ndarray ] Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations Source code in src/core/output/base_output_wrapper.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @staticmethod def get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Determine space indices based on the (x,y)-coordinates of the stations. Args: xy_coordinates (np.ndarray): Input xy-coordinates system. outpoint (np.ndarray): Boolean per x-y indicating if his output is desired. Returns: Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations \"\"\" nout_his = len ( xy_coordinates [ outpoint , 0 ]) x_coord = xy_coordinates [:, 0 ] y_coord = xy_coordinates [:, 1 ] x_station = xy_coordinates [ outpoint , 0 ] y_station = xy_coordinates [ outpoint , 1 ] idx = np . zeros ( nout_his ) for s in range ( len ( idx )): idx [ s ] = np . argmin ( ( x_coord - x_station [ s ]) ** 2 + ( y_coord - y_station [ s ]) ** 2 ) idx_stations = idx . astype ( int ) return xy_coordinates [ idx_stations , :], idx_stations","title":"get_xy_stations()"},{"location":"reference/core/output/output/#src.core.output.base_output_wrapper.BaseOutputWrapper.initialize","text":"Initializes all available output models (His and Map). Parameters: Name Type Description Default biota Biota Biota model to be used in the output. required Source code in src/core/output/base_output_wrapper.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def initialize ( self , biota : Biota ): \"\"\" Initializes all available output models (His and Map). Args: biota (Biota): Biota model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( biota ) self . map_output . initialize ( biota )","title":"initialize()"},{"location":"reference/core/output/output/#output-models","text":"","title":"Output models"},{"location":"reference/core/output/output/#src.core.output.base_output_model.BaseOutput","text":"Bases: BaseModel , ABC Base class containing the generic definition of an output model. Source code in src/core/output/base_output_model.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class BaseOutput ( BaseModel , ABC ): \"\"\" Base class containing the generic definition of an output model. \"\"\" output_dir : Path output_filename : str # Output model attributes. output_params : BaseOutputParameters = BaseOutputParameters () def valid_output ( self ) -> bool : \"\"\" Verifies whether this model can generate valid output. Returns: bool: Output is valid. \"\"\" return self . output_params . valid_output () @property def output_filepath ( self ) -> Path : \"\"\" Gets the full path to the output netcdf file. Returns: Path: Output .nc file. \"\"\" return self . output_dir / self . output_filename def initialize ( self , biota : Optional [ Biota ]): \"\"\" Method to initialize the Output Model based on a given biota model. This method should be implemented in the concrete classes. Args: biota (Optional[Biota]): Base model for the generated output. \"\"\" pass","title":"BaseOutput"},{"location":"reference/core/output/output/#src.core.output.base_output_model.BaseOutput.initialize","text":"Method to initialize the Output Model based on a given biota model. This method should be implemented in the concrete classes. Parameters: Name Type Description Default biota Optional [ Biota ] Base model for the generated output. required Source code in src/core/output/base_output_model.py 50 51 52 53 54 55 56 57 58 def initialize ( self , biota : Optional [ Biota ]): \"\"\" Method to initialize the Output Model based on a given biota model. This method should be implemented in the concrete classes. Args: biota (Optional[Biota]): Base model for the generated output. \"\"\" pass","title":"initialize()"},{"location":"reference/core/output/output/#src.core.output.base_output_model.BaseOutput.output_filepath","text":"Gets the full path to the output netcdf file. Returns: Name Type Description Path Path Output .nc file. Source code in src/core/output/base_output_model.py 40 41 42 43 44 45 46 47 48 @property def output_filepath ( self ) -> Path : \"\"\" Gets the full path to the output netcdf file. Returns: Path: Output .nc file. \"\"\" return self . output_dir / self . output_filename","title":"output_filepath()"},{"location":"reference/core/output/output/#src.core.output.base_output_model.BaseOutput.valid_output","text":"Verifies whether this model can generate valid output. Returns: Name Type Description bool bool Output is valid. Source code in src/core/output/base_output_model.py 31 32 33 34 35 36 37 38 def valid_output ( self ) -> bool : \"\"\" Verifies whether this model can generate valid output. Returns: bool: Output is valid. \"\"\" return self . output_params . valid_output ()","title":"valid_output()"},{"location":"reference/core/output/output/#src.core.output.base_output_model.BaseOutputParameters","text":"Bases: BaseModel , ABC Source code in src/core/output/base_output_model.py 9 10 11 12 13 14 15 16 17 class BaseOutputParameters ( BaseModel , ABC ): def valid_output ( self ) -> bool : \"\"\" Validates whether all the fields from this class have a value. Returns: bool: When all the values are 'filled'. \"\"\" return any ( self . dict () . values ())","title":"BaseOutputParameters"},{"location":"reference/core/output/output/#src.core.output.base_output_model.BaseOutputParameters.valid_output","text":"Validates whether all the fields from this class have a value. Returns: Name Type Description bool bool When all the values are 'filled'. Source code in src/core/output/base_output_model.py 10 11 12 13 14 15 16 17 def valid_output ( self ) -> bool : \"\"\" Validates whether all the fields from this class have a value. Returns: bool: When all the values are 'filled'. \"\"\" return any ( self . dict () . values ())","title":"valid_output()"},{"location":"reference/core/simulation/simulation/","text":"Classes representing the available simulation modes. \u00b6 Biota wrapper \u00b6 BiotaWrapper \u00b6 Bases: BaseModel Structure containing both Biota (input) and its BaseOutputWrapper (output) Source code in src/core/simulation/biota_wrapper.py 9 10 11 12 13 14 15 class BiotaWrapper ( BaseModel ): \"\"\" Structure containing both `Biota` (input) and its `BaseOutputWrapper` (output) \"\"\" biota : Optional [ Biota ] output : Optional [ BaseOutputWrapper ] Base simulation \u00b6 BaseSimulation \u00b6 Bases: BaseModel , ABC Implements the SimulationProtocol . Facade class that can be implemented through an Adapter pattern. Source code in src/core/simulation/base_simulation.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class BaseSimulation ( BaseModel , ABC ): \"\"\" Implements the `SimulationProtocol`. Facade class that can be implemented through an Adapter pattern. \"\"\" mode : str # Directories related to working dir working_dir : Optional [ Path ] = Path . cwd () figures_dir : Path = working_dir / \"figures\" output_dir : Path = working_dir / \"output\" input_dir : Path = working_dir / \"input\" # Other fields. hydrodynamics : Optional [ HydrodynamicProtocol ] environment : Environment = Environment () constants : Optional [ BaseConstants ] # TODO: Replace usage and references (also in protocol) to BiotaWrapper. biota : Optional [ Biota ] output : Optional [ BaseOutputWrapper ] @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) # TODO: add other dependencies based on process switches in self.constants if required def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Biota : pass def run ( self , duration : Optional [ int ] = None ): pass def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass configure_hydrodynamics () abstractmethod \u00b6 Configures the parameters for the HydrodynamicsProtocol . Raises: Type Description NotImplementedError When abstract method not defined in concrete class. Source code in src/core/simulation/base_simulation.py 65 66 67 68 69 70 71 72 73 @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError configure_output () abstractmethod \u00b6 Configures the parameters for the OutputWrapper . Source code in src/core/simulation/base_simulation.py 75 76 77 78 79 80 @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError finalise () \u00b6 Finalise simulation. Source code in src/core/simulation/base_simulation.py 134 135 136 def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass validate_environment () \u00b6 Check input; if all required data is provided. Source code in src/core/simulation/base_simulation.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) validate_hydrodynamics_present ( field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol classmethod \u00b6 Validator to transform the given dictionary into the corresponding hydrodynamic model. Parameters: Name Type Description Default field_values Union [ dict , HydrodynamicProtocol ] Value assigned to hydrodynamics . required values dict Dictionary of values given by the user. required Raises: Type Description ValueError When no hydrodynamics model can be built with the given values. Returns: Name Type Description dict HydrodynamicProtocol Validated dictionary of values given by the user. Source code in src/core/simulation/base_simulation.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values validate_simulation_directories () \u00b6 Generates the required directories if they do not exist already. Source code in src/core/simulation/base_simulation.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) Simulation \u00b6 Bases: BaseSimulation Vanilla definition of the BaseSimulation that allows any user to create their flat simulation without pre-defined values. In other words, everything should be built manually. Source code in src/core/simulation/base_simulation.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 class Simulation ( BaseSimulation ): \"\"\" Vanilla definition of the `BaseSimulation` that allows any user to create their flat simulation without pre-defined values. In other words, everything should be built manually. \"\"\" def configure_hydrodynamics ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass def configure_output ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass configure_hydrodynamics () \u00b6 This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py 146 147 148 149 150 def configure_hydrodynamics ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass configure_output () \u00b6 This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py 152 153 154 155 156 def configure_output ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass Multiplebiota base simulation \u00b6 MultipleBiotaBaseSimulation \u00b6 Bases: BaseModel , ABC Implements the MultipleBiotaSimulationProtocol . Facade class that can be implemented through an Adapter pattern. Source code in src/core/simulation/multiplebiota_base_simulation.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class MultipleBiotaBaseSimulation ( BaseModel , ABC ): \"\"\" Implements the `MultipleBiotaSimulationProtocol`. Facade class that can be implemented through an Adapter pattern. \"\"\" mode : str # Directories related to working dir working_dir : Optional [ Path ] = Path . cwd () figures_dir : Path = working_dir / \"figures\" output_dir : Path = working_dir / \"output\" input_dir : Path = working_dir / \"input\" # Other fields. hydrodynamics : Optional [ HydrodynamicProtocol ] environment : Environment = Environment () constants : Optional [ BaseConstants ] biota_wrapper_list : List [ BiotaWrapper ] @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) # TODO: add other dependencies based on process switches in self.constants if required def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Biota : \"\"\" Initiates a MultipleBiota Simulation. Args: x_range (Optional[tuple], optional): Spatial x-range. Defaults to None. y_range (Optional[tuple], optional): Spatial y-range. Defaults to None. value (Optional[float], optional): Biota cover value. Defaults to None. Returns: Biota: Initiated Biota. \"\"\" pass def run ( self , duration : Optional [ int ] = None ): \"\"\" Runs the multiple biota simulation. Args: duration (Optional[int], optional): Duration of the simulation in years. Defaults to None. \"\"\" pass def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass configure_hydrodynamics () abstractmethod \u00b6 Configures the parameters for the HydrodynamicsProtocol . Raises: Type Description NotImplementedError When abstract method not defined in concrete class. Source code in src/core/simulation/multiplebiota_base_simulation.py 64 65 66 67 68 69 70 71 72 @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError configure_output () abstractmethod \u00b6 Configures the parameters for the OutputWrapper . Source code in src/core/simulation/multiplebiota_base_simulation.py 74 75 76 77 78 79 @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError finalise () \u00b6 Finalise simulation. Source code in src/core/simulation/multiplebiota_base_simulation.py 150 151 152 def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass initiate ( x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None ) -> Biota \u00b6 Initiates a MultipleBiota Simulation. Parameters: Name Type Description Default x_range Optional [ tuple ] Spatial x-range. Defaults to None. None y_range Optional [ tuple ] Spatial y-range. Defaults to None. None value Optional [ float ] Biota cover value. Defaults to None. None Returns: Name Type Description Biota Biota Initiated Biota. Source code in src/core/simulation/multiplebiota_base_simulation.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Biota : \"\"\" Initiates a MultipleBiota Simulation. Args: x_range (Optional[tuple], optional): Spatial x-range. Defaults to None. y_range (Optional[tuple], optional): Spatial y-range. Defaults to None. value (Optional[float], optional): Biota cover value. Defaults to None. Returns: Biota: Initiated Biota. \"\"\" pass run ( duration : Optional [ int ] = None ) \u00b6 Runs the multiple biota simulation. Parameters: Name Type Description Default duration Optional [ int ] Duration of the simulation in years. Defaults to None. None Source code in src/core/simulation/multiplebiota_base_simulation.py 141 142 143 144 145 146 147 148 def run ( self , duration : Optional [ int ] = None ): \"\"\" Runs the multiple biota simulation. Args: duration (Optional[int], optional): Duration of the simulation in years. Defaults to None. \"\"\" pass validate_environment () \u00b6 Check input; if all required data is provided. Source code in src/core/simulation/multiplebiota_base_simulation.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) validate_hydrodynamics_present ( field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol classmethod \u00b6 Validator to transform the given dictionary into the corresponding hydrodynamic model. Parameters: Name Type Description Default field_values Union [ dict , HydrodynamicProtocol ] Value assigned to hydrodynamics . required values dict Dictionary of values given by the user. required Raises: Type Description ValueError When no hydrodynamics model can be built with the given values. Returns: Name Type Description dict HydrodynamicProtocol Validated dictionary of values given by the user. Source code in src/core/simulation/multiplebiota_base_simulation.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values validate_simulation_directories () \u00b6 Generates the required directories if they do not exist already. Source code in src/core/simulation/multiplebiota_base_simulation.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) Simulation Protocol \u00b6 SimulationProtocol \u00b6 Bases: Protocol Protocol to define simulations for the NBSDynamics project. Source code in src/core/simulation/simulation_protocol.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 @runtime_checkable class SimulationProtocol ( Protocol ): \"\"\" Protocol to define simulations for the `NBSDynamics` project. \"\"\" @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\" @property def biota ( self ) -> Biota : \"\"\" Instance of a Biota model object. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Biota instance. \"\"\" raise NotImplementedError @property def output ( self ) -> BaseOutputWrapper : \"\"\" Wrapper containing different output models. Raises: NotImplementedError: When the model does not implement its own definition. Returns: OutputWrapper: Instance of OutputWrapper. \"\"\" raise NotImplementedError def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError biota () -> Biota property \u00b6 Instance of a Biota model object. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Biota Biota Biota instance. Source code in src/core/simulation/simulation_protocol.py 67 68 69 70 71 72 73 74 75 76 77 78 @property def biota ( self ) -> Biota : \"\"\" Instance of a Biota model object. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Biota instance. \"\"\" raise NotImplementedError constants () -> BaseConstants property \u00b6 Constants being used for calculations during simulation. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants BaseConstants Instance of Constants. Source code in src/core/simulation/simulation_protocol.py 55 56 57 58 59 60 61 62 63 64 65 @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\" environment () -> Environment property \u00b6 Environment in which the simulation takes place. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Environment Environment Instantiated environment. Source code in src/core/simulation/simulation_protocol.py 42 43 44 45 46 47 48 49 50 51 52 53 @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError finalise () \u00b6 Finalizes simulation Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py 122 123 124 125 126 127 128 129 def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError hydrodynamics () -> HydrodynamicProtocol property \u00b6 Instance of hydrodynamic model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol Instantiated object. Source code in src/core/simulation/simulation_protocol.py 29 30 31 32 33 34 35 36 37 38 39 40 @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError initiate ( x_range : tuple , y_range : tuple , value : float ) -> Biota \u00b6 Initiates the simulation attributes with the given parameters. Parameters: Name Type Description Default x_range tuple Minimum and maximum x-coordinate. required y_range tuple Minimum and maximum y-coordinate. required value float Biota cover. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Biota Biota Initiated Biota object. Source code in src/core/simulation/simulation_protocol.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError mode () -> str property \u00b6 Name of the mode the simulation should run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str Hydrodynamic mode name. Source code in src/core/simulation/simulation_protocol.py 16 17 18 19 20 21 22 23 24 25 26 27 @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError output () -> BaseOutputWrapper property \u00b6 Wrapper containing different output models. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description OutputWrapper BaseOutputWrapper Instance of OutputWrapper. Source code in src/core/simulation/simulation_protocol.py 80 81 82 83 84 85 86 87 88 89 90 91 @property def output ( self ) -> BaseOutputWrapper : \"\"\" Wrapper containing different output models. Raises: NotImplementedError: When the model does not implement its own definition. Returns: OutputWrapper: Instance of OutputWrapper. \"\"\" raise NotImplementedError run ( duration : int ) \u00b6 Run the simulation with the initiated attributes. Parameters: Name Type Description Default duration int Simulation duration [yrs]. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py 110 111 112 113 114 115 116 117 118 119 120 def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Multiplebiota simulation Protocol \u00b6 MultipleBiotaSimulationProtocol \u00b6 Bases: Protocol Source code in src/core/simulation/multiplebiota_simulation_protocol.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @runtime_checkable class MultipleBiotaSimulationProtocol ( Protocol ): @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\" @property def biota_wrapper_list ( self ) -> List [ BiotaWrapper ]: \"\"\" List of `BiotaWrapper` model object containing a `Biota` and `BaseOutputWrapper` each. Raises: NotImplementedError: When the model does not implement its own definition. Returns: List[BiotaWrapper]: List of available `BiotaWrapper`. \"\"\" raise NotImplementedError def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError biota_wrapper_list () -> List [ BiotaWrapper ] property \u00b6 List of BiotaWrapper model object containing a Biota and BaseOutputWrapper each. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description List [ BiotaWrapper ] List[BiotaWrapper]: List of available BiotaWrapper . Source code in src/core/simulation/multiplebiota_simulation_protocol.py 63 64 65 66 67 68 69 70 71 72 73 74 @property def biota_wrapper_list ( self ) -> List [ BiotaWrapper ]: \"\"\" List of `BiotaWrapper` model object containing a `Biota` and `BaseOutputWrapper` each. Raises: NotImplementedError: When the model does not implement its own definition. Returns: List[BiotaWrapper]: List of available `BiotaWrapper`. \"\"\" raise NotImplementedError constants () -> BaseConstants property \u00b6 Constants being used for calculations during simulation. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants BaseConstants Instance of Constants. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 51 52 53 54 55 56 57 58 59 60 61 @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\" environment () -> Environment property \u00b6 Environment in which the simulation takes place. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Environment Environment Instantiated environment. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 38 39 40 41 42 43 44 45 46 47 48 49 @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError finalise () \u00b6 Finalizes simulation Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 105 106 107 108 109 110 111 112 def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError hydrodynamics () -> HydrodynamicProtocol property \u00b6 Instance of hydrodynamic model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol Instantiated object. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 25 26 27 28 29 30 31 32 33 34 35 36 @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError initiate ( x_range : tuple , y_range : tuple , value : float ) -> Biota \u00b6 Initiates the simulation attributes with the given parameters. Parameters: Name Type Description Default x_range tuple Minimum and maximum x-coordinate. required y_range tuple Minimum and maximum y-coordinate. required value float Biota cover. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Biota Biota Initiated Biota object. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError mode () -> str property \u00b6 Name of the mode the simulation should run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str Hydrodynamic mode name. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 12 13 14 15 16 17 18 19 20 21 22 23 @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError run ( duration : int ) \u00b6 Run the simulation with the initiated attributes. Parameters: Name Type Description Default duration int Simulation duration [yrs]. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 93 94 95 96 97 98 99 100 101 102 103 def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"Simulation"},{"location":"reference/core/simulation/simulation/#classes-representing-the-available-simulation-modes","text":"","title":"Classes representing the available simulation modes."},{"location":"reference/core/simulation/simulation/#biota-wrapper","text":"","title":"Biota wrapper"},{"location":"reference/core/simulation/simulation/#src.core.simulation.biota_wrapper.BiotaWrapper","text":"Bases: BaseModel Structure containing both Biota (input) and its BaseOutputWrapper (output) Source code in src/core/simulation/biota_wrapper.py 9 10 11 12 13 14 15 class BiotaWrapper ( BaseModel ): \"\"\" Structure containing both `Biota` (input) and its `BaseOutputWrapper` (output) \"\"\" biota : Optional [ Biota ] output : Optional [ BaseOutputWrapper ]","title":"BiotaWrapper"},{"location":"reference/core/simulation/simulation/#base-simulation","text":"","title":"Base simulation"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation","text":"Bases: BaseModel , ABC Implements the SimulationProtocol . Facade class that can be implemented through an Adapter pattern. Source code in src/core/simulation/base_simulation.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class BaseSimulation ( BaseModel , ABC ): \"\"\" Implements the `SimulationProtocol`. Facade class that can be implemented through an Adapter pattern. \"\"\" mode : str # Directories related to working dir working_dir : Optional [ Path ] = Path . cwd () figures_dir : Path = working_dir / \"figures\" output_dir : Path = working_dir / \"output\" input_dir : Path = working_dir / \"input\" # Other fields. hydrodynamics : Optional [ HydrodynamicProtocol ] environment : Environment = Environment () constants : Optional [ BaseConstants ] # TODO: Replace usage and references (also in protocol) to BiotaWrapper. biota : Optional [ Biota ] output : Optional [ BaseOutputWrapper ] @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) # TODO: add other dependencies based on process switches in self.constants if required def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Biota : pass def run ( self , duration : Optional [ int ] = None ): pass def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass","title":"BaseSimulation"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.configure_hydrodynamics","text":"Configures the parameters for the HydrodynamicsProtocol . Raises: Type Description NotImplementedError When abstract method not defined in concrete class. Source code in src/core/simulation/base_simulation.py 65 66 67 68 69 70 71 72 73 @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError","title":"configure_hydrodynamics()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.configure_output","text":"Configures the parameters for the OutputWrapper . Source code in src/core/simulation/base_simulation.py 75 76 77 78 79 80 @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError","title":"configure_output()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.finalise","text":"Finalise simulation. Source code in src/core/simulation/base_simulation.py 134 135 136 def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass","title":"finalise()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_environment","text":"Check input; if all required data is provided. Source code in src/core/simulation/base_simulation.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" )","title":"validate_environment()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_hydrodynamics_present","text":"Validator to transform the given dictionary into the corresponding hydrodynamic model. Parameters: Name Type Description Default field_values Union [ dict , HydrodynamicProtocol ] Value assigned to hydrodynamics . required values dict Dictionary of values given by the user. required Raises: Type Description ValueError When no hydrodynamics model can be built with the given values. Returns: Name Type Description dict HydrodynamicProtocol Validated dictionary of values given by the user. Source code in src/core/simulation/base_simulation.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values","title":"validate_hydrodynamics_present()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_simulation_directories","text":"Generates the required directories if they do not exist already. Source code in src/core/simulation/base_simulation.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True )","title":"validate_simulation_directories()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.Simulation","text":"Bases: BaseSimulation Vanilla definition of the BaseSimulation that allows any user to create their flat simulation without pre-defined values. In other words, everything should be built manually. Source code in src/core/simulation/base_simulation.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 class Simulation ( BaseSimulation ): \"\"\" Vanilla definition of the `BaseSimulation` that allows any user to create their flat simulation without pre-defined values. In other words, everything should be built manually. \"\"\" def configure_hydrodynamics ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass def configure_output ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass","title":"Simulation"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.Simulation.configure_hydrodynamics","text":"This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py 146 147 148 149 150 def configure_hydrodynamics ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass","title":"configure_hydrodynamics()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.base_simulation.Simulation.configure_output","text":"This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py 152 153 154 155 156 def configure_output ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass","title":"configure_output()"},{"location":"reference/core/simulation/simulation/#multiplebiota-base-simulation","text":"","title":"Multiplebiota base simulation"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation","text":"Bases: BaseModel , ABC Implements the MultipleBiotaSimulationProtocol . Facade class that can be implemented through an Adapter pattern. Source code in src/core/simulation/multiplebiota_base_simulation.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class MultipleBiotaBaseSimulation ( BaseModel , ABC ): \"\"\" Implements the `MultipleBiotaSimulationProtocol`. Facade class that can be implemented through an Adapter pattern. \"\"\" mode : str # Directories related to working dir working_dir : Optional [ Path ] = Path . cwd () figures_dir : Path = working_dir / \"figures\" output_dir : Path = working_dir / \"output\" input_dir : Path = working_dir / \"input\" # Other fields. hydrodynamics : Optional [ HydrodynamicProtocol ] environment : Environment = Environment () constants : Optional [ BaseConstants ] biota_wrapper_list : List [ BiotaWrapper ] @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) # TODO: add other dependencies based on process switches in self.constants if required def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Biota : \"\"\" Initiates a MultipleBiota Simulation. Args: x_range (Optional[tuple], optional): Spatial x-range. Defaults to None. y_range (Optional[tuple], optional): Spatial y-range. Defaults to None. value (Optional[float], optional): Biota cover value. Defaults to None. Returns: Biota: Initiated Biota. \"\"\" pass def run ( self , duration : Optional [ int ] = None ): \"\"\" Runs the multiple biota simulation. Args: duration (Optional[int], optional): Duration of the simulation in years. Defaults to None. \"\"\" pass def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass","title":"MultipleBiotaBaseSimulation"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.configure_hydrodynamics","text":"Configures the parameters for the HydrodynamicsProtocol . Raises: Type Description NotImplementedError When abstract method not defined in concrete class. Source code in src/core/simulation/multiplebiota_base_simulation.py 64 65 66 67 68 69 70 71 72 @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError","title":"configure_hydrodynamics()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.configure_output","text":"Configures the parameters for the OutputWrapper . Source code in src/core/simulation/multiplebiota_base_simulation.py 74 75 76 77 78 79 @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError","title":"configure_output()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.finalise","text":"Finalise simulation. Source code in src/core/simulation/multiplebiota_base_simulation.py 150 151 152 def finalise ( self ): \"\"\"Finalise simulation.\"\"\" pass","title":"finalise()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.initiate","text":"Initiates a MultipleBiota Simulation. Parameters: Name Type Description Default x_range Optional [ tuple ] Spatial x-range. Defaults to None. None y_range Optional [ tuple ] Spatial y-range. Defaults to None. None value Optional [ float ] Biota cover value. Defaults to None. None Returns: Name Type Description Biota Biota Initiated Biota. Source code in src/core/simulation/multiplebiota_base_simulation.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Biota : \"\"\" Initiates a MultipleBiota Simulation. Args: x_range (Optional[tuple], optional): Spatial x-range. Defaults to None. y_range (Optional[tuple], optional): Spatial y-range. Defaults to None. value (Optional[float], optional): Biota cover value. Defaults to None. Returns: Biota: Initiated Biota. \"\"\" pass","title":"initiate()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.run","text":"Runs the multiple biota simulation. Parameters: Name Type Description Default duration Optional [ int ] Duration of the simulation in years. Defaults to None. None Source code in src/core/simulation/multiplebiota_base_simulation.py 141 142 143 144 145 146 147 148 def run ( self , duration : Optional [ int ] = None ): \"\"\" Runs the multiple biota simulation. Args: duration (Optional[int], optional): Duration of the simulation in years. Defaults to None. \"\"\" pass","title":"run()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.validate_environment","text":"Check input; if all required data is provided. Source code in src/core/simulation/multiplebiota_base_simulation.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" )","title":"validate_environment()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.validate_hydrodynamics_present","text":"Validator to transform the given dictionary into the corresponding hydrodynamic model. Parameters: Name Type Description Default field_values Union [ dict , HydrodynamicProtocol ] Value assigned to hydrodynamics . required values dict Dictionary of values given by the user. required Raises: Type Description ValueError When no hydrodynamics model can be built with the given values. Returns: Name Type Description dict HydrodynamicProtocol Validated dictionary of values given by the user. Source code in src/core/simulation/multiplebiota_base_simulation.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values","title":"validate_hydrodynamics_present()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_base_simulation.MultipleBiotaBaseSimulation.validate_simulation_directories","text":"Generates the required directories if they do not exist already. Source code in src/core/simulation/multiplebiota_base_simulation.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True )","title":"validate_simulation_directories()"},{"location":"reference/core/simulation/simulation/#simulation-protocol","text":"","title":"Simulation Protocol"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol","text":"Bases: Protocol Protocol to define simulations for the NBSDynamics project. Source code in src/core/simulation/simulation_protocol.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 @runtime_checkable class SimulationProtocol ( Protocol ): \"\"\" Protocol to define simulations for the `NBSDynamics` project. \"\"\" @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\" @property def biota ( self ) -> Biota : \"\"\" Instance of a Biota model object. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Biota instance. \"\"\" raise NotImplementedError @property def output ( self ) -> BaseOutputWrapper : \"\"\" Wrapper containing different output models. Raises: NotImplementedError: When the model does not implement its own definition. Returns: OutputWrapper: Instance of OutputWrapper. \"\"\" raise NotImplementedError def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"SimulationProtocol"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.biota","text":"Instance of a Biota model object. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Biota Biota Biota instance. Source code in src/core/simulation/simulation_protocol.py 67 68 69 70 71 72 73 74 75 76 77 78 @property def biota ( self ) -> Biota : \"\"\" Instance of a Biota model object. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Biota instance. \"\"\" raise NotImplementedError","title":"biota()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.constants","text":"Constants being used for calculations during simulation. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants BaseConstants Instance of Constants. Source code in src/core/simulation/simulation_protocol.py 55 56 57 58 59 60 61 62 63 64 65 @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\"","title":"constants()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.environment","text":"Environment in which the simulation takes place. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Environment Environment Instantiated environment. Source code in src/core/simulation/simulation_protocol.py 42 43 44 45 46 47 48 49 50 51 52 53 @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError","title":"environment()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.finalise","text":"Finalizes simulation Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py 122 123 124 125 126 127 128 129 def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.hydrodynamics","text":"Instance of hydrodynamic model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol Instantiated object. Source code in src/core/simulation/simulation_protocol.py 29 30 31 32 33 34 35 36 37 38 39 40 @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError","title":"hydrodynamics()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.initiate","text":"Initiates the simulation attributes with the given parameters. Parameters: Name Type Description Default x_range tuple Minimum and maximum x-coordinate. required y_range tuple Minimum and maximum y-coordinate. required value float Biota cover. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Biota Biota Initiated Biota object. Source code in src/core/simulation/simulation_protocol.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.mode","text":"Name of the mode the simulation should run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str Hydrodynamic mode name. Source code in src/core/simulation/simulation_protocol.py 16 17 18 19 20 21 22 23 24 25 26 27 @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError","title":"mode()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.output","text":"Wrapper containing different output models. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description OutputWrapper BaseOutputWrapper Instance of OutputWrapper. Source code in src/core/simulation/simulation_protocol.py 80 81 82 83 84 85 86 87 88 89 90 91 @property def output ( self ) -> BaseOutputWrapper : \"\"\" Wrapper containing different output models. Raises: NotImplementedError: When the model does not implement its own definition. Returns: OutputWrapper: Instance of OutputWrapper. \"\"\" raise NotImplementedError","title":"output()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.run","text":"Run the simulation with the initiated attributes. Parameters: Name Type Description Default duration int Simulation duration [yrs]. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py 110 111 112 113 114 115 116 117 118 119 120 def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"run()"},{"location":"reference/core/simulation/simulation/#multiplebiota-simulation-protocol","text":"","title":"Multiplebiota simulation Protocol"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol","text":"Bases: Protocol Source code in src/core/simulation/multiplebiota_simulation_protocol.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @runtime_checkable class MultipleBiotaSimulationProtocol ( Protocol ): @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\" @property def biota_wrapper_list ( self ) -> List [ BiotaWrapper ]: \"\"\" List of `BiotaWrapper` model object containing a `Biota` and `BaseOutputWrapper` each. Raises: NotImplementedError: When the model does not implement its own definition. Returns: List[BiotaWrapper]: List of available `BiotaWrapper`. \"\"\" raise NotImplementedError def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"MultipleBiotaSimulationProtocol"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.biota_wrapper_list","text":"List of BiotaWrapper model object containing a Biota and BaseOutputWrapper each. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description List [ BiotaWrapper ] List[BiotaWrapper]: List of available BiotaWrapper . Source code in src/core/simulation/multiplebiota_simulation_protocol.py 63 64 65 66 67 68 69 70 71 72 73 74 @property def biota_wrapper_list ( self ) -> List [ BiotaWrapper ]: \"\"\" List of `BiotaWrapper` model object containing a `Biota` and `BaseOutputWrapper` each. Raises: NotImplementedError: When the model does not implement its own definition. Returns: List[BiotaWrapper]: List of available `BiotaWrapper`. \"\"\" raise NotImplementedError","title":"biota_wrapper_list()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.constants","text":"Constants being used for calculations during simulation. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Constants BaseConstants Instance of Constants. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 51 52 53 54 55 56 57 58 59 60 61 @property def constants ( self ) -> BaseConstants : \"\"\" Constants being used for calculations during simulation. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Constants: Instance of Constants. \"\"\"","title":"constants()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.environment","text":"Environment in which the simulation takes place. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Environment Environment Instantiated environment. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 38 39 40 41 42 43 44 45 46 47 48 49 @property def environment ( self ) -> Environment : \"\"\" Environment in which the simulation takes place. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Environment: Instantiated environment. \"\"\" raise NotImplementedError","title":"environment()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.finalise","text":"Finalizes simulation Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 105 106 107 108 109 110 111 112 def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.hydrodynamics","text":"Instance of hydrodynamic model. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description HydrodynamicProtocol HydrodynamicProtocol Instantiated object. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 25 26 27 28 29 30 31 32 33 34 35 36 @property def hydrodynamics ( self ) -> HydrodynamicProtocol : \"\"\" Instance of hydrodynamic model. Raises: NotImplementedError: When the model does not implement its own definition. Returns: HydrodynamicProtocol: Instantiated object. \"\"\" raise NotImplementedError","title":"hydrodynamics()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.initiate","text":"Initiates the simulation attributes with the given parameters. Parameters: Name Type Description Default x_range tuple Minimum and maximum x-coordinate. required y_range tuple Minimum and maximum y-coordinate. required value float Biota cover. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description Biota Biota Initiated Biota object. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Biota : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Biota cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Biota: Initiated Biota object. \"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.mode","text":"Name of the mode the simulation should run. Raises: Type Description NotImplementedError When the model does not implement its own definition. Returns: Name Type Description str str Hydrodynamic mode name. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 12 13 14 15 16 17 18 19 20 21 22 23 @property def mode ( self ) -> str : \"\"\" Name of the mode the simulation should run. Raises: NotImplementedError: When the model does not implement its own definition. Returns: str: Hydrodynamic mode name. \"\"\" raise NotImplementedError","title":"mode()"},{"location":"reference/core/simulation/simulation/#src.core.simulation.multiplebiota_simulation_protocol.MultipleBiotaSimulationProtocol.run","text":"Run the simulation with the initiated attributes. Parameters: Name Type Description Default duration int Simulation duration [yrs]. required Raises: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/multiplebiota_simulation_protocol.py 93 94 95 96 97 98 99 100 101 102 103 def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"run()"}]}